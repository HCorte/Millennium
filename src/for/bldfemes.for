C
C SUBROUTINE BLDFEMES
C $Log:   GXAFXT:[GOLS]BLDFEMES.FOV  $
C  
C     Rev 1.0   17 Apr 1996 12:18:22   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 15:43:16   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - gnfemes.for **
C
*
* ========================================================
* SUBROUTINE BLDFEMES
*
* This subroutine will build the front end message and
* will send it to TCP/IP.
*
* Input parameters:
*
*     OUTSAP      Int*4       Request SAP number
*     MESTYP      Int*4       Message type
*     SUBTYP      Int*4       Message subtype
*     MSGID       Int*4       PC message identifier
*     MSGSEQ      Int*4       Message sequence number
*
* Ouput paramters:
*
*     MESLEN      Int*4       Message length
*
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE BLDFEMES(OUTSAP,MESTYP,SUBTYP,MSGID,MSGSEQ,MESLEN)
	IMPLICIT NONE
*
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
*
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:GNSMES.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
*
	INTEGER*4   OUTSAP              !Connection number
	INTEGER*4   MESTYP              !Message type
	INTEGER*4   SUBTYP              !Message subtype
	INTEGER*4   MSGID               !PC message identifier
	INTEGER*4   MSGSEQ              !Message sequence number
	INTEGER*4   MESLEN              !Message length
	INTEGER*4   MESS(400)           !Output buffer
	INTEGER*4   OFF                 !Data message offset
	INTEGER*4   CURTIM              !Current system time
	INTEGER*4   FEID		!Frontend ID
	INTEGER*4   FESTA		!Frontend status
	INTEGER*4   LSTACT		!Last active
	INTEGER*4   HSTSNT		!# of messages sent by host
	INTEGER*4   STNSNT		!# of messages sent by station
	INTEGER*4   BLKCNT		!# of blocks sent
	INTEGER*4   SEQCNT		!
	INTEGER*4   SEQERR		!# of sequence errors
	INTEGER*4   LANDEL		!LAN delay
	INTEGER*4   CURCAP		!Current capacity
	INTEGER*4   LOCPRT		!# of local ports
	INTEGER*4   I
	INTEGER*4   SITE		!Site location
	INTEGER*4   NETPRT		!Network port
	INTEGER*4   FETYP		!Frontend type
*
* CHECK FOR A VALID SAP NUMBER.
*
	IF(OUTSAP.LT.1 .OR. OUTSAP.GT.X2X_SAP) THEN
	  MESLEN=-1
	  GOTO 8000
	ENDIF
*
* EXTRACT INFORMATION FOR FRONT END.
*
	FEID   = X2XE_FE_ID(OUTSAP)                 !Front end id
	FESTA  = X2XE_ACT_STATUS(OUTSAP)            !Current status
	LSTACT = X2XE_TIME(OUTSAP)                  !Last time active
	HSTSNT = X2XE_TOT_MSG_CNT(OUTSAP)           !Message count
	STNSNT = X2XE_STATION_MSG_CNT(OUTSAP)       !Station messages
	BLKCNT = X2XE_CNT_BLK(OUTSAP)               !Transport blk count
	SEQERR = X2XE_CNT_ERR(OUTSAP)               !Sequence errors
	LANDEL = X2XE_DELAY(OUTSAP)                 !Ethernet delay
	CURCAP = X2XE_CAPACITY(OUTSAP)              !Current capacity
*
* IF THE FRONT END IS NOT ACTIVE, DO NOT SEND ANY
* MESSAGES.
*
	IF(FESTA.EQ.0) GOTO 8000
*
* DETERMINE THE SITE BY FINDING A LOCAL PORT WHICH IS CONNECTED
* TO THIS FRONT END.
*
	LOCPRT=0
	I=0
100	CONTINUE
	I=I+1
	IF(X2XPL_SAP(I).EQ.OUTSAP) THEN
	  LOCPRT=I
	ELSE
	  IF(I.LT.X2X_LOCAL_PORTS) GOTO 100
	ENDIF
	SITE=0
	IF(LOCPRT.NE.0) SITE=X2XPL_SITE(LOCPRT)
*
* DETERMINE THE FRONT END TYPE BY CONNECTING THE LOCAL PORT
* TO A NETWORK PORT, AND DETERMINING THE TYPE OF THE NETWORK
* PORT.
*
	NETPRT=0
	FETYP=0
	IF(LOCPRT.NE.0) NETPRT=X2XPL_LOCAL_TO_NETWORK(LOCPRT)
	IF(NETPRT.NE.0) FETYP=X2XPN_TYPE(NETPRT)
*
* VALID FRONT END, BUILD HEADER MESSAGE.
*
	MSGSEQ=MSGSEQ+1
	CALL ISBYTE(GNHDRMES_PROTID_VAL,MESS,GNDWNMES_PROTID-1)
	CALL I4TOBUF2(MESTYP,MESS,GNDWNMES_MESTYP-1)
	CALL ISBYTE(SUBTYP,MESS,GNDWNMES_SUBTYP-1)
	CALL I4TOBUF2(MSGID,MESS,GNDWNMES_MSGID-1)
	CALL I4TOBUF2(MSGSEQ,MESS,GNDWNMES_SEQNUM-1)
	CALL I4TOBUF2(GNDWNMES_CMDDTA,MESS,GNDWNMES_DATOFF-1)
	CURTIM=P(ACTTIM)
	CALL I4TOBUF4(CURTIM,MESS,GNDWNMES_TIME-1)
	CALL ISBYTE(GNDWNMES_FLAGS_DATA,MESS,GNDWNMES_FLAGS-1)
	CALL ISBYTE(0,MESS,GNDWNMES_CMDSTS-1)
	CALL ISBYTE(0,MESS,GNDWNMES_CMDDTA-1)
	OFF=GNDWNMES_CMDDTA
*
* BUILD OUTPUT DATA MESSAGE PORTION.
*
	CALL ISBYTE(OUTSAP,MESS,OFF+GNFEMES_SAP-1)
	CALL I4TOBUF2(FEID,MESS,OFF+GNFEMES_FE-1)
	CALL ISBYTE(FESTA,MESS,OFF+GNFEMES_STATE-1)
	CALL I4TOBUF4(LSTACT,MESS,OFF+GNFEMES_LSTACT-1)
	CALL I4TOBUF4(HSTSNT,MESS,OFF+GNFEMES_HSTMES-1)
	CALL I4TOBUF4(STNSNT,MESS,OFF+GNFEMES_STNMES-1)
	CALL I4TOBUF2(SEQERR,MESS,OFF+GNFEMES_SEQERR-1)
	CALL I4TOBUF4(BLKCNT,MESS,OFF+GNFEMES_TRNBLK-1)
	CALL I4TOBUF2(LANDEL,MESS,OFF+GNFEMES_LANDEL-1)
	CALL I4TOBUF2(CURCAP,MESS,OFF+GNFEMES_CURCAP-1)
	CALL ISBYTE(FETYP,MESS,OFF+GNFEMES_FETYP-1)
	CALL ISBYTE(SITE,MESS,OFF+GNFEMES_SITE-1)
*
* STORE MESSAGE LENGTH INTO MESSAGE HEADER.
*
	MESLEN=OFF+GNFEMES_SITE
	CALL I4TOBUF2(MESLEN,MESS,GNDWNMES_MESLEN-1)
*
* SEND MESSAGE TO TCP/IP.
*
	CALL TCP_SNDBUF(MESS,MESLEN)
*
* PROGRAM EXIT.
*
8000	CONTINUE
	RETURN
	END
