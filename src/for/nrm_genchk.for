C
C SUBROUTINE GENCHK
C $Log:   GXAFXT:[GOLS]GENCHK.FOV  $
C  
C     Rev 1.0   17 Apr 1996 13:17:56   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 16:23:38   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - nrm_scram.for **
C
C
C
C
C *** GENCHK
C
C This is an internally called subroutine to generate check digits
C
C CALLING SEQUENCE:
C	 CALL GENCHK( CDC, INTSER, EXTSER, CHKDIG, SYSIDX)
C
C INPUT:
C	 CDC	    CDC date of ticket
C	 INTSER	    Internal serial #
C	 EXTSER	    External serial #
C	 SYSIDX	    Value of SYSIDC
C
C OUTPUT:
C	 CHKDIG	    Check digits
C
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GENCHK ( CDC, INTSER, EXTSER, CHKDIG, SYSIDX)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
C
	INTEGER*4      CDC
	INTEGER*4      INTSER
	INTEGER*4      EXTSER
	INTEGER*4      CHKDIG
	INTEGER*4      SYSIDX
C
C
	INTEGER*4       EVN
	PARAMETER      (EVN = 0)
	INTEGER*4       ODD
	PARAMETER      (ODD = 1)
C
	INTEGER*4      K
C
	INTEGER*4      PARITY(0:255)
	DATA (PARITY(K),K=0,63)/
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !00-07
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !08-0F
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !10-17
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !18-1F
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !20-27
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !28-2F
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !30-37
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN/    !38-3F
	DATA (PARITY(K),K=64,127)/
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !40-47
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !48-4F
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !50-57
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !58-5F
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !60-67
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !68-6F
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !70-77
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD/    !78-7F
	DATA (PARITY(K),K=128,191)/
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !80-87
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !88-8F
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !90-97
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !98-9F
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !A0-A7
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !A8-AF
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !B0-B7
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD/    !B8-BF
	DATA (PARITY(K),K=192,255)/
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !C0-C7
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !C8-CF
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !D0-D7
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !D8-DF
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN,    !E0-E7
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !E8-EF
     *	  EVN,ODD,ODD,EVN,ODD,EVN,EVN,ODD,    !F0-F7
     *	  ODD,EVN,EVN,ODD,EVN,ODD,ODD,EVN/    !F8-FF
C
	INTEGER*4       MASK1
	PARAMETER      (MASK1 = '0000CCCC'X)
	INTEGER*4       MASK2
	PARAMETER      (MASK2 = '00005555'X)
	INTEGER*4       MASK3
	PARAMETER      (MASK3 = '0000AAAA'X)
C
	INTEGER*4      X,CHK,EXT,R5,R6,R7,INTHI
C
C
C
	X   = IAND ( CDC, '00000003'X)      !LOW 2 BITS
	INTHI = ISHFT( INTSER, -24)         !LOW 3 BITS OF HIGH BYTE
	INTHI = IAND ( INTHI, '00000007'X)
	CHK   = ISHFT(X,3) + INTHI
C
C Now get high 3 bits of the check digit
C
	EXT = IAND (EXTSER, '000000FF'X)    !LOW BYTE
	R5  = IAND (EXT, MASK1)
	R6  = IAND (EXT, MASK2)
	R7  = IAND (EXT, MASK3)
	IF( PARITY(R5).EQ.ODD) CHK = IEOR(CHK,'00000080'X)
	IF( PARITY(R6).EQ.ODD) CHK = IEOR(CHK,'00000040'X)
	IF( PARITY(R7).EQ.ODD) CHK = IEOR(CHK,'00000020'X)
C
	EXT = IAND (EXTSER, '0000FF00'X)    !MIDDLE BYTE
	EXT = ISHFT(EXT, -8)
	R5  = IAND (EXT, MASK1)
	R6  = IAND (EXT, MASK2)
	R7  = IAND (EXT, MASK3)
	IF( PARITY(R5).EQ.ODD) CHK = IEOR(CHK,'00000080'X)
	IF( PARITY(R6).EQ.ODD) CHK = IEOR(CHK,'00000040'X)
	IF( PARITY(R7).EQ.ODD) CHK = IEOR(CHK,'00000020'X)
C
	EXT = IAND (EXTSER, '00FF0000'X)    !HIGH BYTE
	EXT = ISHFT(EXT, -16)
	R5  = IAND (EXT, MASK1)
	R6  = IAND (EXT, MASK2)
	R7  = IAND (EXT, MASK3)
	IF( PARITY(R5).EQ.ODD) CHK = IEOR(CHK,'00000080'X)
	IF( PARITY(R6).EQ.ODD) CHK = IEOR(CHK,'00000040'X)
	IF( PARITY(R7).EQ.ODD) CHK = IEOR(CHK,'00000020'X)
C
	EXT = INTHI                         !HI 3 BITS OF INTERNAL
	R5  = IAND (EXT, MASK1)
	R6  = IAND (EXT, MASK2)
	R7  = IAND (EXT, MASK3)
	IF( PARITY(R5).EQ.ODD) CHK = IEOR(CHK,'00000080'X)
	IF( PARITY(R6).EQ.ODD) CHK = IEOR(CHK,'00000040'X)
	IF( PARITY(R7).EQ.ODD) CHK = IEOR(CHK,'00000020'X)
C
C Add in system ID
C
	CHK = CHK + SYSIDX
C
C Now mix up with external serial #
C
	CALL MIXCHK( EXTSER, CHK)
	CHKDIG = CHK
C
	RETURN
	END
