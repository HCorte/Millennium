C
C PROGRAM MDCMNG (MILLENNIUM DATA COLLECTOR MANAGEMENT)
C
C THIS PROGRAM COLLECTS TRANSACTION DATA FROM MTMF FILE
C AND SEND IT TO EURO MILHOES SYSTEM.
C
C MESSAGES ARE READ FROM QUEUE 5 AND SENT TO QUEUE 4
C
C ** Source - MDCMNG.FOR;1 **
C
C MDCMNG.FOR
C
C V04 21-JUN-2016 SCML M16 PROJECT
C V03 13-JAN-2014 SCML Added support to new validation sub-types
C V02 03-MAY-2011 ACN  Added new transactions: Validation and Sign-on
C                      Added new game: Passive
C V01 03-ABR-2009 ACN  INITIAL RELEASE
C
C=======OPTIONS /CHECK=NOOVERFLOW/EXT
        PROGRAM MDCMNG
        IMPLICIT NONE

        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:CONCOM.DEF'
        INCLUDE 'INCLIB:PROCOM.DEF'
        INCLUDE 'INCLIB:AGTCOM.DEF'
        INCLUDE 'INCLIB:DESTRA.DEF'
        INCLUDE 'INCLIB:TASKID.DEF'
        INCLUDE 'INCLIB:PRMLOG.DEF'
        INCLUDE 'INCLIB:CHKSUMCM.DEF'
        INCLUDE 'INCLIB:QUECOM.DEF'
        INCLUDE 'INCLIB:APUCOM.DEF'
        INCLUDE 'INCLIB:EURCON.DEF'
        INCLUDE 'INCLIB:DATBUF.DEF'

        INTEGER*4 STATUS,ST
        INTEGER*4 MESSERIAL,SEROFFSET
        INTEGER*4 MINSERIAL ! MINIMUM SERIAL NUMBER
        INTEGER*4 MAXSERIAL ! MAXIMUM SERIAL NUMBER
        INTEGER*4 MAXTRIES  ! MAXIMUM NUMBER OF RETRIES TO DO ATTACH TO MESSAGE QUEUE
        INTEGER*4 CURRTRY   ! CURRENT NUMBER OF MESSAGE QUEUE ATTACHMENT RETRIES
        INTEGER*4 FILENAME(4)
        LOGICAL EOT/.FALSE./
        LOGICAL ERROR_READ/.FALSE./
        LOGICAL CONEURO,FIRSTRUN
        LOGICAL INITFLAG/.TRUE./

        PARAMETER(MAXTRIES = 6)
        PARAMETER(MINSERIAL = 0)
        PARAMETER(MAXSERIAL = 999999999)

        CALL OPSTXT(' Copyright 2009 SCML/Accenture. All rights reserved. ')
        CALL SNIF_AND_WRKSET

        CURRTRY = 0
        MESSERIAL = 0
        SEROFFSET = 0
        CONEURO = .FALSE.
        FIRSTRUN = .FALSE.
        CALL OPSTXT(' ******************* MDCMNG *******************')

        FILENAME(1) = 'PRIM'
        FILENAME(2) = ':MTM'
        FILENAME(3) = 'F01.'
        FILENAME(4) = 'FIL'

        CALL OPSTXT(' INFO - MAIN - OPENING MTMF FILE')
        TYPE*,' INFO - MAIN - OPENING MTMF FILE'
        CALL OPENWY(1,FILENAME,0,4,0,ST)
C       CALL TOPEN(1)

        IF(ST.NE.0) THEN
          CALL FILERR(FILENAME,1,ST,0)
          CALL OPSTXT(' FATAL - MAIN - ERROR OPENING MTMF FILE')
          TYPE*,' FATAL - MAIN - ERROR OPENING MTMF FILE'
          CALL GSTOP(GEXIT_FATAL)
        ENDIF
C
C WAIT FOR SOMETHING TO DO
C IF END OF DAY THEN CALL GSTOP(GEXIT_SUCCESS)
C
10      CONTINUE
C
C IF DAYCLOSE THEN SEND STOP... IF SYSTEM IS LIVE THEN DISCONNECT TO EURO MILHOES MESSAGEQ
C

C       DAYSTS = DSCLOS

        IF (DAYSTS .EQ. DSCLOS) THEN
C          IF (P(SYSTYP) .EQ. LIVSYS) THEN
              CALL MESSQ_EXIT(%REF(ST))
              CALL OPSTXT(' INFO - MAIN - EURO MILHOES IS DISCONNECTED!')
              TYPE*,' INFO - MAIN - EURO MILHOES IS DISCONNECTED!'
              TYPE*,' INFO - MAIN - MDCMNG EXITED SUCCESSFULLY!'
C          ENDIF
           CONEURO = .FALSE.
           CALL GSTOP(GEXIT_SUCCESS)
        ENDIF
C
C IF NOT LIVE SYSTEM THEN WAIT
C
C       IF (P(SYSTYP) .NE. LIVSYS) THEN
C          CALL XWAIT(5,2,ST)
C          FIRSTRUN = .TRUE.
C        GOTO 10
C       ENDIF
C
C IF DAY IS SUSPENDED STAY ON HOLD
C
        IF(DAYSTS .EQ. DSSUSP) THEN
          CALL HOLD(0,STATUS)
          IF(DAYSTS .EQ. DSOPEN) GOTO 10
          GOTO 10
        ENDIF
C
C IF NO CONNECTION TO EURO MILHOES THEN TRY TO CONNECT TO MESSAGEQ
C IF ONE ERROR OCCURS SEND ERROR MESSAGE AND TRY AGAIN
C

543     CONTINUE

C
C CHECKS THE NUMBER OF ATTACHMENT RETRIES
C EXITS THE PROGRAM IF MAXIMUM NUMBER IS REACHED
C
        IF (CURRTRY .GT. MAXTRIES) THEN
          CALL OPS('FATAL - MAIN - CAN NOT ATTACH TO MESSAGEQ!',CURRTRY,0)
          TYPE*,'FATAL - MAIN - CAN NOT ATTACH TO MESSAGEQ - MAXIMUM NUMBER OF RETRIES REACHED!'
          CALL GSTOP(GEXIT_FATAL)
        ENDIF

        IF (CONEURO .EQ. .FALSE.) THEN
          CALL OPSTXT(' INFO - MAIN - MESSAGEQ WILL BE NOW ATTACHED...')
          TYPE*,' INFO - MAIN - MESSAGEQ WILL BE NOW ATTACHED...'
          CALL MESSQ_ATTACH(%REF(ST))
          IF (ST .NE. PAMS__SUCCESS) THEN
            CALL OPS('ERROR - MAIN - CANNOT ATTACH TO MESSAGEQ!',ST,0)
            TYPE*,'ERROR - MAIN - CANNOT ATTACH TO MESSAGEQ! (STATUS = ',ST,')'
            CURRTRY = CURRTRY + 1
            CALL MESSQ_EXIT(%REF(ST))
            GOTO 10   ! ST = 1 ATTACH SUCCESS
          ELSE
            CURRTRY = 0
            CALL OPSTXT(' INFO - MAIN - MESSAGEQ ATTACHED SUCCESSFULLY!')
            TYPE*,' INFO - MAIN - MESSAGEQ ATTACHED SUCCESSFULLY!'
          ENDIF
          CONEURO = .TRUE.
        ENDIF

333     CONTINUE
C
C INIT_PROCESS FUNCTION STARTS THE PROCESS
C
        IF (INITFLAG .EQ. .TRUE.) THEN
          ST = PAMS__SUCCESS
          CALL OPSTXT(' INFO - MAIN - INIT_PROCESS STARTED.')
          TYPE*,' INFO - MAIN - INIT_PROCESS STARTED.'
          CALL INIT_PROCESS(ST,SEROFFSET)
!         TYPE*,' INFO: SERIAL RECEIVED FROM DM ON DAY STARTUP: ',SEROFFSET

          IF (ST .EQ. PAMS__SUCCESS) THEN
            CALL OPSTXT(' INFO - MAIN - INIT_PROCESS ENDED SUCCESSFULLY!')
            CALL OPSTXT(' INFO - MAIN - SENDING OF DATA MINING MESSAGES WILL BEGIN...')
            TYPE*,' INFO - MAIN - INIT_PROCESS ENDED SUCCESSFULLY!'
            TYPE*,' INFO - MAIN - SENDING OF DATA MINING MESSAGES WILL BEGIN...'
            INITFLAG = .FALSE.
            GOTO 20
          ENDIF

          IF ((ST .NE. PAMS__SUCCESS ) .AND. (ST .NE. PAMS__TIMEOUT)) THEN
            CALL OPS('ERROR - MAIN - INIT_PROCESS ENDED WITH BAD STATUS!',ST,0)
            CALL OPSTXT(' INFO - MAIN - MESSAGEQ WILL BE DETACHED!')
            TYPE*,'ERROR - MAIN - INIT_PROCESS ENDED WITH BAD STATUS: ',ST
            TYPE*,' INFO - MAIN - MESSAGEQ WILL BE DETACHED!'
            CALL MESSQ_EXIT(%REF(ST))
            IF (ST .EQ. PAMS__SUCCESS) THEN
              CALL OPSTXT(' INFO - MAIN - MESSAGEQ DETACHED SUCCESSFULLY!')
              TYPE*,' INFO - MAIN - MESSAGEQ DETACHED SUCCESSFULLY!'
              CONEURO = .FALSE.
              GOTO 543
            ENDIF
            CALL OPS('ERROR - MAIN - MESSAGEQ CANNOT BE DETACHED!',ST,0)
            TYPE*,'ERROR - MAIN - MESSAGEQ CANNOT BE DETACHED! (STATUS = ',ST,')'
            GOTO 10
          ENDIF
        ENDIF
C
C IF NO MORE RESPONSE MESSAGES THEN START TO SEND ALL MESSAGES TO DATA MINING
C UNTIL THERE ARE NO MORE BUFFER TO PROCESS
C
20      CONTINUE

        IF (SEROFFSET .LT. MINSERIAL .OR. SEROFFSET .GT. MAXSERIAL) THEN
          CALL OPS('FATAL - SERIAL OFFSET OUT OF BOUNDS!',SEROFFSET,0)
          TYPE*, 'FATAL - SERIAL OFFSET OUT OF BOUNDS (MIN=,',MINSERIAL,', MAX=',MAXSERIAL,')' ! FATAL
          CALL GSTOP(GEXIT_FATAL)
        ENDIF

        CALL GETTRABUF(TRABUF,SEROFFSET,EOT,ERROR_READ) ! GETS A WAGER OR CANCELLATION TRANSACTION

        IF (.NOT. EOT .AND. .NOT. ERROR_READ) THEN
          CALL SEND_DATA_TO_DM(TRABUF,SEROFFSET,ST)
          IF (ST .NE. PAMS__SUCCESS) THEN
            SEROFFSET = SEROFFSET - 1
            CALL OPS('ERROR - MAIN - SEND_DATA_TO_DM ENDED WITH BAD STATUS!',ST,0)
            CALL OPSTXT(' INFO - MAIN - MESSAGEQ WILL BE DETACHED!')
            TYPE*,'ERROR - MAIN - SEND_DATA_TO_DM ENDED WITH BAD STATUS: ',ST
            TYPE*,' INFO - MAIN - MESSAGEQ WILL BE DETACHED!'
            CALL MESSQ_EXIT(%REF(ST))
            IF (ST .EQ. PAMS__SUCCESS) THEN
              CALL OPSTXT(' INFO - MAIN - MESSAGEQ DETACHED SUCCESSFULLY!')
              TYPE*,' INFO - MAIN - MESSAGEQ DETACHED SUCCESSFULLY!'
              CONEURO = .FALSE.
              GOTO 543
            ENDIF
            CALL OPS('ERROR - MAIN - MESSAGEQ CANNOT BE DETACHED!',ST,0)
            TYPE*,'ERROR - MAIN - MESSAGEQ CANNOT BE DETACHED! (STATUS = ',ST,')'
            GOTO 10
          ENDIF
!       ELSE
!         TYPE*,' INFO - END OF FILE REACHED!'
        ENDIF
C
C CALL PROCESS_MSG_FROM_DM FUNCTION IS USED TO PROCESS MESSAGES FROM DATA MINING SYSTEM
C
        CALL PROCESS_MSG_FROM_DM(ST,SEROFFSET)
        IF ((ST .EQ. PAMS__SUCCESS) .OR. (ST .EQ. PAMS__NOMOREMSG)) GOTO 20
        IF ((ST .NE. PAMS__SUCCESS) .AND. (ST .NE. PAMS__NOMOREMSG)) THEN
          CALL OPS('ERROR - MAIN - PROCESS_MSG_FROM_DM ENDED WITH BAD STATUS!',ST,0)
          CALL OPSTXT(' INFO - MAIN - MESSAGEQ WILL BE DETACHED!')
          TYPE*,'ERROR - MAIN - PROCESS_MSG_FROM_DM ENDED WITH BAD STATUS: ',ST
          TYPE*,' INFO - MAIN - MESSAGEQ WILL BE DETACHED!'
          CALL MESSQ_EXIT(%REF(ST))
          IF (ST .EQ. PAMS__SUCCESS) THEN
            CALL OPSTXT(' INFO - MAIN - MESSAGEQ DETACHED SUCCESSFULLY!')
            TYPE*,' INFO - MAIN - MESSAGEQ DETACHED SUCCESSFULLY!'
            CONEURO = .FALSE.
            IF (EOT) GOTO 10
            GOTO 543
          ENDIF
          CALL OPS('ERROR - MAIN - MESSAGEQ CAN NOT BE DETACHED!',ST,0)
          TYPE*,'ERROR - MAIN - MESSAGEQ CAN NOT BE DETACHED! (STATUS = ',ST,')'
          GOTO 10
        ENDIF
        GOTO 20
      END

C**************************************************
C SUBROUTINE: PROCESS MESSAGES FROM DATA MINING SYSTEM
C
C INPUT: -
C
C OUTPUT:
C        ST - PROCESS STATUS
C    SEROFFSET - NEW SERIAL OFFSET
C
C**************************************************
C
C=======OPTIONS /CHECK=NOOVERFLOW
        SUBROUTINE PROCESS_MSG_FROM_DM(ST,SEROFFSET)
        IMPLICIT NONE

        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:CONCOM.DEF'
        INCLUDE 'INCLIB:PROCOM.DEF'
        INCLUDE 'INCLIB:AGTCOM.DEF'
        INCLUDE 'INCLIB:TASKID.DEF'
        INCLUDE 'INCLIB:PRMLOG.DEF'
        INCLUDE 'INCLIB:CHKSUMCM.DEF'
        INCLUDE 'INCLIB:QUECOM.DEF'
        INCLUDE 'INCLIB:APUCOM.DEF'
        INCLUDE 'INCLIB:EURCON.DEF'
        INCLUDE 'INCLIB:DATBUF.DEF'

        INTEGER*4 I4TEMP
        INTEGER*2 I2TEMP(2)
        BYTE      I1TEMP(4)
        EQUIVALENCE (I4TEMP,I2TEMP,I1TEMP)
        INTEGER*4 ST,STATUS

        INTEGER*4 MSGTYP ! MESSAGE TYPE
        INTEGER*4 MSGSUBTYP ! MESSAGE SUBTYPE
        INTEGER*4 SEROFFSET ! SERIAL OFFSET
        INTEGER*4 DAYOK
        INTEGER*4 DAYNOTOK
        INTEGER*4 ADMINTYP !ADMINISTRATION MESSAGE TYPE
        INTEGER*4 OFFSETREQSUBTYP ! OFFSET REQUEST SUBTYPE
        INTEGER*4 DAYREQSUBTYP ! DAY REQUEST SUBTYPE
        INTEGER*4 OFFSETRESSUBTYP ! OFFSET RESPONSE SUBTYPE
        INTEGER*4 DAYRESSUBTYP ! DAY RESPONSE SUBTYPE
        INTEGER*4 SETOFFSETREQSUBTYP ! SET OFFSET SUBTYPE
        INTEGER*4 SETOFFSETRESSUBTYP ! SET OFFSET RESPONSE SUBTYPE

        PARAMETER(ADMINTYP = 255)
        PARAMETER(OFFSETREQSUBTYP = 0)
        PARAMETER(OFFSETRESSUBTYP = 1)
        PARAMETER(DAYREQSUBTYP = 2)
        PARAMETER(DAYRESSUBTYP = 3)
        PARAMETER(SETOFFSETREQSUBTYP = 4)
        PARAMETER(SETOFFSETRESSUBTYP = 5)

        PARAMETER(DAYOK = 0)
        PARAMETER(DAYNOTOK = 1)
C
C THIS COMMON AREA IS EQUAL TO THE STRUCTURE USED IN MESSAGEQ_MDC.C
C IS USED TO PASS MESSAGES...
C
        COMMON /TO_DATAMINING/MESS_TO_DATAMINING,MESS_TO_LEN
        BYTE MESS_TO_DATAMINING(1024)

        INTEGER*4 MESS_TO_LEN
        INTEGER*4 INDTO
C
C THIS COMMON AREA IS EQUAL TO THE STRUCTURE USED IN MESSAGEQ_MDC.C
C IS USED TO RECEIVE MESSAGES...
C
        COMMON /FROM_DATAMINING/MESS_FROM_DATAMINING,MESS_FROM_LEN
        BYTE MESS_FROM_DATAMINING(1024)
        INTEGER*4 MESS_FROM_LEN

C       TYPE*, ' ' !INFO
C       TYPE*, ' INFO: PROCESS_MSG_FROM_DM CALLED.'

20      CONTINUE
        CALL MESSQ_GET(%REF(STATUS))

        IF (STATUS .EQ. PAMS__SUCCESS) THEN
C
C GET MESSAGE TYPE
C
          I1TEMP(4) = 0
          I1TEMP(3) = 0
          I1TEMP(2) = 0
          I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(1))
          MSGTYP = I4TEMP

          IF (MSGTYP .NE. ADMINTYP) GOTO 20 ! ONLY ADMINISTRATION MESSAGES ALLOWED
C
C GET MESSAGE SUBTYPE
C
          I1TEMP(4) = 0
          I1TEMP(3) = 0
          I1TEMP(2) = 0
          I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(2))
          MSGSUBTYP = I4TEMP

          IF (MSGSUBTYP .NE. SETOFFSETREQSUBTYP) GOTO 20 ! UNSOLICITED MESSAGE

          I1TEMP(4) = ZEXT (MESS_FROM_DATAMINING(3))
          I1TEMP(3) = ZEXT (MESS_FROM_DATAMINING(4))
          I1TEMP(2) = ZEXT (MESS_FROM_DATAMINING(5))
          I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(6))

          SEROFFSET = I4TEMP
          CALL OPS ('DEBUG - PROCESS_MSG_FROM_DM - NEW SERIAL OFFSET RECEIVED: ',SEROFFSET,SEROFFSET)
          TYPE*, ' INFO - PROCESS_MSG_FROM_DM - NEW SERIAL OFFSET RECEIVED: ', SEROFFSET ! INFO

C
C BUILDS THE SET OFFSET MESSAGE RESPONSE
C
30      CONTINUE
C       TYPE*, ' INFO: BUILDING SET OFFSET MESSAGE RESPONSE ...' ! INFO
C
C PUT IN BEGIN (1-1 BYTES) TYPE MESSAGE
C
          INDTO = 0
          I4TEMP = 0
          I4TEMP = ADMINTYP
          MESS_TO_DATAMINING(INDTO+1) = I1TEMP(1)

!         CALL OPS('DEBUG: ADMINTYP SET - 1 BYTE',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (2-2 BYTES) SUBTYPE MESSAGE
C
          INDTO = 1
          I4TEMP = 0
          I4TEMP = SETOFFSETRESSUBTYP
          MESS_TO_DATAMINING(INDTO+1) = I1TEMP(1)

!         CALL OPS('DEBUG: SETOFFSETRESSUBTYP SET - 1 BYTE',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C         MESS_TO_LEN = LENGTH OF MESSAGE SENT TO MESSAGEQ_MDC
C
          MESS_TO_LEN = INDTO + 1

!         CALL OPS('DEBUG: MESS_TO_LEN SET',MESS_TO_LEN,MESS_TO_LEN)

C         TYPE*, ' INFO: BUILD SET OFFSET RESPONSE MESSAGE FINISHED!' ! INFO
C
C CALL C FUNCTION TO PUT THE MESSAGE INTO MESSAGEQ_MDC (QUEUE = 4)
C
          CALL MESSQ_PUT(%REF(STATUS))
C
          IF (STATUS .NE. PAMS__SUCCESS) THEN
            CALL OPS ('ERROR - PROCESS_MSG_FROM_DM - WHILE PUT INTO MESSAGEQ!',STATUS,0)
            TYPE*,'ERROR - PROCESS_MSG_FROM_DM - WHILE PUT INTO MESSAGEQ! (STATUS = ',STATUS,')'
            CALL XWAIT(1,2,ST) ! WAIT FOR 1 SEC AND SEND AGAIN
            GOTO 30
          ENDIF

          ST = STATUS
          RETURN
        ENDIF

C         IF (STATUS .EQ. PAMS__NOMOREMSG) THEN
C           CALL OPS('NAO EXISTEM MSG NA QUEUE',STATUS)
C           TYPE*,' INFO: NEW SERIAL OFFSET WAS NOT RECEIVED'
C           ST = STATUS
C           RETURN
C         ENDIF
        ST = STATUS
        RETURN
        END

C**************************************************
C SUBROUTINE: SENDS MESSAGES TO DATA MINING SYSTEM
C INPUT:
C        TRABUF - CONTAINS THE DATA TO BE SENT
C        SER - SERIAL OF THE MESSAGE
C
C OUTPUT:
C        ST - PROCESS STATUS
C
C**************************************************
C
C=======OPTIONS /CHECK=NOOVERFLOW
        SUBROUTINE SEND_DATA_TO_DM(TRABUF,SER,ST)
        IMPLICIT NONE

        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:CONCOM.DEF'
        INCLUDE 'INCLIB:PROCOM.DEF'
        INCLUDE 'INCLIB:AGTCOM.DEF'
        INCLUDE 'INCLIB:DESTRA.DEF'
        INCLUDE 'INCLIB:TASKID.DEF'
        INCLUDE 'INCLIB:PRMLOG.DEF'
        INCLUDE 'INCLIB:CHKSUMCM.DEF'
        INCLUDE 'INCLIB:QUECOM.DEF'
        INCLUDE 'INCLIB:APUCOM.DEF'
        INCLUDE 'INCLIB:EURCON.DEF'

        INTEGER*4 CSHAMTL, CSHAMTH
        INTEGER*4 I4TEMP, I4TEMP1
        INTEGER*2 I2TEMP(2), I2TEMP1(2)
        BYTE      I1TEMP(4), I1TEMP1(4)
        EQUIVALENCE (I4TEMP,I2TEMP,I1TEMP)
        EQUIVALENCE (I4TEMP1,I2TEMP1,I1TEMP1)
        INTEGER*4 SER
        INTEGER*4 ST,IND,STATUS
        INTEGER*4 THOUR,TMIN,TSECS
        INTEGER*4 TCKS
        INTEGER*4 GAMEUR
        PARAMETER (GAMEUR = 11)                                                 !EUROMILLIONS GAME NUMBER (THE NEXT GAME NUMBER AVAILABLE: 11)
        INTEGER*4 GAMSM                                                         !V04
        PARAMETER (GAMSM  = 12)                                                 !M1LHAO GAME NUMBER (THE NEXT GAME NUMBER AVAILABLE AFTER EUROMILLIONS: 12) !V04
C
C THIS COMMON AREA IS EQUAL TO THE STRUCTURE USED IN MESSAGEQ_MDC.C
C IS USED TO PASS MESSAGE...
C
C MESS_TO_DATAMINING = MESSAGE IN BYTES
C MESS_TO_LEN = MESSAGE LENGTH
C
        COMMON /TO_DATAMINING/MESS_TO_DATAMINING,MESS_TO_LEN
        BYTE MESS_TO_DATAMINING(1024)
        INTEGER*4 MESS_TO_LEN

C       TYPE*, ' ' ! INFO
C       TYPE*, ' INFO: SEND_DATA_TO_DM CALLED.' ! INFO

        ST = 0
        I4TEMP = 0
        I4TEMP1 = 0
        THOUR = 0
        TMIN = 0
        TSECS = 0
        CSHAMTL = 0
        CSHAMTH = 0
!       CALL FASTSET(0,TRABUF,TRALEN)

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                         W A G E R  &  C A N C E L L A T I O N
C                              M E S S A G E S
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        IF(TRABUF(TTYP) .EQ. TWAG .OR. TRABUF(TTYP) .EQ. TCAN) THEN

CC!          TYPE*,' INFO: BUILDING WAGER/CANCELLATION MESSAGE ...'
          !# CALL OPSTXT(' INFO: BUILDING WAGER/CANCELLATION MESSAGE ...')

C
C PUT IN BEGIN (1-1 BYTES) THE TRANSACTION TYPE
C
          I4TEMP = 0
          IND = 0
          I4TEMP = TRABUF(TTYP)

          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: TTYP SET (BYTES 1-1)',I1TEMP(1),I1TEMP(1)) ! DEBUG

C
C PUT IN (2-2 BYTES) THE GAME NUMBER
C
!         I4TEMP = GTNTAB(TRABUF(TGAMTYP),TRABUF(TGAMIND))
          I4TEMP = TRABUF(TGAM)
          IND = 1
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: TGAM SET (BYTES 2-2)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (3-6 BYTES) THE SERIAL NUMBER
C
          I4TEMP = SER
          IND = 2
          MESS_TO_DATAMINING(IND+1) = I1TEMP(4)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+4) = I1TEMP(1)

          !# CALL OPS('DEBUG: TSER SET (BYTES 3-6)',I4TEMP,I4TEMP) ! DEBUG
C
C PUT IN (7-10 BYTES) THE WAGER AMOUNT
C

!         I4TEMP = TRABUF(TWTOT)
          I4TEMP = TRABUF(TWAMT)*TRABUF(TWDUR)
          IND = 6
          MESS_TO_DATAMINING(IND+1) = I1TEMP(4)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+4) = I1TEMP(1)

!         CALL OPS('DEBUG: TWTOT SET (BYTES 7-10)',I4TEMP,I4TEMP) ! DEBUG
          !# CALL OPS('DEBUG: TWAMT SET (BYTES 7-10)',I4TEMP,I4TEMP) ! DEBUG
C
C PUT IN (11-14) THE JOKER AMOUNT
C
          I4TEMP = TRABUF(TWKAMT)*TRABUF(TWDUR)
          IND = 10
          MESS_TO_DATAMINING(IND+1) = I1TEMP(4)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+4) = I1TEMP(1)

          !# CALL OPS('DEBUG: TWKAMT SET (BYTES 11-14)',I4TEMP,I4TEMP) ! DEBUG
C
C PUT IN (15-17 BYTES) THE AGENT NUMBER
C
          I4TEMP = TRABUF(TAGT)
          IND = 14
          MESS_TO_DATAMINING(IND+1) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(1)

          !# CALL OPS('DEBUG: TAGT SET (BYTES 15-17)',I4TEMP,I4TEMP) ! DEBUG
C
          CALL DISTIM(TRABUF(TTIM),THOUR,TMIN,TSECS)
C
C PUT IN (18-18 BYTES) THE HOUR
C
          I4TEMP = THOUR
          IND = 17
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: THOUR SET (BYTES 18-18)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (19-19 BYTES) THE MINUTE
C
          I4TEMP = TMIN
          IND = 18
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: TMIN SET (BYTES 19-19)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (20-20 BYTES) THE SECOND
C
          I4TEMP = TSECS
          IND = 19
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: TSECS SET (BYTES 20-20)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (21-21 BYTES) WAGER QUICK PICK FLAG INDICATOR
C
!          IF (TRABUF(TWQPF) .EQ. 0) THEN
!            I4TEMP = 0
!          ELSE
!            I4TEMP = 1
!          ENDIF
!          IND = 20
!          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)
!
!          CALL OPS('DEBUG: TWQPF SET (BYTES 21-21)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (22-22 BYTES) SYSTEM TYPE FLAG INDICATOR
C
!          IF (TRABUF(TWSYST) .GT. 0) THEN
!            I4TEMP = 1
!          ELSE
!            I4TEMP = 0
!          ENDIF
!          IND = 21
!          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)
!
!          CALL OPS('DEBUG: TWSYST SET (BYTES 22-22)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (23-23 BYTES) DURATION FLAG INDICATOR
C
!          IF (TRABUF(TWDUR) .GT. 1) THEN
!            I4TEMP = 1
!          ELSE
!            I4TEMP = 0
!          ENDIF
!          IND = 22
!          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)
!
!          CALL OPS('DEBUG: TWDUR SET (BYTES 23-23)',I1TEMP(1),I1TEMP(1)) ! DEBUG

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                             V A L I D A T I O N
C                               M E S S A G E S
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        ELSE IF((TRABUF(TTYP) .EQ. TVAL) .OR. ((TRABUF(TTYP) .EQ. TEUR) .AND. (TRABUF(TEUTYP) .EQ. TVAL)) .OR.
     *          (TRABUF(TTYP) .EQ. TREF)) THEN
CC!          TYPE*,' INFO: BUILDING VALIDATION MESSAGE ...'
          !# CALL OPSTXT(' INFO: BUILDING VALIDATION MESSAGE ...')
C
C PUT IN BEGIN (1-1 BYTES) VALIDATION - THE TRANSACTION TYPE
C
          I4TEMP = 0
          I4TEMP1 = 0
          
          IND = 0
          I4TEMP = TVAL
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: TTYP SET (BYTES 1-1)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (2-2 BYTES) THE VALIDATION SUBTYPE - 0 = PRIZE PAYMENT, 16 = PRIZE VALIDATION
C
          IF((TRABUF(TSTAT) .EQ. GOOD) .AND. (TRABUF(TERR) .EQ. NOER)) THEN
            ! GET THE VALUE OF CASH AMOUNT:
            ! IF VALUE GREATER THAN ZERO THEN 
            !    PRIZE PAYMENT
            ! ELSE
            !    PRIZE VALIDATION
            ! ENDIF
CV04            IF(TRABUF(TGAMTYP) .EQ. TEUM) THEN
            IF(TRABUF(TGAMTYP) .EQ. TEUM .OR. TRABUF(TGAMTYP) .EQ. TRAF) THEN   !V04
              IF(TRABUF(TEUVSBT) .NE. 15) THEN
                CSHAMTL = TRABUF(TEUVCAM) ! CASH AMOUNT
                CSHAMTH = TRABUF(TEUVCAMH) ! CASH AMOUNT HIGH HALF WORD
              ELSE
                CSHAMTL = 0
                CSHAMTH = 0
              ENDIF
            ELSE IF(TRABUF(TGAMTYP) .EQ. TPAS) THEN
              CSHAMTL = 0
              CSHAMTH = 0
              DO TCKS = 1, TRABUF(TPTCK) ! TRABUF(TPTCK) NUMBER OF TICKETS TO VALIDATE (cfr. DESTRA.DEF)
                IF(TRABUF(TPSTS1+OFFTRA*(TCKS-1)).EQ.VWINNER) THEN
                  CSHAMTL = CSHAMTL + TRABUF(TPPAY1+OFFTRA*(TCKS-1)) !TPPAY1 - PRIZE PAID 1 (cfr. DESTRA.DEF)
                  !# CALL OPS('CMONY:',CMONY(CSHAMTL,11,VALUNIT),CSHAMTL)
                  !TYPE*,'CMONY: ', CMONY(CSHAMTL,11,VALUNIT)
                ENDIF
              ENDDO
            ELSE
              CSHAMTL = TRABUF(TVPAY) + TRABUF(TVKPAY)
              CSHAMTH = 0
            ENDIF
          ENDIF
          
          IF(TRABUF(TTYP) .EQ. TEUR) THEN
C----+------------------------------------------------------------------
C V03| Added support to new validation sub-types
C----+------------------------------------------------------------------
C             IF((TRABUF(TEUVSBT) .EQ. 1) .OR. (TRABUF(TEUVSBT) .EQ. 15)) THEN
C                 I4TEMP = 16 ! PRIZE VALIDATION
C                 CSHAMTL = 0
C                 CSHAMTH = 0
C             ELSE
C                 I4TEMP = 0 ! PRIZE PAYMENT
C             ENDIF
             ! Validations
             IF( (TRABUF(TEUVSBT) .EQ. 1) 
     *       .OR.(TRABUF(TEUVSBT) .EQ. 6) 
     *       .OR.(TRABUF(TEUVSBT) .EQ. 7) 
     *       .OR.(TRABUF(TEUVSBT) .EQ. 10) 
     *       .OR.(TRABUF(TEUVSBT) .EQ. 15)
     *       ) THEN
                 I4TEMP = 16 ! PRIZE VALIDATION
                 CSHAMTL = 0
                 CSHAMTH = 0
             ! Prize payments
             ELSEIF(
     *           (TRABUF(TEUVSBT) .EQ. 0) 
     *       .OR.(TRABUF(TEUVSBT) .EQ. 8) 
     *       .OR.(TRABUF(TEUVSBT) .EQ. 9) 
     *       ) THEN
                 I4TEMP = 0 ! PRIZE PAYMENT
             ENDIF
C----+------------------------------------------------------------------
C V03| Added support to new validation sub-types
C----+------------------------------------------------------------------
          ELSE 
          	IF((TRABUF(TERR) .EQ. VINQ) .OR. (TRABUF(TERR) .EQ. INVL) .OR. ((CSHAMTL .EQ. 0) .AND. (CSHAMTH .EQ. 0))) THEN
              I4TEMP = 16 ! PRIZE VALIDATION
              CSHAMTL = 0
             	CSHAMTH = 0
            ELSE
          	  I4TEMP = 0 ! PRIZE PAYMENT
          	ENDIF
          ENDIF
          
          IND = 1
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)
          
          !# CALL OPS('DEBUG: VSUBTYPE SET (BYTES 2-2)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (3-3 BYTES) THE GAME NUMBER
C
          I4TEMP = 0
          IF(TRABUF(TTYP) .EQ. TEUR) THEN
C----+---+-------------+------------------------------------------------
C V04|BEG| M16 PROJECT | ADD M1LHAO GAME
C----+---+-------------+------------------------------------------------
CV04            I4TEMP = GAMEUR                                                   !EUROMILLIONS GAME NUMBER
            IF(TRABUF(TGAMTYP) .EQ. TEUM) THEN                                  
              I4TEMP = GAMEUR                                                   !EUROMILLIONS GAME NUMBER
            ELSEIF(TRABUF(TGAMTYP) .EQ. TRAF) THEN
              I4TEMP = GAMSM                                                    !M1LHAO GAME NUMBER
            ENDIF
C----+---+-------------+------------------------------------------------
C V04|END| M16 PROJECT | ADD M1LHAO GAME
C----+---+-------------+------------------------------------------------
          ELSE                                                                  !OTHER GAMES THAN EUROMILLIONS AND M1LHAO
            I4TEMP = TRABUF(TGAM)
          ENDIF
          IND = 2
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: TGAM SET (BYTES 3-3)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (4-7 BYTES) THE SERIAL NUMBER
C
!         I4TEMP = TRABUF(TSER)
          I4TEMP = SER
          IND = 3
          MESS_TO_DATAMINING(IND+1) = I1TEMP(4)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+4) = I1TEMP(1)

          !# CALL OPS('DEBUG: TSER SET (BYTES 4-7)',I4TEMP,I4TEMP) ! DEBUG
C
C PUT IN (8-13 BYTES) THE CASH AMOUNT
C
          I4TEMP = CSHAMTL
          I4TEMP1 = CSHAMTH

          IND = 7
          MESS_TO_DATAMINING(IND+1) = I1TEMP1(2)
          MESS_TO_DATAMINING(IND+2) = I1TEMP1(1)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(4)
          MESS_TO_DATAMINING(IND+4) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+5) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+6) = I1TEMP(1)

          !# CALL OPS('DEBUG: CASH AMT SET (BYTES 8-13)',I4TEMP,I4TEMP1) ! DEBUG

C
C PUT IN (20-22 BYTES) THE AGENT NUMBER
C
          I4TEMP = TRABUF(TAGT)
          IND = 13
          MESS_TO_DATAMINING(IND+1) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(1)

          !# CALL OPS('DEBUG: TAGT SET (BYTES 14-16)',I4TEMP,I4TEMP) ! DEBUG
C
          CALL DISTIM(TRABUF(TTIM),THOUR,TMIN,TSECS)
C
C PUT IN (23-23 BYTES) THE HOUR
C
          I4TEMP = THOUR
          IND = 16
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: THOUR SET (BYTES 17-17)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (24-24 BYTES) THE MINUTE
C
          I4TEMP = TMIN
          IND = 17
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: TMIN SET (BYTES 18-18)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (25-25 BYTES) THE SECOND
C
          I4TEMP = TSECS
          IND = 18
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

          !# CALL OPS('DEBUG: TSECS SET (BYTES 18-18)',I1TEMP(1),I1TEMP(1)) ! DEBUG

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                             S I G N  O N / OFF
C                               M E S S A G E S
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        ELSE IF(TRABUF(TTYP) .EQ. TSPE) THEN

CC!          TYPE*,' INFO: BUILDING SIGN ON/OFF MESSAGE ...'
          !# CALL OPSTXT(' INFO: BUILDING SIGN ON/OFF MESSAGE ...')
C
C PUT IN BEGIN (1-1 BYTES) SPECIAL - THE TRANSACTION TYPE
C
          I4TEMP = 0
          IND = 0
          I4TEMP = TRABUF(TTYP)

          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

!         CALL OPS('DEBUG: TTYP SET (BYTES 1-1)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (2-2 BYTES) THE SPECIAL FUNCTION
C
          I4TEMP = TRABUF(TSFUN)
          IND = 1
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

!         CALL OPS('DEBUG: TGAM SET (BYTES 2-2)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (3-6 BYTES) THE SERIAL NUMBER
C
!         I4TEMP = TRABUF(TSER)
          I4TEMP = SER
          IND = 2
          MESS_TO_DATAMINING(IND+1) = I1TEMP(4)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+4) = I1TEMP(1)

!         CALL OPS('DEBUG: TSER SET (BYTES 3-6)',I4TEMP,I4TEMP) ! DEBUG
C
C PUT IN (7-9 BYTES) THE AGENT NUMBER
C
          I4TEMP = TRABUF(TAGT)
          IND = 6
          MESS_TO_DATAMINING(IND+1) = I1TEMP(3)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+3) = I1TEMP(1)

!         CALL OPS('DEBUG: TAGT SET (BYTES 7-9)',I4TEMP,I4TEMP) ! DEBUG
C
C PUT IN (10-11 BYTES) THE TERMINAL NUMBER
C
          I4TEMP = TRABUF(TTER)
          IND = 9
          MESS_TO_DATAMINING(IND+1) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(1)

          !# CALL OPS('DEBUG: TTER SET (BYTES 10-11)',I4TEMP,I4TEMP) ! DEBUG
C
C PUT IN (12-13 BYTES) THE CDC DATE
C
          I4TEMP = TRABUF(TCDC)
          IND = 11
          MESS_TO_DATAMINING(IND+1) = I1TEMP(2)
          MESS_TO_DATAMINING(IND+2) = I1TEMP(1)

          !# CALL OPS('DEBUG: TCDC SET (BYTES 12-13)',I4TEMP,I4TEMP) ! DEBUG
C
          CALL DISTIM(TRABUF(TTIM),THOUR,TMIN,TSECS)
C
C PUT IN (14-14 BYTES) THE HOUR
C
          I4TEMP = THOUR
          IND = 13
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

         !# CALL OPS('DEBUG: THOUR SET (BYTES 14-14)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (15-15 BYTES) THE MINUTE
C
          I4TEMP = TMIN
          IND = 14
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

         !# CALL OPS('DEBUG: TMIN SET (BYTES 15-15)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (16-16 BYTES) THE SECOND
C
          I4TEMP = TSECS
          IND = 15
          MESS_TO_DATAMINING(IND+1) = I1TEMP(1)

         !# CALL OPS('DEBUG: TSECS SET (BYTES 16-16)',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
        ENDIF
C
C MESS_TO_LEN = LENGTH OF MESSAGE SENT TO MESSAGEQ_MDC
C
        MESS_TO_LEN = IND + 1
        !# CALL OPS('MESS_TO_LEN',MESS_TO_LEN,MESS_TO_LEN) ! DEBUG

C       TYPE*, ' INFO: BUILD MESSAGE FINISHED!' ! INFO
C
C CALL C FUNCTION TO PUT THE MESSAGE INTO MESSAGEQ (QUEUE = 4)
C
C       TYPE *,' PUT BEF - ',MESSERIAL,' - TIME: ',P(ACTTIM)
        CALL MESSQ_PUT(%REF(STATUS))
C       TYPE *,' PUT AFT- ',MESSERIAL,' - TIME: ',P(ACTTIM)
C
C IF STATUS NOT SUCCESS THEN SEND TO CONSOLE ERROR MESSAGE
C
        IF (STATUS .NE. PAMS__SUCCESS) THEN
          CALL OPS ('ERROR - SEND_DATA_TO_DM - WHILE PUT INTO MESSAGEQ!',STATUS,0)
CV04          CALL OPSTXT(' INFO - SEND_DATA_TO_DM - WILL CONNECT TO FAILOVER HOST!')
          TYPE*,'ERROR - SEND_DATA_TO_DM - WHILE PUT INTO MESSAGEQ! STATUS: ',STATUS
CV04          TYPE*,' INFO - SEND_DATA_TO_DM - WILL CONNECT TO FAILOVER HOST!'
          CALL OPSTXT(' INFO - SEND_DATA_TO_DM - WILL TRY TO CONNECT TO FAILOVER HOST IN 60 SECS...') !V04
          TYPE*,' INFO - SEND_DATA_TO_DM - WILL TRY TO CONNECT TO FAILOVER HOST IN 60 SECS...' !V04
          CALL XWAIT(60,2,ST)                                                   !WAIT FOR 60 SECS !V04
          ST = STATUS
          RETURN
        ENDIF

C       TYPE*, ' INFO: MESSAGE WAS PUT INTO MESSAGEQ!' ! INFO

        ST = STATUS
9998    FORMAT(' MESSWORD SENT: ',I4.3,' - ', Z3.2)
        END
C**************************************************
C SUBROUTINE: STARTS THE PROCESS.
C       - SENDS A DAY MESSAGE REQUEST TO DM
C       - WAITS FOR DAY MESSAGE RESPONSE FROM DM
C       - SENDS A SERIAL OFFSET MESSAGE REQUEST TO DM
C       - WAITS FOR SERIAL OFFSET MESSAGE
C INPUT:
C
C OUTPUT:
C        ST - PROCESS STATUS
C        SEROFFSET - SERIAL OFFSET
C
C**************************************************
C
C=======OPTIONS /CHECK=NOOVERFLOW
        SUBROUTINE INIT_PROCESS(ST,SEROFFSET)
        IMPLICIT NONE

        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:CONCOM.DEF'
        INCLUDE 'INCLIB:PROCOM.DEF'
        INCLUDE 'INCLIB:AGTCOM.DEF'
        INCLUDE 'INCLIB:DESTRA.DEF'
        INCLUDE 'INCLIB:TASKID.DEF'
        INCLUDE 'INCLIB:PRMLOG.DEF'
        INCLUDE 'INCLIB:CHKSUMCM.DEF'
        INCLUDE 'INCLIB:QUECOM.DEF'
        INCLUDE 'INCLIB:APUCOM.DEF'
        INCLUDE 'INCLIB:EURCON.DEF'
        INCLUDE 'INCLIB:DATBUF.DEF'

        INTEGER*4 I4TEMP
        INTEGER*2 I2TEMP(2)
        BYTE      I1TEMP(4)
        EQUIVALENCE (I4TEMP,I2TEMP,I1TEMP)
        INTEGER*4 ST,STATUS

        INTEGER*2 VDAT(LDATE_LEN)

        INTEGER*4 MSGTYP
        INTEGER*4 MSGSUBTYP
        INTEGER*4 SEROFFSET
        INTEGER*4 DAYSTATUS
        INTEGER*4 DAYOK
        INTEGER*4 DAYNOTOK

        INTEGER*4 ADMINTYP !ADMINISTRATION MESSAGE TYPE
        INTEGER*4 OFFSETREQSUBTYP ! OFFSET REQUEST SUBTYPE
        INTEGER*4 DAYREQSUBTYP ! DAY REQUEST SUBTYPE
        INTEGER*4 OFFSETRESSUBTYP ! OFFSET RESPONSE SUBTYPE
        INTEGER*4 DAYRESSUBTYP ! DAY RESPONSE SUBTYPE
        INTEGER*4 SETOFFSETREQSUBTYP ! SET OFFSET REQUEST SUBTYPE

        PARAMETER(ADMINTYP = 255)
        PARAMETER(OFFSETREQSUBTYP = 0)
        PARAMETER(OFFSETRESSUBTYP = 1)
        PARAMETER(DAYREQSUBTYP = 2)
        PARAMETER(DAYRESSUBTYP = 3)
        PARAMETER(SETOFFSETREQSUBTYP = 4)
        PARAMETER(DAYOK = 0)
        PARAMETER(DAYNOTOK = 1)
C
C MESS_TO_DATAMINING = MESSAGE IN BYTES
C MESS_TO_LEN = MESSAGE LENGTH
C

C
C THIS COMMON AREA IS EQUAL TO THE STRUCTURE USED IN MESSAGEQ_MDC.C
C IS USED TO PASS MESSAGE...
C
        COMMON /TO_DATAMINING/MESS_TO_DATAMINING,MESS_TO_LEN
        BYTE MESS_TO_DATAMINING(1024)

        INTEGER*4 MESS_TO_LEN
        INTEGER*4 INDTO
C
C THIS COMMON AREA IS EQUAL TO THE STRUCTURE USED IN MESSAGEQ_MDC.C
C IS USED TO RECEIVE MESSAGE...
C
        COMMON /FROM_DATAMINING/MESS_FROM_DATAMINING,MESS_FROM_LEN
        BYTE MESS_FROM_DATAMINING(1024)
        INTEGER*4 MESS_FROM_LEN

        ST = 0
C
C BUILDS THE DAY REQUEST MESSAGE
C
10      CONTINUE
C
C PUT IN BEGIN (1-1 BYTES) MESSAGE TYPE
C
        INDTO = 0
        I4TEMP = 0
        I4TEMP = ADMINTYP
        MESS_TO_DATAMINING(INDTO+1) = I1TEMP(1)

!       CALL OPS('DEBUG: ADMINTYP SET - 1 BYTE',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (2-2 BYTES) MESSAGE SUBTYPE
C
        INDTO = 1
        I4TEMP = 0
        I4TEMP = DAYREQSUBTYP
        MESS_TO_DATAMINING(INDTO+1) = I1TEMP(1)

!       CALL OPS('DEBUG: DAYREQSUBTYP SET - 1 BYTE',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (3-6 BYTES) MILLENNIUM SYSTEM DAY
C
        VDAT(VCDC)=DAYCDC
        CALL LCDATE(VDAT)

        INDTO = 2
        I4TEMP = 0
        I4TEMP = VDAT(VDAY)

        MESS_TO_DATAMINING(INDTO+1) = I1TEMP(1)

!       CALL OPS('DEBUG: SYSDAY SET - 1 BYTE',I1TEMP(1),I1TEMP(1)) ! DEBUG

        INDTO = 3
        I4TEMP = 0
        I4TEMP = VDAT(VMON)

        MESS_TO_DATAMINING(INDTO+1) = I1TEMP(1)

!       CALL OPS('DEBUG: SYSMONTH SET - 1 BYTE',I1TEMP(1),I1TEMP(1)) ! DEBUG

        INDTO = 4
        I4TEMP = 0
        IF(VDAT(VYEAR).LT.77) THEN
          I4TEMP = VDAT(VYEAR)+2000
        ELSE
          I4TEMP = VDAT(VYEAR)+1900
        ENDIF

        MESS_TO_DATAMINING(INDTO+1) = I1TEMP(2)
        MESS_TO_DATAMINING(INDTO+2) = I1TEMP(1)

!       CALL OPS('DEBUG: SYSYEAR SET - 2 BYTES',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C MESS_TO_LEN = LENGTH OF MESSAGE SENT TO MESSAGEQ_MDC
C
        MESS_TO_LEN = INDTO + 2

!       CALL OPS('DEBUG: MESS_TO_LEN SET',MESS_TO_LEN,MESS_TO_LEN)

C
C CALL C FUNCTION TO PUT THE MESSAGE INTO MESSAGEQ_MDC (QUEUE = 4)
C
!       TYPE *,' INFO: BEF PUT - TIME: ',P(ACTTIM)
        CALL MESSQ_PUT(%REF(STATUS))
!       TYPE *,' INFO: AFT PUT - TIME: ',P(ACTTIM)
C
C IF STATUS NOT SUCCESS THEN SEND TO CONSOLE ERROR MESSAGE
C
        IF (STATUS .NE. PAMS__SUCCESS) THEN
          CALL OPS('ERROR - INIT_PROCESS - WHILE PUT DAY REQUEST INTO MESSAGEQ',STATUS,0)
          TYPE*, 'ERROR - INIT_PROCESS - WHILE PUT DAY REQUEST INTO MESSAGEQ - STATUS: ', STATUS
          IF (STATUS .NE. PAMS__TIMEOUT) THEN
CV04            CALL OPSTXT(' INFO - INIT_PROCESS - WILL CONNECT TO FAILOVER HOST!')
CV04            TYPE*,' INFO - INIT_PROCESS - WILL CONNECT TO FAILOVER HOST!'
            CALL OPSTXT(' INFO - INIT_PROCESS - WILL TRY TO CONNECT TO FAILOVER HOST IN 60 SECS...') !V'4
            TYPE*,' INFO - INIT_PROCESS - WILL TRY TO CONNECT TO FAILOVER HOST IN 60 SECS...' !V04
            CALL XWAIT(60,2,ST)                                                 !WAIT FOR 60 SECS !V04
            ST = STATUS
            RETURN
          ENDIF
          CALL XWAIT(5,2,ST) ! WAIT FOR 5 SECS
          GOTO 10
        ENDIF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C WAITS FOR DAY MESSAGE RESPONSE FROM DATA MINING
C IF DAY MESSAGE REQUEST WAS PUT SUCCESSFULLY
C IN THE QUEUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        CALL OPSTXT(' INFO - INIT_PROCESS - DAY REQUEST WAS PUT SUCCESSFULLY IN QUEUE.')
        CALL OPSTXT(' INFO - INIT_PROCESS - WAITING FOR DAY RESPONSE...')
        TYPE*,' INFO - INIT_PROCESS - DAY REQUEST WAS PUT SUCCESSFULLY IN QUEUE.'
        TYPE*,' INFO - INIT_PROCESS - WAITING FOR DAY RESPONSE...'
20      CONTINUE

        CALL MESSQ_GET(%REF(STATUS))

        IF (STATUS .EQ. PAMS__NOMOREMSG) THEN
!         TYPE*,' INFO - INIT_PROCESS - NO MESSAGE YET - SLEEP 1 SEC.'
          CALL XWAIT(1,2,ST) ! WAIT FOR 1 SEC
          GOTO 20
        ENDIF

        IF (STATUS .EQ. PAMS__SUCCESS) THEN
C
C GET MESSAGE TYPE
C
          I1TEMP(4) = 0
          I1TEMP(3) = 0
          I1TEMP(2) = 0
          I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(1))
          MSGTYP = I4TEMP

!         TYPE*, 'DEBUG: MSGTYP - ', MSGTYP

          IF (MSGTYP .NE. ADMINTYP) GOTO 20 ! ONLY ADMINISTRATION MESSAGES ALLOWED
C
C GET MESSAGE SUBTYPE
C
          I1TEMP(4) = 0
          I1TEMP(3) = 0
          I1TEMP(2) = 0
          I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(2))
          MSGSUBTYP = I4TEMP

!         TYPE*, 'DEBUG: MSGSUBTYP - ', MSGSUBTYP ! DEBUG
C
C AT THIS STAGE, RECEIVING SETOFFSET MESSAGE MEANS THAT DATA MINING SYSTEM IS RECOVERING FROM FAILURE
C
          IF (MSGSUBTYP .EQ. SETOFFSETREQSUBTYP) GOTO 10
          IF (MSGSUBTYP .NE. DAYRESSUBTYP) GOTO 20 ! NOT A DAY MESSAGE RESPONSE
          CALL OPSTXT(' INFO - INIT_PROCESS - DAY RESPONSE RECEIVED.')
          TYPE*,' INFO - INIT_PROCESS - DAY RESPONSE RECEIVED.'
          I1TEMP(4) = 0
          I1TEMP(3) = 0
          I1TEMP(2) = 0
          I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(3))
          DAYSTATUS = I4TEMP
!         TYPE*, 'DEBUG: DAYSTATUS - ', DAYSTATUS ! DEBUG

          IF (DAYSTATUS .EQ. DAYNOTOK) THEN
            CALL OPSTXT('FATAL - INIT_PROCESS - THE DAY IN SYSTEMS MILL AND EUROMIL IS DIFFERENT!')
            TYPE*, 'FATAL - INIT_PROCESS - THE DAY IN SYSTEMS MILL AND EUROMIL IS DIFFERENT!' ! FATAL
            I4TEMP = 0
            IF(VDAT(VYEAR).LT.77) THEN
              I4TEMP = VDAT(VYEAR)+2000
            ELSE
              I4TEMP = VDAT(VYEAR)+1900
            ENDIF
            TYPE*, ' INFO - INIT_PROCESS - MILL DAY IS ', VDAT(VDAY),'.',VDAT(VMON),'.',I4TEMP ! INFO
            CALL GSTOP(GEXIT_FATAL)
          ENDIF

!         TYPE*, ' INFO: DAY MESSAGE RESPONSE IS OK!' ! INFO
C
C BUILDS THE OFFSET MESSAGE REQUEST
C
          IF (MSGSUBTYP .EQ. DAYRESSUBTYP .AND. DAYSTATUS .EQ. DAYOK) THEN
            CALL OPSTXT(' INFO - INIT_PROCESS - DAY STATUS IS OK!')
            TYPE*,' INFO - INIT_PROCESS - DAY STATUS IS OK!'
C
C PUT IN BEGIN (1-1 BYTES) TYPE MESSAGE
C
40      CONTINUE
!           TYPE*, ' INFO: BUILDING OFFSET MESSAGE REQUEST ...' ! INFO
            INDTO = 0
            I4TEMP = 0
            I4TEMP = ADMINTYP
            MESS_TO_DATAMINING(INDTO+1) = I1TEMP(1)

!           CALL OPS('DEBUG: ADMINTYP SET - BYTE 1/1',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C PUT IN (2-2 BYTES) SUBTYPE MESSAGE
C
            INDTO = 1
            I4TEMP = 0
            I4TEMP = OFFSETREQSUBTYP
            MESS_TO_DATAMINING(INDTO+1) = I1TEMP(1)

!           CALL OPS('DEBUG: OFFSETREQSUBTYP SET - BYTE 1/1',I1TEMP(1),I1TEMP(1)) ! DEBUG
C
C MESS_TO_LEN = LENGTH OF MESSAGE SENT TO MESSAGEQ_MDC
C
            MESS_TO_LEN = INDTO + 1
!           CALL OPS('DEBUG: MESS_TO_LEN SET',MESS_TO_LEN,MESS_TO_LEN) ! DEBUG

!           TYPE*, ' INFO: BUILD OFFSET MESSAGE REQUEST FINISHED!' ! INFO
C
C CALL C FUNCTION TO PUT THE MESSAGE INTO MESSAGEQ (QUEUE = 4)
C
!           TYPE *,' INFO: BEF PUT - TIME: ',P(ACTTIM)
            CALL MESSQ_PUT(%REF(STATUS))
!           TYPE *,' INFO: AFT PUT - TIME: ',P(ACTTIM)

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C WAITS FOR THE OFFSET MESSAGE RESPONSE FROM DATA MINING
C SYSTEM IF THE OFFSET MESSAGE REQUEST WAS PUT SUCCSSEFULLY
C IN THE QUEUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
            IF (STATUS .EQ. PAMS__SUCCESS) THEN
!             TYPE*, ' INFO: OFFSET MESSAGE REQUEST WAS PUT INTO MESSAGEQ_MDC!' ! INFO
              CALL OPSTXT(' INFO - INIT_PROCESS - OFFSET REQUEST WAS PUT SUCCESSFULLY IN QUEUE.')
              CALL OPSTXT(' INFO - INIT_PROCESS - WAITING FOR OFFSET RESPONSE...')
              TYPE*,' INFO - INIT_PROCESS - OFFSET REQUEST WAS PUT SUCCESSFULLY IN QUEUE.'
              TYPE*,' INFO - INIT_PROCESS - WAITING FOR OFFSET RESPONSE...'
30      CONTINUE
              CALL MESSQ_GET(%REF(STATUS))

              IF (STATUS .EQ. PAMS__NOMOREMSG) THEN
!               TYPE*, ' INFO: NO OFFSET MESSAGE RESPONSE YET, SLEEP 1 SEC' !INFO
                CALL XWAIT(1,2,ST) ! WAIT FOR 1 SEC
                GOTO 30
              ENDIF

              IF (STATUS .EQ. PAMS__SUCCESS) THEN
!               TYPE*, ' INFO: MESSAGE RECEIVED!' !INFO
C
C GET MESSAGE TYPE
C
                I1TEMP(4) = 0
                I1TEMP(3) = 0
                I1TEMP(2) = 0
                I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(1))
                MSGTYP = I4TEMP

!               TYPE*, 'DEBUG: MSGTYP - ', MSGTYP ! DEBUG

                IF (MSGTYP .NE. ADMINTYP) GOTO 30 ! ONLY ADMINISTRATION MESSAGES ALLOWED
C
C GET MESSAGE SUBTYPE
C
                I1TEMP(4) = 0
                I1TEMP(3) = 0
                I1TEMP(2) = 0
                I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(2))
                MSGSUBTYP = I4TEMP

!               TYPE*, 'DEBUG: MSGSUBTYP - ', MSGSUBTYP ! DEBUG
C
C AT THIS STAGE, RECEIVING SETOFFSET MESSAGE MEANS THAT DATA MINING SYSTEM IS RECOVERING FROM FAILURE
C
                IF (.NOT. (MSGSUBTYP .EQ. SETOFFSETREQSUBTYP .OR. MSGSUBTYP .EQ. OFFSETRESSUBTYP) ) GOTO 40

                CALL OPSTXT(' INFO - INIT_PROCESS - OFFSET RESPONSE RECEIVED.')
                TYPE*,' INFO - INIT_PROCESS - OFFSET RESPONSE RECEIVED.'

                I1TEMP(4) = ZEXT (MESS_FROM_DATAMINING(3))
                I1TEMP(3) = ZEXT (MESS_FROM_DATAMINING(4))
                I1TEMP(2) = ZEXT (MESS_FROM_DATAMINING(5))
                I1TEMP(1) = ZEXT (MESS_FROM_DATAMINING(6))

                SEROFFSET = I4TEMP ! SERIAL OFFSET VALUE
                CALL OPS('DEBUG - INIT_PROCESS - OFFSET VALUE: ',SEROFFSET,SEROFFSET)
                TYPE*,'DEGUG - INIT_PROCESS - OFFSET VALUE: ',SEROFFSET
!               TYPE*, 'DEBUG: SEROFFSET RECEIVED - ', SEROFFSET ! DEBUG
                ST = STATUS
                RETURN
              ELSE
                CALL OPS('ERROR - INIT_PROCESS - WHILE GET OFFSET RESPONSE FROM MESSAGEQ',STATUS,0)
                CALL OPSTXT(' INFO - INIT_PROCESS - WILL CONNECT TO FAILOVER HOST!')
                TYPE*,'ERROR - INIT_PROCESS - WHILE GET OFFSET RESPONSE FROM MESSAGEQ (STATUS = ',STATUS,')'
                TYPE*,' INFO - INIT_PROCESS - WILL CONNECT TO FAILOVER HOST!'
                ST = STATUS
                RETURN
              ENDIF
            ELSE
              CALL OPS('ERROR - INIT_PROCESS - WHILE PUT OFFSET REQUEST INTO MESSAGEQ',STATUS,0)             !V04
              TYPE*,'ERROR - INIT_PROCESS - WHILE PUT OFFSET REQUEST INTO MESSAGEQ (STATUS = ',STATUS,')'    !V04
              IF (STATUS .NE. PAMS__TIMEOUT) THEN
CV04                CALL OPS('ERROR - INIT_PROCESS - WHILE PUT OFFSET REQUEST INTO MESSAGEQ',STATUS,0)
CV04                CALL OPSTXT(' INFO - INIT_PROCESS - WILL CONNECT TO FAILOVER HOST!')
CV04                TYPE*,'ERROR - INIT_PROCESS - WHILE PUT OFFSET REQUEST INTO MESSAGEQ (STATUS = ',STATUS,')'
CV04                TYPE*,' INFO - INIT_PROCESS - WILL CONNECT TO FAILOVER HOST!'
                CALL OPSTXT(' INFO - INIT_PROCESS - WILL TRY TO CONNECT TO FAILOVER HOST IN 60 SECS...')
                TYPE*,' INFO - INIT_PROCESS - WILL TRY TO CONNECT TO FAILOVER HOST IN 60 SECS...'    !V04
                CALL XWAIT(60,2,ST)                                             !WAIT FOR 60 SECS !V04
                ST = STATUS
                RETURN
              ENDIF
              CALL XWAIT(5,2,ST) ! WAIT FOR 5 SECS
              GOTO 40
            ENDIF
          ENDIF
        ELSE
          CALL OPS('ERROR - INIT_PROCESS - WHILE GET DAY RESPONSE FROM MESSAGEQ',STATUS,0)
          CALL OPSTXT(' INFO - INIT_PROCESS - WILL CONNECT TO FAILOVER HOST!')
          TYPE*,'ERROR - INIT_PROCESS - WHILE GET DAY RESPONSE FROM MESSAGEQ (STATUS = ',STATUS,')'
          TYPE*,' INFO - INIT_PROCESS - WILL CONNECT TO FAILOVER HOST!'
          ST = STATUS
          RETURN
        ENDIF

9998    FORMAT(' MESSAGE SENT: ',I4.3,' - ', Z3.2)
9999    FORMAT(' MESSAGE RECV: ',I4.3,' - ', Z3.2)
        END

C**************************************************
C SUBROUTINE: GET WAGER, CANCELLATION, VALIDATION
C             AND SIGN-ON TRANSACTIONS FROM TMF OF
C             THE FOLLOWING GAMES:
C
C         GAME NUMBER       GAME NAME
C             1          Totobola Normal
C             5          Joker
C             6          Totoloto Sábado
C             7          Totoloto Quarta
C             8          Lotaria Clássica
C             9          Lotaria Popular
C            10          Totobola Extra 1
C            11          Euromillions
C            12          M1lhao
C
C INPUT:
C     SEROFFSET - SERIAL NUMBER
C
C OUTPUT: TRABUF - TRANSACTION
C     SEROFFSET - SERIAL OFFSET
C     EOT - END OF FILE FLAG INDICATOR
C**************************************************
C
C=======OPTIONS /CHECK=NOOVERFLOW
        SUBROUTINE GETTRABUF(TRABUF,SEROFFSET,EOT,ERROR_READ)
        IMPLICIT NONE
C
        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:PRMLOG.DEF'
        INCLUDE 'INCLIB:DESTRA.DEF'
        INCLUDE 'INCLIB:CONCOM.DEF'

        INTEGER*4 LOGREC(LREC*3), ST, DUMMY, EOTCNT, SEROFFSET,SER

C       GAME NUMBERS
        INTEGER*4 GAMTBLANRML
        PARAMETER (GAMTBLANRML = 1)  ! TOTOBOLA NORMAL
        INTEGER*4 GAMKIK
        PARAMETER (GAMKIK = 5)       ! JOKER
        INTEGER*4 GAMTLTOSAT
        PARAMETER (GAMTLTOSAT = 6)   ! TOTOLOTO SÁBADO
        INTEGER*4 GAMTLTOWED
        PARAMETER (GAMTLTOWED = 7)   ! TOTOLOTO QUARTA
        INTEGER*4 GAMPAS1
        PARAMETER (GAMPAS1 = 8)      ! LOTARIA CLÁSSICA
        INTEGER*4 GAMPAS2
        PARAMETER (GAMPAS2 = 9)      ! LOTARIA POPULAR
        INTEGER*4 GAMTBLAEXT1
        PARAMETER (GAMTBLAEXT1 = 10) ! TOTOBOLA EXTRA 1
        INTEGER*4 GAMEUR
        PARAMETER (GAMEUR = 11) ! EUROMILLIONS
        INTEGER*4 GAMSM
        PARAMETER (GAMSM = 12)                                                  !M1LHAO

        LOGICAL EOT
        LOGICAL ERROR_READ
        DATA EOTCNT/0/

        EOT = .FALSE.
        ERROR_READ = .FALSE.


C       TYPE*, ' '
C       TYPE*, ' INFO: GETTRABUF CALLED.'
        SER = SEROFFSET
C       TYPE*, 'DEBUG: LAST SERIAL: ', SER
!       CALL OPS('DEBUG: LAST SERIAL PROCESSED: ', SER, 0)

10      CONTINUE
        SER = SER+1
        IF(SER.GT.NXTSER) THEN
            !EOTCNT = 0
            EOT = .TRUE.
!            TYPE*, ' INFO: SER ', SER, ', END OF FILE REACHED! WAITING 10 SECS BEFORE CONTINUE ...'
            CALL XWAIT(10,2,ST) ! END OF FILE REACHED, WAIT 10 SECS ...
!            CALL OPS(' INFO: SER',SER,SER)
            RETURN
            !GOTO 10
        ENDIF

        CALL RLOG(SER,LOGREC,DUMMY,ST)
C
C CHECK FOR END OF FILE
C
        IF(ST.EQ.-1) THEN
C         EOTCNT = EOTCNT+1
C         IF(EOTCNT.GT.2500) THEN
C           EOTCNT = 0
C           EOT = .TRUE.
C           TYPE*, ' INFO: END OF FILE REACHED! WAITING 10 SECS BEFORE CONTINUE ...'
C           CALL XWAIT(10,2,ST) ! END OF FILE REACHED, WAIT 10 SECS ...
C           RETURN
C         ELSE
            GOTO 10
C         ENDIF
        ENDIF

C       IF(ST.NE.0) GOTO 10
        IF(ST.NE.0) THEN
C         TYPE*, ' ERROR READING FROM FILE !!!'

          ERROR_READ = .TRUE.
C         EOT = .TRUE.
          RETURN
        ENDIF
C
C CHECK FOR WAGER, CANCELLATION, VALIDATION/PAYMENT AND SIGN ON/OFF TRANSACTIONS
C
        CALL LOGTRA(TRABUF,LOGREC)

      !  IF((TRABUF(TTER) .NE. 1255) .AND. (TRABUF(TTER) .NE. 3427)) THEN
      !  IF((TRABUF(TTER) .NE. 2211)) THEN
      !IF((TRABUF(TTER) .NE. 1489 .AND. TRABUF(TTER) .NE. 4828)) THEN
      	!IF(TRABUF(TTER) .NE. 3521) THEN
      	!IF(TRABUF(TTER) .NE. 5902) THEN
        !  SEROFFSET = SER
        !  IF(MOD(SEROFFSET,10000) .EQ. 0) THEN
        !    TYPE*, 'INFO: SERIAL CHECKPOINT: ', SEROFFSET
        !    CALL OPS(' INFO: SERIAL CHECKPOINT',SEROFFSET, SEROFFSET)
        !  ENDIF
        !  GOTO 10
        !ENDIF

        EOTCNT = 0
CC!        TYPE*,' INFO: NEW TRX READ FROM TMF!'
CC!        TYPE*,'DEBUG: TRABUF(TTYP) = ',TRABUF(TTYP)

        IF((TRABUF(TTYP) .EQ. TEUR) .AND. ((TRABUF(TEUTYP) .EQ. TWAG) .OR. (TRABUF(TEUTYP) .EQ. TCAN))) THEN
CC!          TYPE*,' INFO: EUR WAG/CAN SKIPPED!'
          SEROFFSET = SER
          GOTO 10
        ENDIF

        ! WAGER/CANCELLATION
        IF((TRABUF(TTYP) .EQ. TWAG) .OR. (TRABUF(TTYP) .EQ. TCAN)) THEN
!        IF((TRABUF(TTYP) .EQ. TWAG) .OR. (TRABUF(TTYP) .EQ. TCAN) .OR. (TRABUF(TTYP) .EQ. TVAL) .OR. (TRABUF(TTYP) .EQ. TREF)) THEN
!          IF(((TRABUF(TSTAT) .EQ. GOOD)) .AND. (TRABUF(TERR) .EQ. NOER)) THEN
          IF(TRABUF(TERR) .EQ. NOER) THEN
            IF(((TRABUF(TGAMTYP) .EQ. TLTO) .AND. ((TRABUF(TGAM) .EQ. GAMTLTOWED) .OR. (TRABUF(TGAM) .EQ. GAMTLTOSAT))) .OR.
     *         ((TRABUF(TGAMTYP) .EQ. TKIK) .AND.  (TRABUF(TGAM) .EQ. GAMKIK)) .OR.
     *         ((TRABUF(TGAMTYP) .EQ. TPAS) .AND. (TRABUF(TWEPOP) .NE. EPASRES) .AND. (TRABUF(TWEPOP) .NE. EPASREL) .AND. 
     *         ((TRABUF(TGAM) .EQ. GAMPAS1) .OR. (TRABUF(TGAM) .EQ. GAMPAS2))) .OR.
     *         ((TRABUF(TGAMTYP) .EQ. TSPT) .AND. ((TRABUF(TGAM) .EQ. GAMTBLANRML) .OR. (TRABUF(TGAM) .EQ. GAMTBLAEXT1)))) THEN

              SEROFFSET = SER

CC!              TYPE*,' INFO: NEW TRX FOUND!'
CC!              TYPE*,'DEBUG: TERR',TRABUF(TERR)
CC!              TYPE*,'DEBUG: TTYP',TRABUF(TTYP)
CC!              TYPE*,'DEBUG: TGAMTYP',TRABUF(TGAMTYP)
CC!              TYPE*,'DEBUB: TGAM',TRABUF(TGAM)
CC!              TYPE*,'DEBUG: TSTAT',TRABUF(TSTAT)
CC!              TYPE*,'DEBUG: SER',SER

              RETURN
            ENDIF
          ENDIF
        ! VALIDATION/PAYMENT
!        ELSE IF((TRABUF(TTYP) .EQ. TVAL) .OR. (TRABUF(TTYP) .EQ. TREF)) THEN
        ELSE IF((TRABUF(TSTAT) .NE. SUPR) .AND. ((TRABUF(TTYP) .EQ. TVAL) .OR. (TRABUF(TTYP) .EQ. TREF))) THEN
!          IF((TRABUF(TSTAT) .EQ. REJT) .AND. ((TRABUF(TERR) .EQ. VINQ) .OR. (TRABUF(TERR) .EQ. INVL)) .OR. (TRABUF(TERR) .EQ. NOER)) THEN
!          IF((TRABUF(TERR) .EQ. VINQ) .OR. (TRABUF(TERR) .EQ. INVL) .OR. (TRABUF(TERR) .EQ. NOER)) THEN
!            IF(((TRABUF(TGAMTYP) .EQ. TLTO) .AND. ((TRABUF(TGAM) .EQ. GAMTLTOWED) .OR. (TRABUF(TGAM) .EQ. GAMTLTOSAT))) .OR.
!     *         ((TRABUF(TGAMTYP) .EQ. TKIK) .AND.  (TRABUF(TGAM) .EQ. GAMKIK)) .OR.
!     *         ((TRABUF(TGAMTYP) .EQ. TPAS) .AND. ((TRABUF(TGAM) .EQ. GAMPAS1) .OR. (TRABUF(TGAM) .EQ. GAMPAS2))) .OR.
!     *         ((TRABUF(TGAMTYP) .EQ. TSPT) .AND. ((TRABUF(TGAM) .EQ. GAMTBLANRML) .OR. (TRABUF(TGAM) .EQ. GAMTBLAEXT1)))) THEN

              SEROFFSET = SER

CC!              TYPE*,' INFO: NEW TRX FOUND!'
CC!              TYPE*,'DEBUG: TERR',TRABUF(TERR)
CC!              TYPE*,'DEBUG: TTYP',TRABUF(TTYP)
CC!              TYPE*,'DEBUG: TGAMTYP',TRABUF(TGAMTYP)
CC!              TYPE*,'DEBUB: TGAM',TRABUF(TGAM)
CC!              TYPE*,'DEBUG: TSTAT',TRABUF(TSTAT)
CC!              TYPE*,'DEBUG: SER',SER

              RETURN
!            ENDIF
          !ENDIF
        ! EM/M1LHAO VALIDATION/PAYMENT
        ELSE IF((TRABUF(TTYP) .EQ. TEUR) .AND. (TRABUF(TEUTYP) .EQ. TVAL)) THEN
CC!          type*, '  TRABUF(TSTAT): ', TRABUF(TSTAT)
CC!          type*, '   TRABUF(TERR): ', TRABUF(TERR)
CC!          type*, 'TRABUF(TGAMTYP): ', TRABUF(TGAMTYP) ! TRABUF(TEUVSBT)
C----+------------------------------------------------------------------
C V03| Added support to new validation sub-types
C----+------------------------------------------------------------------
C         IF((TRABUF(TSTAT) .EQ. GOOD) .AND. ((TRABUF(TEUVSBT) .EQ. 1) .OR. (TRABUF(TERR) .EQ. NOER)) .AND.
C    *        (TRABUF(TGAMTYP) .EQ. TEUM)) THEN
          IF(  (TRABUF(TSTAT)   .EQ. GOOD) 
     *    .AND.    ((TRABUF(TEUVSBT) .EQ. 1) 
     *         .OR. (TRABUF(TEUVSBT) .EQ. 6) 
     *         .OR. (TRABUF(TEUVSBT) .EQ. 7) 
     *         .OR. (TRABUF(TEUVSBT) .EQ. 8) 
     *         .OR. (TRABUF(TEUVSBT) .EQ. 9) 
     *         .OR. (TRABUF(TEUVSBT) .EQ. 10) 
     *         .OR. (TRABUF(TERR) .EQ. NOER)) 
CV04     *    .AND.(TRABUF(TGAMTYP) .EQ. TEUM)) THEN
     *    .AND.    ((TRABUF(TGAMTYP) .EQ. TEUM)                                 !V04
     *         .OR. (TRABUF(TGAMTYP) .EQ. TRAF))) THEN                          !V04
C----+------------------------------------------------------------------
C V03| Added support to new validation sub-types
C----+------------------------------------------------------------------

CC!            TYPE*,' INFO: EM/M1LHAO VALIDATION FOUND!'
CC!            TYPE*,'DEBUG: TERR',TRABUF(TERR)
CC!            TYPE*,'DEBUG: TTYP',TRABUF(TTYP)
CC!            TYPE*,'DEBUG: TEUTYP',TRABUF(TEUTYP)
CC!            TYPE*,'DEBUG: TGAMTYP',TRABUF(TGAMTYP)
CC!            TYPE*,'DEBUG: SERIAL',SER

            SEROFFSET = SER
            RETURN
          ENDIF
        ! SIGN ON/OFF
!        ELSE IF((TRABUF(TSTAT) .EQ. GOOD) .AND. (TRABUF(TTYP) .EQ. TSPE) .AND.
        ELSE IF((TRABUF(TERR) .EQ. NOER) .AND. (TRABUF(TTYP) .EQ. TSPE) .AND.
     *         ((TRABUF(TSFUN) .EQ. TSON) .OR. (TRABUF(TSFUN) .EQ. TSOFF))) THEN
CC!          TYPE*,' INFO: SIGN OF/OFF FOUND!'
CC!          TYPE*,'DEBUG: TERR',TRABUF(TERR)
CC!          TYPE*,'DEBUG: TTYP',TRABUF(TTYP)
CC!          TYPE*,'DEBUG: TSFUN',TRABUF(TSFUN)
CC!          TYPE*,'DEBUG: SERIAL',SER
          SEROFFSET = SER
          RETURN
        ELSE
          SEROFFSET = SER	  
        ENDIF

        GOTO 10
        END

C**************************************************
C SUBROUTINE: GETS THE HOUR, MIN AND SEC GIVEN THE
C             TOTAL NUMBER OF SECONDS
C INPUT:
C     NUM - NUMBER OF SECONDS TO CONVERT
C
C OUTPUT:
C     HR - HOUR
C     MIN - MINUTE
C     SEC - SECONDS
C**************************************************
C
C=======OPTIONS /CHECK=NOOVERFLOW
        SUBROUTINE DISTIM(NUM,HR,MIN,SEC)
        IMPLICIT NONE
C
        INTEGER*4   NUM, HR, MIN, SEC
C
        SEC=NUM
        IF(SEC.GT.'40000000'X) SEC=SEC-'40000000'X
C***    SEC = IAND(SEC,'7FFFFFFF'X)
        HR=SEC/3600
        SEC=SEC-(HR*3600)
        MIN=SEC/60
        SEC=SEC-(MIN*60)
        IF(HR.GT.99) HR=99

        RETURN
        END

