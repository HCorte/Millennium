C PROGRAM NBRPRO
C
C V12 21-JUN-2002 JHR Checksum & sequence # update for cancellations moved here.
C V11 25-JAN-2001 UXN All cancellations are now 2 phase transactions.
C V10 04-OCT-2000 UXN GLOBAL RFSS #91
C V09 26-JUN-2000 OXK BTEST -> TSBIT
C V08 30-MAR-1999 UXN&WS FIX FOR FAILURE TO READ FROM TMF IN CASE
C                        IF ORIGINAL WAGER RECORD NOT WRITTEN YET BY APULOG
C V07 21-MAY-1994 HXK CHANGE CHECK FOR 2 BYTE CHECKSUM; CHECK FOR LSTSER .EQ. 0
C V06 21-MAY-1994 HXK CHANGE CHECK FOR 2 BYTE CHECKSUM; CHECK FOR LSTSER .EQ. 0
C V05 03-SEP-1993 HXK Removed supression of priv ter wagering
C V04 21-JAN-1993 DAB Initial Release
C                     Based on Netherlands Bible, 12/92, and Comm 1/93 update
C                     DEC Baseline
C V03 24-MAY-1992 HDB ADDED UPDSTA (STATISTICS)
C V02 07-OCT-1991 MTK INITAL RELEASE FOR NETHERLANDS
C V01 01-AUG-1990 XXX RELEASED FOR VAX
C
C NUMBERS WAGER PROCESSING TASK
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 2000 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM NBRPRO
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:NBRCOM.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:AGTCOM.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:PRMLOG.DEF'
	INCLUDE 'INCLIB:CHKSUMCM.DEF'
C
	INTEGER*4 MESS(EDLEN),LOGREC(LREC*3),WRKBUF(TRALEN)
	INTEGER*4 ERCODE, BETOFF, I, ST, LSTSER, ENCMES, ENCACT
	INTEGER*4 GAME, AGAME, TYPE, TER, BUF, STATUS
	INTEGER*4 TASK, LNUM, LGIND, LPOOL, LTYPE
        INTEGER*4 SIMOUTTAB(40)
        INTEGER*2 SIMOUTLEN
	LOGICAL	  WARN
C
        INTEGER*4  I4TEMP               ! rev 1.2
        INTEGER*2  I2TEMP(2)            ! rev 1.2
        EQUIVALENCE (I4TEMP,I2TEMP(1))  ! rev 1.2
C
	CALL COPYRITE
	CALL SNIF_AND_WRKSET
C
	TASK=NBR
	MESS(1)=TASK
5	CONTINUE
        BASECHKSUM=IAND(DAYCDC,'FFFF'X)
C
C WAIT FOR SOMETHING TO DO
C IF END OF DAY THEN CALL GSTOP(GEXIT_SUCCESS)
C
10	CONTINUE
	IF(DAYSTS.EQ.DSCLOS) CALL GSTOP(GEXIT_SUCCESS)
	IF(DAYSTS.EQ.DSSUSP) THEN
	  CALL HOLD(0,STATUS)
	  IF(DAYSTS.EQ.DSOPEN) GOTO 5
	  GOTO 10
	ENDIF
	CALL HOLD(0,STATUS)
C
C GET BUFFER NUMBER FROM TOP OF QUEUE.
C IF NO WAGERS QUEUED, GO BACK TO WAIT STATE.
C
20	CONTINUE
	CALL TOPQUE(TASK,BUF)
	IF(BUF.EQ.0) GOTO 10
C
C DECODE TERMINAL MESSAGE INTO INTERNAL TRANSACTION FORMAT
C
	TER=HPRO(TERNUM,BUF)
	TYPE=HPRO(TRCODE,BUF)
	IF(TYPE.EQ.TYPNCN.OR.TYPE.EQ.TYPNDL) GOTO 1000
C
C
	CALL FASTSET(0,TRABUF,TRALEN)
	TRABUF(TSTAT)=GOOD
	TRABUF(TERR)=NOER
	TRABUF(TTYP)=TWAG
	TRABUF(TCDC)=DAYCDC
	TRABUF(TTER)=TER
	TRABUF(TSER)=PRO(SERIAL,BUF)
	TRABUF(TTIM)=PRO(TSTAMP,BUF)
	TRABUF(TSIZE)=HPRO(NUMLRC,BUF)
	TRABUF(TAGT)=AGTTAB(AGTNUM,TER)
	CALL DNBR(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
C
C CHECK IF TRANSACTION TYPE IS SUPRESSED ON
C AGENT AND GLOBAL LEVELS
C
	AGAME=0
	GAME=TRABUF(TGAM)
	IF(GAME.NE.0) AGAME=AGTGAM(GFLAGS,GAME,TER)
	IF(TSBIT(AGTTAB(AGTTYP,TER),AGTWAG))   TRABUF(TERR)=SUPR
C***	IF(TSBIT(AGTTAB(AGTTYP,TER),AGTPRV))   TRABUF(TERR)=SUPR !not in Finland
	IF(TSBIT(AGAME,AGTWAG))                TRABUF(TERR)=SUPR
	IF(TSBIT(P(SUPGWA),GAME))              TRABUF(TERR)=SUPR
	IF(P(SUPWAG).NE.0)                     TRABUF(TERR)=SUPR
C
C CHECK AGENT AND SYSTEM STATUS
C
	IF(AGTHTB(AOPSTS,TER).NE.SIGNON)       TRABUF(TERR)=NOTON
	IF(P(SYSSTS).EQ.SYSDRW)                TRABUF(TERR)=SDRW
	IF(P(SYSSTS).EQ.SYSDOR)                TRABUF(TERR)=SDOR
C
C CHECK FOR DES ERROR
C
	IF(P(DESACT).EQ.0) THEN
	  ENCMES = BPRO(BINPTAB,BUF)
	  ENCMES = IAND(ENCMES,'08'X)
	  IF(P(DESFLG).EQ.0 .AND.
     *       TSBIT(AGTTAB(AGTTYP,TER),AGTDES)) THEN
	    ENCACT = '08'X
	  ELSE
	    ENCACT = 0
	  ENDIF
	  IF(ENCMES.NE.ENCACT) TRABUF(TERR) = DESMOD
	ENDIF
	IF(TRABUF(TERR).NE.NOER) TRABUF(TSTAT)=REJT
C
C IF TERMINAL RETRY, AND TRANSACTION STATUS IS GOOD, AND
C TRANSACTION SEQUENCE NUMBER MATCHES THE LAST SEQUENCE
C NUMBER FOR THIS TERMINAL, CONTINUE RETRY PROCESSING, ELSE
C PROCESS AS NORMAL.
C

        LSTSER = AGTTAB(ALSTRA,TER)          ! rev 1.2
        IF(LSTSER.EQ.0) GOTO 80              ! rev 1.2

        IF(HPRO(   SIMMOD,BUF).EQ.-999)GOTO 80
	IF(TRABUF(TTRN).EQ.AGTHTB(ATRNUM,TER)) THEN

	  IF(TRABUF(TCHK).NE.ZEXT(AGTHTB(ACHKSM,TER))) THEN

	    LSTSER=AGTTAB(ALSTRA,TER)
	    CALL RLOG(LSTSER,LOGREC,TASK,ST)
CV08
	    IF (ST.NE.0) THEN
		CALL WAIT_APUQUE
      		CALL RLOG(LSTSER,LOGREC,TASK,ST)
	    ENDIF
CEV08
	    IF(ST.NE.0) GOTO 80
	    CALL LOGTRA(WRKBUF,LOGREC)
	    IF(WRKBUF(TTYP).NE.TWAG)           GOTO 80
	    IF(WRKBUF(TCHK).NE.TRABUF(TCHK))   GOTO 80
	    IF(WRKBUF(TTRN).NE.TRABUF(TTRN))   GOTO 80
	    IF(WRKBUF(TGAM).NE.TRABUF(TGAM))   GOTO 80
	    IF(WRKBUF(TWAMT).NE.TRABUF(TWAMT)) GOTO 80
	    DO 40 I=0,TRABUF(TWNBET)-1
	    IF(WRKBUF(TWNNUM1+I*3).NE.TRABUF(TWNNUM1+I*3)) GOTO 80
	    IF(WRKBUF(TWNPOL1+I*3).NE.TRABUF(TWNPOL1+I*3)) GOTO 80
	    IF(WRKBUF(TWNAMT1+I*3).NE.TRABUF(TWNAMT1+I*3)) GOTO 80
40	    CONTINUE
            IF(TRABUF(TWBEG).GT.WRKBUF(TWBEG)) THEN
                IF(TRABUF(TTIM)-WRKBUF(TTIM).GT.60) GOTO 80
                IF(WRKBUF(TGAMTYP).EQ.TNBR) THEN
                   IF(NBRSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                TRABUF(TWBEG) = WRKBUF(TWBEG)
                TRABUF(TWEND) = WRKBUF(TWEND)
            ENDIF
	    IF(WRKBUF(TWBEG).NE.TRABUF(TWBEG)) GOTO 80
	    IF(WRKBUF(TWEND).NE.TRABUF(TWEND)) GOTO 80
	  ENDIF
	  TRABUF(TSTAT)=REJT
	  TRABUF(TERR )=RETY
	  CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
	  TRABUF(TSER)=AGTTAB(ALSTRA,TER)
	  TRABUF(TSTAT) = GOOD
	  TRABUF(TERR)  = NOER
	  CALL OUTWAG(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
	  GOTO 90
	ENDIF
C
C UPDATE POOLS AND CHECK IF LIMIT EXCEEDED
C
80	CONTINUE
	IF(TRABUF(TSTAT).EQ.GOOD) THEN
	  CALL UPLIAB(TRABUF,.FALSE.,BETOFF,WARN)
	  IF(TRABUF(TERR).EQ.LIAB.OR.WARN) THEN
	    LTYPE=1
	    IF(TRABUF(TERR).EQ.LIAB) LTYPE=2
	    LGIND=TRABUF(TGAMIND)
	    LNUM=TRABUF(TWNNUM1+BETOFF*3)
	    LPOOL=TRABUF(TWNPOL1+BETOFF*3)
	    CALL LMESCHK(LTYPE,LGIND,LNUM,LPOOL,ST)
	    IF(ST.EQ.0) THEN
	      MESS(2)=TEGEN
	      MESS(3)=22
	      IF(LTYPE.EQ.2) MESS(3)=21
	      MESS(4)=LGIND
	      MESS(5)=LNUM
	      MESS(6)=LPOOL
	      CALL QUEMES(MESS)
	    ENDIF
	  ENDIF
	ENDIF
C
C UPDATE FINANCIAL INFORMATION
C
	IF(TRABUF(TSTAT).EQ.GOOD) THEN
	  CALL UPDSUB(TRABUF)
	  CALL UPDSTA(TRABUF)
	  PERFRM(1,GAME)=PERFRM(1,GAME)+1
	ENDIF
	CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
	IF(TRABUF(TERR).EQ.TBAD) HPRO(ENCOVR,BUF)=-1
        IF(HPRO(SIMMOD,BUF).EQ.-999)THEN
          CALL OUTWAG(TRABUF,SIMOUTTAB, SIMOUTLEN)    !DON'T DESTROY INPUT
	  SIMOUTLEN=0
        ELSE
          CALL OUTWAG(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
        ENDIF
C
C IF SYNTAX ERROR THEN PRINT ERROR CODE
C ON THE CONSOLE.
C
	IF(P(SUPSYN).EQ.0.AND.SYNTERRCOD.NE.0.AND.
     *	   TRABUF(TERR).NE.NOTON) THEN
	  MESS(2)=TEGEN
	  MESS(3)=10
	  MESS(4)=SYNTERRCOD
	  MESS(5)=TER
	  MESS(6)=TRABUF(TGAMTYP)
	  MESS(7)=TRABUF(TGAMIND)
	  MESS(8)=TRABUF(TSER)
	  CALL QUEMES(MESS)
	ENDIF
C
C QUEUE TRANSACTION TO LOGGER OUTPUT QUEUE
C
90	CONTINUE
	AGTHTB(ATRNUM,TER)=TRABUF(TTRN)
	IF(TRABUF(TSTAT).NE.GOOD.AND.TRABUF(TERR).NE.RETY) THEN
	  AGTHTB(ACHKSM,TER)=-1
	ELSE
	  AGTHTB(ACHKSM,TER)=TRABUF(TCHK)
	ENDIF
	CALL QUETRA(APU, BUF)
	CALL DQUTRA(TASK,BUF)
	GOTO 20
C
C PROCESS NUMBERS CANCELLATIONS AND DELETIONS.
C CANCELLATION AND WAGER ARE ENCODED IN THE WORK
C AREA OF THE PROCOM BUFFER (FROM CANPRO/INCPRO).
C UPDATE SALES DATA FOR NUMBERS CANCELLATIONS.
C
1000	CONTINUE
	CALL LOGTRA(TRABUF,PRO(WRKTAB,BUF))
C 
        AGTHTB(ATRNUM,TER)=TRABUF(TTRN)        ! V12
        AGTHTB(ACHKSM,TER)=-1                  ! V12
C
	TERMCHKSUM = TRABUF(TCHK)
	ERCODE     = TRABUF(TSUBERR)

	IF(TRABUF(TSTAT).EQ.REJT) GOTO 1100

	CALL RLOG(TRABUF(TWCSER),LOGREC,TASK,STATUS)
CV08
	IF (STATUS.NE.0) THEN
	    CALL WAIT_APUQUE
      	    CALL RLOG(TRABUF(TWCSER),LOGREC,TASK,STATUS)
	ENDIF
CEV08
	CALL LOGTRA(WRKBUF,LOGREC)
	IF(STATUS.NE.0.OR.WRKBUF(TSER).NE.TRABUF(TWCSER)) THEN
	  TRABUF(TSTAT)=REJT
	  TRABUF(TERR)=INVL
	  CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
	  ERCODE=1
	ELSE
	  WRKBUF(TSTAT)=VOID
	  IF(TRABUF(TTYP).EQ.TINC) WRKBUF(TSTAT)=INCA
	  WRKBUF(TWCSER)=TRABUF(TSER)
	  WRKBUF(TWCTER)=TRABUF(TTER)
	  CALL TRALOG(WRKBUF,LOGREC)
	  CALL UPDSUB(TRABUF)
	  CALL UPDSTA(TRABUF)
	  CALL UPLIAB(TRABUF,.FALSE.,BETOFF,WARN)
	  CALL WLOG(WRKBUF(TSER),LOGREC,TASK)
	  ERCODE=0
	ENDIF
C
1100	CONTINUE
C
        IF(TRABUF(TTYP).EQ.TCAN) THEN
          IF(HPRO(SIMMOD,BUF).EQ.-999)THEN
            CALL OUTCAN(TRABUF,SIMOUTTAB,SIMOUTLEN,ERCODE)
          ELSE
            CALL OUTCAN(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF),ERCODE)
          ENDIF
        ELSE
          CALL OUTDEL(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
        ENDIF
	HPRO(TRCODE,BUF)=TYPREG
	CALL QUETRA(APU, BUF)
	CALL DQUTRA(TASK,BUF)
	GOTO 20
C
	END
