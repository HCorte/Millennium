C
C *** SUBROUTINE BLDCONF ***
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]MSC_BLDCONF.FOV                              $
C  $Date::   17 Apr 1996 14:07:10                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C  
C *** Pre-Baseline Source - msc_bldconf.for ***
C
C V03 07-JAN-94 PJS MODIFIED TO HANDLE MULTIPLE SWITCHES.
C V02 13-JAN-93 RRB PASS SEARCH STRING TO GETPARM
C                   STARTING AT EXPECTED BEGINNING OF TARGET STRING.
C V01 29-JAN-91 RRB RELEASED FOR VAX.
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode Island,
C and contains confidential and trade secret information. It may not be
C transferred from the custody or control of GTECH except as authorized in
C writing by an officer of GTECH. Neither this item nor the information it
C contains may be used, transferred, reproduced, published, or disclosed,
C in whole or in part, and directly or indirectly, except as expressly
C authorized by an officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose:
C	BUILD MATRIX SWITCH CONFIGURATION SO THAT IT MAY BE CHECKED
C	AGAINST X2X CONFIGURATION PERIODICALLY IN TIME TRAP.
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE BLDCONF(MESSAGE)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
C
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:MSCCOM.DEF'
	INCLUDE 'INCLIB:MSCCMDS.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
C
C LOCAL DECLARATIONS
C
	INTEGER*4	BEG_IND,
     *			END_IND,
     *			END_SWITCH,			! ENDING SWITCH #
     *			IDX_SWITCH,			! SWITCH # INDEX
     *			INC_SWITCH,			! SWITCH # INCREMENT
     *			FIRST_PAGE,
     *			I,
     *			IND,
     *			IND1,
     *			IND2,
     *			LAST_PAGE,
     *			LOC_CONFIG(MSC_MAX_PORTS),	! TEMP OF MSC CONFIG
     *			LOC_PORT,			! LOCAL PORT
     *			NET_CONFIG(MSC_MAX_PORTS),	! TEMP OF MSC CONFIG
     *			NET_PORT,			! NETWORK PORT
     *			ST,
     *			STR_LEN,
     *			SEL_SWITCH,			! SELECTED SWITCH
     *			TIND
C
	CHARACTER*(*)	MESSAGE
C
	CHARACTER*81	LINE
C
	CHARACTER*1	CR		/Z0D/
C
	LOGICAL*4	FIRST_TIME	/.TRUE./,	! FIRST TIME CALLED ?
     *			FORWARDS,			! DIR OF SWITCH SELECT
     *			NEW_PAGE
C
	INTEGER*4	IMSCCMD(20)
	CHARACTER*80	MSCCMD
	EQUIVALENCE	(IMSCCMD, MSCCMD)
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C THE FOLLOWING STATEMENT IS NOT ABSOULTELY NECESSARY UNDER VAX FORTRAN ...
C HOWEVER, IT WOULD BE REQUIRED TO COMPLY WITH THE ANSI F77 SPECIFICATION.
C
	SAVE		END_SWITCH,
     *			INC_SWITCH,
     *			FIRST_PAGE,
     *			FIRST_TIME,
     *			FORWARDS,
     *			LAST_PAGE,
     *			LOC_CONFIG,
     *			NET_CONFIG,
     *			SEL_SWITCH
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C WHEN WE ARE CALLED FOR THE FIRST TIME, THE FIRST SWITCH HAS BEEN SELECTED
C AND THE DIRECTION OF SWITCH SELECTION IS FORWARDS (I.E. FORWARDS <- .TRUE.).
C
C SO WE LOOP THROUGH THE SWITCHES BEGINNING AT 1,
C SELECTING EACH SUBSEQUENT SWITCH AS WE PROCEED.
C
C WHEN WE ARE FINISHED, THE LAST SWITCH WILL HAVE BEEN SELECTED AND ONCE
C THE CONFIGURATION HAS BEEN RECEIVED, WE CHANGE DIRECTION FOR THE NEXT TIME.
C
C THIS ALLEVIATES UNNECESSARY SWITCH SELECTION.
C
	IF (FIRST_TIME) THEN
	  FIRST_TIME = .FALSE.
	  FORWARDS   = .TRUE.
	  SEL_SWITCH = 1
	  END_SWITCH = MSC_CONF_INFO(SWITCH_CNT)
	  INC_SWITCH = 1
	ENDIF
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C LOOP THRU MESSAGE RECEIVED FROM MSC AND
C DECODE EACH LINE CONTAINING A CONNECTION.
C
	MSC_CONF_FLAG = CONF_REC_IN_PROG
C
	NEW_PAGE = .TRUE.
	BEG_IND  = 2
	END_IND  = 0
C
100	CONTINUE
	BEG_IND = BEG_IND + END_IND + 1
	END_IND = INDEX(MESSAGE(BEG_IND:), CR)
	IF (END_IND .LE. 0) GOTO 300
	IF (END_IND .GT. LEN(LINE)) END_IND = LEN(LINE)
	LINE = MESSAGE(BEG_IND:BEG_IND + END_IND)
C
C FIRST, GET BEGINNING AND ENDING PAGE NUMBER
C
	IF (NEW_PAGE) THEN
	  NEW_PAGE = .FALSE.
	  IND = INDEX(LINE, 'Page:')
	  IF (IND .GT. 0) THEN
	    CALL GETPARM(LINE(IND:), 'Page:', FIRST_PAGE)
	    IF (FIRST_PAGE .EQ. 1) THEN
	      IND = INDEX(LINE, 'of')
	      CALL GETPARM(LINE(IND:), 'of', LAST_PAGE)
	    ENDIF
	    IF (FIRST_PAGE .LT. LAST_PAGE) THEN
	      MSCCMD = NEXT_PAGE // CR
	      CALL MSC_QUECMD(IMSCCMD)
	    ENDIF
	    GOTO 100
	  ENDIF
C
C SINGLE PAGE RESPONSE HAS NO "PAGE X OF X" HEADER
C
	  FIRST_PAGE = 0
	  LAST_PAGE  = 0
	ENDIF
C
C FIND MSC'S NETWORK PORT IDENTIFIER JUST SKIP LINE IF NOT FOUND
C
	IND = INDEX(LINE, 'DCE: ')
	IF (IND .LE. 0) GOTO 100
	IND = IND + 5
C
C CHECK FOR AUXILIARY PORT ID'S FIRST. SKIP TO NEXT LINE IF ONE FOUND.
C
	DO 200 I = 1, MSC_CONF_INFO(AUX_PORT_CNT)
	  CALL NOSPACES(AUX_PORT_ID(I), IND1, IND2, STR_LEN)
	  TIND = INDEX(LINE(IND:), AUX_PORT_ID(I)(IND1:IND2))
	  IF (TIND .GT. 0) GOTO 100
200	CONTINUE
C
C GET NETWORK PORT NUMBER USING MY NETWORK PORT ID.
C
	CALL GETPARM(LINE(IND:), CMSC_CONF_INFO(NET_PORT_ID), NET_PORT)
	IF (NET_PORT .LT. 0 .OR. NET_PORT .GT. X2X_NETWORK_PORTS) THEN
	  CALL OPS('*** MSC_BLDCONF - ' //
     *             'INVALID NETWORK PORT NUMBER ***',
     *             NET_PORT, NET_PORT)
	  GOTO 100
	ENDIF
C
C FIND MSC'S LOCAL PORT IDENTIFIER
C
	IND = INDEX(LINE, 'DTE: ')
	IF (IND .LE. 0) GOTO 100
	IND = IND + 5
C
C GET LOCAL PORT NUMBER USING MY LOCAL PORT ID.
C
	CALL GETPARM(LINE(IND:), CMSC_CONF_INFO(LOC_PORT_ID), LOC_PORT)
	IF (LOC_PORT .LT. 0 .OR. LOC_PORT .GT. X2X_LOCAL_PORTS) THEN
	  CALL OPS('*** MSC_BLDCONF - ' //
     *             'INVALID LOCAL PORT NUMBER ***',
     *             LOC_PORT, LOC_PORT)
	  GOTO 100
	ENDIF
C
C UPDATE SWITCH CONFIGURATION
C
	IF (LOC_PORT .NE. 0 .AND. NET_PORT .NE. 0) THEN
	  LOC_CONFIG(LOC_PORT) = NET_PORT
	  NET_CONFIG(NET_PORT) = LOC_PORT
C
C CHECK IF ALARM REPORTING IS ENABLED
C
	  IND = INDEX(LINE, '@')
	  IF (IND .GT. 0) THEN
	    MSC_ALARM_STATUS(LOC_PORT) = MSCPA_ENABLED
	  ELSE
	    MSC_ALARM_STATUS(LOC_PORT) = MSCPA_DISABLED
	  ENDIF
C
C CHECK IF PORT IS ALARMED
C
	  IND = INDEX(LINE, 'ALM')
	  IF (IND .GT. 0) THEN
	    MSC_PORT_STATUS(LOC_PORT) = MSCPS_ALARMED
	  ELSE
	    MSC_PORT_STATUS(LOC_PORT) = MSCPS_NORMAL
	  ENDIF	
	ENDIF
C
C CHECK NEXT LINE
C
	GOTO 100
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C IF LAST PAGE OF CONFIGURATION RESPONSE, THEN UPDATE ACTUAL CONFIGURATION.
C INCREMENT (OR DECREMENT) THE SELECTED SWITCH NUMBER AND
C DETERMINE WHETHER ALL OF THE CONFIGURATION DATA HAS BEEN RECEIVED.
C IF SO, THEN UPDATE THE DIRECTION INDICATOR, SELECTED SWITCH NUMBER,
C ENDING SWITCH NUMBER, SWITCH NUMBER INCREMENT AND UPDATE THE MSC_CONF_FLAG
C TO BE CONFIGURATION RECEIVED.
C
300	CONTINUE
	IF (FIRST_PAGE .EQ. LAST_PAGE) THEN
	  SEL_SWITCH = SEL_SWITCH + INC_SWITCH
	  IF (FORWARDS) THEN
	    IF (SEL_SWITCH .GT. END_SWITCH) THEN
	      FORWARDS      = .FALSE.
	      SEL_SWITCH    = END_SWITCH
	      END_SWITCH    = 1
	      INC_SWITCH    = -1
	      MSC_CONF_FLAG = CONF_RECEIVED
	    ELSE
	      IDX_SWITCH = SWITCH_NAME + SEL_SWITCH - 1
	      MSCCMD = SELECT // CMSC_CONF_INFO(IDX_SWITCH) // CR
	      CALL MSC_QUECMD(IMSCCMD)
	    ENDIF
	  ELSE
	    IF (SEL_SWITCH .LT. END_SWITCH) THEN
	      FORWARDS      = .TRUE.
	      SEL_SWITCH    = END_SWITCH
	      END_SWITCH    = MSC_CONF_INFO(SWITCH_CNT)
	      INC_SWITCH    = 1
	      MSC_CONF_FLAG = CONF_RECEIVED
	    ELSE
	      IDX_SWITCH = SWITCH_NAME + SEL_SWITCH - 1
	      MSCCMD = SELECT // CMSC_CONF_INFO(IDX_SWITCH) // CR
	      CALL MSC_QUECMD(IMSCCMD)
	    ENDIF
	  ENDIF
	ENDIF	
C
C IF WE'VE RECEIVED ALL OF THE CONFIGURATION DATA THEN ...
C   RECORD THE TIME AND CLEAR TEMPORARY STORAGE.
C
	IF (MSC_CONF_FLAG .EQ. CONF_RECEIVED) THEN
	  CALL GETTIM(MSC_LAST_CONF_TIME)
	  CALL FASTMOV(LOC_CONFIG, MSC_LOCAL_TO_NETWORK, MSC_MAX_PORTS)
	  CALL FASTMOV(NET_CONFIG, MSC_NETWORK_TO_LOCAL, MSC_MAX_PORTS)
	  CALL FASTSET(0, LOC_CONFIG, MSC_MAX_PORTS)
	  CALL FASTSET(0, NET_CONFIG, MSC_MAX_PORTS)
	ENDIF
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C RETURN & END.
C
	RETURN
	END
