C NRM_GETSIZ_USED.FOR
C	
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GETSIZ_USED(LUN, SIZE)
	IMPLICIT NONE
C
	INTEGER*4   LUN
	INTEGER*4   SIZE
C
	IF(LUN.LE.0) THEN
	    SIZE=1
	    RETURN
	ENDIF
C
	CALL GET_VAX_FILE_SIZE_USED(LUN,SIZE)
	SIZE = SIZE * 2
C
	RETURN
	END
C
C *** GET_VAX_FILE_SIZE_USED
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_VAX_FILE_SIZE_USED(LUN, SIZE)
	IMPLICIT NONE
C
	INTEGER*4   LUN
	INTEGER*4   SIZE
C
	INTEGER*4   FOR$RAB
C
	CALL GFS_USED_1(%VAL(FOR$RAB(LUN)), SIZE)
C
	RETURN
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C *** GFS_USED_1
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GFS_USED_1(RAB, SIZE)
	IMPLICIT NONE
C
	INCLUDE	    '($RABDEF)'
C
	RECORD	    /RABDEF/ RAB
	INTEGER*4   SIZE
	INTEGER*4   FABADR
C
	FABADR = RAB.RAB$L_FAB
C
	CALL GFS_USED_2(%VAL(FABADR), SIZE)
	RETURN
	END
C
C
C *** GFS_USED_2
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GFS_USED_2(FAB, SIZE)
	IMPLICIT NONE
C
	INCLUDE	'($FABDEF)'
	INCLUDE '($XABDEF)'
	INCLUDE '($XABFHCDEF)'
C
	RECORD /FABDEF/ FAB
	RECORD /XABDEF/ XAB
	RECORD /XABFHCDEF/ XABFHC
C
	INTEGER*4   SIZE, STAT
	INTEGER*4   SYS$DISPLAY
C
	XAB.XAB$B_COD = XAB$C_FHC 			!  xab id code 
	XAB.XAB$B_BLN = XAB$C_FHCLEN			!  block length 
C	XAB.XABDEF$$_FILL_1	= 0			!  (spare) 
	XAB.XAB$L_NXT = 0				!  xab chain link 
C
	CALL FASTMOV(XAB,XABFHC,2)			! move header to XABFHC
C
	FAB.FAB$L_XAB = %LOC(XABFHC)
C
	STAT = SYS$DISPLAY(FAB)
	IF(.NOT.STAT) THEN
	  CALL LIB$SIGNAL(%VAL(STAT))
	ENDIF
C
	SIZE = XABFHC.XAB$L_EBK
C
C The first block is used for something else,
C and SIZE returned is always 1 higher than really is,
C so just subtract 2
C
	IF(FAB.FAB$B_ORG.EQ.FAB$C_REL) THEN
	  SIZE = MAX(0, SIZE - 2)
	ELSE
	  SIZE = MAX(0, SIZE - 1)
	ENDIF
C
	RETURN
	END
