C
C SUBROUTINE APU_WLOG
C $Log:   GXAFXT:[GOLS]APU_WLOG.FOV  $
C  
C     Rev 1.0   17 Apr 1996 12:12:52   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 15:39:36   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - wlogapu.for **
C
C WLOGAPU.FOR
C
C V02 08-JAN-93 TD  COMMENTED OUT NWLOG ENTRY POINT BECAUSE NO OTHER ROUTINE
C		    CALLS IT
C V01 25-JAN-91 TKO RELEASED FOR VAX
C
C *** THIS IS THE SAME AS WLOG EXCEPT IT KICKS LOGGER IF IT NEEDS TO READ ***
C
C
C LOGGER WRITE SUBROUTINE
C WRITE TRANSACTION TO APPROPIATE LOGGER MEMORY
C BUFFER.  IF BUFFER NOT CURRENTLY IN MEMORY
C CHECK IF IT IS A NEW BUFFER NOT YET WRITTEN.
C IF SO ALLOCATE A USED LOGGER BUFFER ELSE
C REQUEST BUFFER TO BE READ AND WAIT FOR COMPLETION.
C DETERMINE TRANSACTION TYPE AND
C BEFORE WRITTING RECORD, SET APPROPIATE RECORD TYPE
C IN LAST FOUR BITS OF RECORD. RECORD TYPE IS AS FOLLOWS:
C     1 - SINGLE RECORD TRANSACTION
C     2 - FIRST RECORD OF A MULTI-RECORD TRANSACTION
C     3 - SECOND RECORD OF A MULTI-RECORD TRANSACTION
C     4 - LAST  RECORD OF A MULTI-RECORD TRANSACTION
C
C ENTRY NWLOG WILL NOT WAIT BETWEEN TRIES FOR COMMON ACCESS.
C
C CALLING SEQUENCE:
C     CALL APU_WLOG(SERIAL,RECORD)
C     CALL NWLOG(SERIAL,RECORD)
C INPUT
C     SERIAL   -  TRANSACTION SERIAL NUMBER
C     RECORD   -  TRANSACTION LOG RECORD
C OUTPUT
C     NONE
C
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE APU_WLOG(SERIAL,RECORD)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:LOGCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:DESLOG.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INTEGER*4 RECORD(LREC*3), BLOCK, LENGTH, TYPE, CNT !RECORD(LREC*3) tamanho maximo da mensagem s√£o os 3 segmentos <-> 48 bytes
	INTEGER*4 K, STATUS, RTYPE, BL, ST, UPCNT, OFFSET, INDEX
	INTEGER*4 SERIAL
	LOGICAL WFLAG,NEWREC
	WFLAG=.TRUE.
	GOTO 5
C
C NWLOG ENTRY -- DON'T WAIT BETWEEN TRIES FOR COMMON ACCESS
C
CCC	ENTRY NWLOG(SERIAL,RECORD)
CCC	WFLAG=.FALSE.
CCC	GOTO 5
C
C
5	CONTINUE
	NEWREC=.FALSE.
	IF(SERIAL.LT.1) RETURN
	IF(MOD(SERIAL,SYSOFF).GT.HRSER) HRSER=MOD(SERIAL,SYSOFF)
C
C DETERMINE RECORD LENGTH
C
	CNT=1
	TYPE=ISHFT(RECORD(LREC),-24) !size of the log record filtra os 3 bytes menos significativos
	TYPE=IAND(TYPE,7) ! 7d =  0111b filtra o 4 bit mais significativo
	IF(TYPE.EQ.LONE) THEN !FIRST RECORD OF A MULTI RECORD TRANS (primeiro segmento) - maximo de 3 segmentos
 	  TYPE=ISHFT(RECORD(LREC*2),-24)
	  TYPE=IAND(TYPE,7)
	  IF(TYPE.EQ.LEND) CNT=2
	  IF(TYPE.EQ.LTWO) CNT=3
	ENDIF
	LENGTH=LREC*CNT
C
C GET TRANSACTION BLOCK AND INDEX
C
	CALL GETBI(SERIAL,BLOCK,INDEX,OFFSET)
	OFFSET=OFFSET+LOGHDR-1
C
C IF TRANSACTION USES THE OVERFLOW RECORDS AT THE
C END OF THE BLOCK THEN ADJUST THE LOG BLOCK RECORD
C UPDATE COUNT
C
	UPCNT=CNT
	IF(INDEX.EQ.LBLK) UPCNT=1
	IF(INDEX.EQ.LBLK-1.AND.CNT.EQ.3) UPCNT=2
C
C SCAN MEMORY RESIDENT LOGGER BLOCKS FOR
C THIS BLOCK.
C
10	CONTINUE
	IF(LOKON(P(LOGFLG))) THEN
15	  CONTINUE
	  IF(P(LOGFLG).NE.0) THEN
	    IF(WFLAG) CALL XWAIT(5,1,ST)
	    GOTO 15
	  ENDIF
	  GOTO 10
	ENDIF
C
	  DO 1000 BL=1,NUMLOG
	  IF(LOGBUF(BLONUM,BL).NE.BLOCK) GOTO 1000
C
C IF STATUS EQUALS READY FOR I/O THEN
C WRITE TRANSACTION TO BUFFER
C
	    IF(LOGBUF(BSTATE,BL).EQ.LGRDY.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGUSD.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGRRW.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGROU) THEN
	        RTYPE=ISHFT(LOGBUF(OFFSET+LREC-1,BL),-24)
	        IF(IAND(RTYPE,7).EQ.0) NEWREC=.TRUE.
	        CALL FASTMOV(RECORD(1),LOGBUF(OFFSET,BL),LENGTH)
	        OFFSET=OFFSET+LENGTH
C
C INCREMENT BLOCK RECORD COUNT
C AND CHANGE STATE TO READY FOR I/O.
C IF BLOCKING LIMIT HAS BEEN
C REACHED REQUEST BLOCK TO BE WRITTEN.
C
	        LOGBUF(LOGCNT,BL)=LOGBUF(LOGCNT,BL)+UPCNT
	        IF(NEWREC) LOGBUF(BLKCNT,BL)=LOGBUF(BLKCNT,BL)+UPCNT
	        IF(MOD(SERIAL,SYSOFF).GT.LOGBUF(BLHISR,BL))
     *	          LOGBUF(BLHISR,BL)=MOD(SERIAL,SYSOFF)
	        IF(LOGBUF(LOGCNT,BL).GT.P(LOGBLO))THEN
	          LOGBUF(BSTATE,BL)=LGROU
C*V02*	          CALL RELSE(TSKNAM(LOG),STATUS)
	        ELSE
	          LOGBUF(BSTATE,BL)=LGRDY
	        ENDIF
C
C ALWAYS EXIT CRITICAL REGION
C
	        CALL LOKOFF(P(LOGFLG))
C
	      RETURN
	    ELSE
C
C ALWAYS EXIT CRITICAL REGION
C
	      CALL LOKOFF(P(LOGFLG))
C
C*V02*	      CALL RELSE(TSKNAM(LOG),STATUS)
C*V02*	      CALL HOLD(0,STATUS)
	      CALL XWAIT(13,1,ST)
	      GOTO 10
	    ENDIF
1000	  CONTINUE
C
C BLOCK NOT FOUND ALLOCATE A USED BLOCK
C AND REQUEST BLOCK TO BE READ IF IT HAS
C ALREADY BEEN WRITTEN TO DISK.
C USE ROUND ROBIN SEARCH TO GIVE EVERYONE A CHANCE.
C
	  DO 2000 K=1,NUMLOG
	  BL=SBLOCK
	  BL=MOD(BL,NUMLOG)+1
	  SBLOCK=BL
	  IF(LOGBUF(BSTATE,BL).NE.LGUSD) GOTO 2000
	  LOGBUF(BLONUM,BL)=BLOCK
	  LOGBUF(LOGCNT,BL)=0
	  LOGBUF(BLTAPE,BL)=0
C
C IF BLOCK NOT YET WRITTEN ALLOCATE A USED
C BUFFER AND PROCESS THE REQUEST.
C
	    IF(BLOCK.GT.HBLOCK) THEN
	      HBLOCK=BLOCK
	      CALL FASTSET(0,LOGBUF(DSKREC,BL),LOGLEN-DSKREC+1)
	      LOGBUF(TSKMAP,BL)=0
	      LOGBUF(BSTATE,BL)=LGRDY
C
C ALWAYS EXIT CRITICAL REGION
C
	    CALL LOKOFF(P(LOGFLG))
C
	    ELSE
C
C IF BLOCK ALREADY WRITTEN REQUEST THE
C LOGGER TASK TO READ THE BLOCK AND WAIT
C FOR COMPLETION.  WHEN DONE GOTO PROCESS
C THE REQUEST.
C
	      LOGBUF(BSTATE,BL)=LGRIN
C
C ALWAYS EXIT CRITICAL REGION
C
	      CALL LOKOFF(P(LOGFLG))
C
	      CALL RELSE(TSKNAM(LOG),STATUS)
C*V02*	      CALL HOLD(0,STATUS)
	      CALL XWAIT(13,1,ST)
	    ENDIF
	  GOTO 10
2000	  CONTINUE
C
C NO BUFFERS AVAILABLE ADD TASKS ID
C NUMBER TO A ACTIVE LOGGER BUFFER
C SO LOGGER WILL KICK US WHEN A BUFFER
C BECOMES AVAILABLE.
C
C
C ALWAYS EXIT CRITICAL REGION
C
	CALL LOKOFF(P(LOGFLG))
	CALL RELSE(TSKNAM(LOG),STATUS)
C*V02*	CALL HOLD(0,STATUS)
	CALL XWAIT(13,1,ST)
	GOTO 10
	END
