C *** SUBROUTINE MSC_SNDBUF ***
C
C V04 13-JUN-2000 OXK MSC_TIMEOUTS from MSCCOM.DEF to here (not used elsewhere)
C V03 09-DEC-1993 RRB INITIATE READ AFTER WRITE AND WAIT FOR RESPONSE
C                      OR TIMEOUT. USED TO BE ASYNCHRONOUS IN NATURE
C                      BUT TELENEX CHANGED THEIR WAY OF DOING THINGS
C		       WITH REV 8.0 AND HIGHER. THIS SIMPLIFIES THIS
C                      LOGIC CONSIDERABLY, RELATIVE TO THE WAY WE 
C                      ACTUALLY TALK TO THE SWITCH.
C V02 10-NOV-1993 RRB INCREMENT WRITE TIMOUT COUNTER
C V01 23-DEC-1992 RRB VAX INITIAL RELEASE (ISOLATED FROM MSCMGR.FOR)
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode Island,
C and contains confidential and trade secret information. It may not be
C transferred from the custody or control of GTECH except as authorized in
C writing by an officer of GTECH. Neither this item nor the information it
C contains may be used, transferred, reproduced, published, or disclosed,
C in whole or in part, and directly or indirectly, except as expressly
C authorized by an officer of GTECH, pursuant to written agreement.
C
C Copyright 2000 GTECH Corporation. All rights reserved.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose:
C	1.) VERFIY CONNECTION IS ESTABLISHED VIA DECSERVER
C	2.) BUILD COMMAND PACKET AND SEND TO MSC
C	3.) WAIT FOR ACKNOWLEDGEMENT FROM MSC
C	4.) RELEASE BUFFER AND CONTINUE PROCESSING
C
C	NOTE: OUTPUT BUFFER LENGTH IS DETERMINED BY LOCATING THE POSITION OF THE
C	      CARRAIGE RETURN CHARACTER REQUIRED BY THE MSC. ALL OUTPUT BUFFERS
C	      SHOULD THEREFORE BE TERMINATED WITH A CARRAIGE RETURN PRIOR TO
C	      BEING QUEUED HERE.
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE MSC_SNDBUF(BUF)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:MSCCOM.DEF'
	INCLUDE 'INCLIB:MSCEVN.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:DESNET.DEF'
C
	INCLUDE '($IODEF)'
        INCLUDE '($SSDEF)'
        INCLUDE '($SYSSRVNAM)'
C
CV04 Previously in MSCCOM.DEF
	INTEGER*4   MSC_TIMEOUTS                ! CONNECTION TIMEOUTS
C
	INTEGER*4   BUF				!BUFFER NUMBER
	INTEGER*4   LRC	                        !EXCLUSIVE OR CHECKSUM
	INTEGER*4   LEN                         !DATA LENGTH IN BYTES
	INTEGER*4   STATUS, ST, IND, FLGSTS
	INTEGER*4   I1, I2
C
	BYTE        MSCWRITEBUF(MSCHDRLEN+MSCBYTLEN)!WRITE BUFFER
C
	INTEGER*2   TLEN
	BYTE        BLEN(2)
	EQUIVALENCE (BLEN,TLEN)
C
	CHARACTER*1   CR/Z0D/
C
C VERIFY OPEN CONNECTION TO SERVER BEFORE SENDING
C
        IF(MSC_CONNECT_FLAG.NE.MSC_OPENED) THEN
           MSCSTS = MSC_REQ_ONLINE         !RESET PROCESSING STATUS  
C
C OPEN CHANNEL ON LAT SERVER (MAKE SURE IT IS CLOSED FIRST)
C
           IF(LAT_CHANNEL.NE.0) CALL MSCCLOSE(LAT_CHANNEL,ST)
C
C IF WE CANNOT OPEN CONNECTION THEN FORGET IT FOR NOW. 
C WE WILL TRY TO REOPEN THE CONNECTION WITH EACH WRITE REQUEST.
C
           CALL MSCOPEN(LAT_NAME(NODEID), LAT_CHANNEL, ST)
           IF(ST.NE.0) THEN
	      CALL MSCFLUSH          !IF CANNOT OPEN, FLUSH EXEC QUEUE
	      GOTO 8000
	   ENDIF
           CALL OPS('LINK WITH SERVER RE-ESTABLISHED',0,0)
           MSC_CONNECT_FLAG = MSC_OPENED
	ENDIF
C
C INITIALIZE WRITE PARAMETERS
C
	MSC_SEND_CNT = 0
        CALL FASTSET(0,MSCWRITEBUF,(MSCHDRLEN+MSCBYTLEN)/4)
C
C BUILD LOCAL OUTPUT BUFFER
C
	MSCWRITEBUF(1) = SOH                 ! START OF PACKET
	LEN = INDEX(CMSCBUF(BUF),CR)         ! DATA LENGTH
	IF(LEN.LE.0.OR.LEN.GT.MSCBYTLEN) THEN
	   CALL OPS('Invalid out buffer length. BUFFER',
     *               BUF,BUF)
	   GOTO 8000
	ENDIF
	TLEN = LEN
	MSCWRITEBUF(2) = BLEN(2)
	MSCWRITEBUF(3) = BLEN(1)
 	MSCWRITEBUF(4) = LAST_BLOCK	     ! BLOCK TYPE (ONE AND ONLY)
	DO 2000 IND = 1,LEN
	   MSCWRITEBUF(MSCHDRLEN+IND) = BMSCBUF(IND,BUF)! ACTUAL DATA
2000    CONTINUE
C
C CALCULATE LRC
C
	CALL GETLRC(MSCWRITEBUF,2,MSCHDRLEN+LEN,LRC)
	MSCWRITEBUF(MSCHDRLEN+LEN+1) = LRC
C
C
C SET TEST FLAG TO DUMP BUFFER TO STANDARD OUTPUT
C
	IF(MSC_TEST.NE.0) THEN
           TYPE*,IAM(),'WRITE BUFFER:'
           DO 2100 I1 = 1,((MSCHDRLEN+LEN+1)+39)/40
	      WRITE(5,2200) (MSCWRITEBUF(I2),I2=40*I1-39,I1*40)
2100	   CONTINUE
2200       FORMAT(1X,40(Z02.2))		
	ENDIF
C
C INITIATE WRITE
C
	MSC_WRITE_IN_PROG = .TRUE.
3000    CONTINUE
        CALL MSCWRITEW(MSCWRITEBUF,MSCHDRLEN+LEN+1,STATUS)
	CALL GETTIM(MSC_LAST_SENT_TIME)
	MSC_WRITECNT = MSC_WRITECNT + 1
        MSC_SEND_CNT = MSC_SEND_CNT + 1
C
C INITITATE READ 
C
3500    CONTINUE
C
D       TYPE*,IAM(),'WAITING FOR ACK/NAK OR TIMEOUT RESPONSE'
	CALL MSCREAD
C
C CHECK FOR GOOD ACKNOWLEDGMENT
C
        STATUS=SYS$READEF(%VAL(MSC_ACK_FLAG),FLGSTS)
        IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
C
C IF ACK FLAG WAS SET CONTINUE PROCESSING
C
        IF(STATUS.EQ.SS$_WASSET) THEN
           STATUS=SYS$CLREF(%VAL(MSC_ACK_FLAG))
D	   TYPE*,IAM(),'RECEIVED ACKNOWLEDGEMENT FROM MSC'
           IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
	   MSC_TIMEOUTS = 0
	   GOTO 8000
        ELSE 
	   IF (STATUS.NE.SS$_WASCLR) THEN
              CALL OPS('INVALID EVENT FLAG IN WRITE TRAP',0,0)
              STATUS=SYS$CLREF(%VAL(MSC_ACK_FLAG))
              IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
	   ENDIF
	ENDIF
C
C CHECK FOR NEGATIVE ACKNOWLEDGEMENT FLAG
C
        STATUS=SYS$READEF(%VAL(MSC_NAK_FLAG),FLGSTS)
        IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
C
        IF(STATUS.EQ.SS$_WASSET) THEN
           STATUS=SYS$CLREF(%VAL(MSC_NAK_FLAG))
D	   TYPE*,IAM(),'RECEIVED NEGATIVE ACKNOWLEDGEMENT FROM MSC'
           IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
        ELSE 
	   IF(STATUS.NE.SS$_WASCLR) THEN
              CALL OPS('INVALID EVENT FLAG IN WRITE TRAP',0,0)
              STATUS=SYS$CLREF(%VAL(MSC_NAK_FLAG))
              IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
	   ENDIF
        ENDIF
C
C CHECK FOR TIMEOUT
C
        STATUS=SYS$READEF(%VAL(MSC_TOUT_FLAG),FLGSTS)
        IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
        IF(STATUS.EQ.SS$_WASSET) THEN
D	   TYPE*,IAM(),'RECEIVED WRITE TIME OUT IN SNDBUF' 
           STATUS=SYS$CLREF(%VAL(MSC_TOUT_FLAG))
           IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
        ELSE 
           IF (STATUS.NE.SS$_WASCLR) THEN
              CALL OPS('INVALID EVENT FLAG IN WRITE TRAP',0,0)
              STATUS=SYS$CLREF(%VAL(MSC_TOUT_FLAG))
              IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
	   ENDIF
	ENDIF
C
C REISSUE WRITE?
C
	IF(MSC_SEND_CNT.LT.MSC_SEND_MAX) THEN
           GOTO 3000
	ENDIF
C
C FORGET IT!
C
	MSC_TIMEOUTS = MSC_TIMEOUTS + 1
	IF(MSCSTS.GT.MSC_REQ_ONLINE)
     *     CALL OPS('Cannot send buffer ',BUF,BUF)
C
C IF TIMEOUT LIMIT EXCEEDED THEN FLUSH BUFFERS AND 
C CHANGE MSC STATUS TO CONNECT REQUEST.
C
	IF(MSC_TIMEOUTS.GT.MSC_TIMEOUT_MAX) THEN
           IF(MSCSTS.GT.MSC_REQ_ONLINE) THEN
   	      MSCSTS = MSC_REQ_ONLINE
   	      CALL OPS('Retry Limit Exceeded.....',0,0)
	   ENDIF
	   CALL MSCFLUSH              !FLUSH OUTSTANDING BUFFERS
        ENDIF
C
C RELEASE THIS BUFFER AND RETURN
C
8000    CONTINUE
	CALL MSCRELB(BUF)
	MSC_WRITE_IN_PROG = .FALSE.
	RETURN
	END
