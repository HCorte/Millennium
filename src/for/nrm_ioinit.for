C
C SUBROUTINE IOINIT
C $Log:   GXAFXT:[GOLS]IOINIT.FOV  $
C  
C     Rev 1.0   17 Apr 1996 13:39:54   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 16:41:34   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - nrm_diskio.for **
C
C
C
C *** IOINIT
C
C This is just like the IOINIT call under OS/32 except you call it
C with the number of bytes - not sectors
C
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE IOINIT(FDB, LUN, NUMBYTES)
	IMPLICIT NONE
C
	INCLUDE	    'INCLIB:SYSPARAM.DEF'
	INCLUDE	    'INCLIB:SYSEXTRN.DEF'
	INCLUDE	    'INCLIB:DISKIO.DEF'
C
C
	INTEGER*4   FDB(FDB_LENGTH)
	INTEGER*4   LUN
	INTEGER*4   NUMBYTES
C
	INTEGER*4   K
C
C
	IF(NUMBYTES.LT.256)THEN
	  TYPE *,IAM(),'IOINIT LENGTH TOO SHORT = ',NUMBYTES
	  CALL LIB$STOP(%VAL(0))
	ENDIF
	IF(NUMBYTES.GT.65535)THEN
	  TYPE *,IAM(),'IOINIT LENGTH TOO  LONG = ',NUMBYTES
	  CALL LIB$STOP(%VAL(0))
	ENDIF
C
D	IF(MOD(NUMBYTES,512).NE.0)THEN
D	  TYPE *,IAM(),'**** WARNING **** BAD SECTOR LENGTH = ',NUMBYTES
D	  CALL LIB$SIGNAL(%VAL(0))
D	ENDIF
C
	DO 110 K = 1, FDB_LENGTH
	  FDB(K) = 0
110	CONTINUE
C
	FDB(FDB_LUN)   = LUN		    !LUN #
	FDB(FDB_BYTSZ) = NUMBYTES	    !BYTES  PER I/O
	FDB(FDB_BLKSZ) = (NUMBYTES+511)/512 !BLOCKS PER I/O
C
	RETURN
	END
