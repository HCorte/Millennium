C
C SUBROUTINE OVRCHKPNT
C $Log:   GXAFXT:[GOLS]OVRCHKPNT.FOV  $
C  
C     Rev 1.0   17 Apr 1996 14:21:06   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 17:14:56   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - chkpnt.for **
C
C
C====================================================================
C   SUBROUTINE OVRCHKPNT - THIS SUBROUTINE WILL WRITE LOTTO POOLS
C                          AND OVER TABLE TO CHECK POINT FILE.
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE OVRCHKPNT
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CHKPNT.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:POOLLTO.DEF'
	INCLUDE 'INCLIB:CHKCOM.DEF'
C
	INTEGER*4 FDB(7),CFDB(7),CFILES(0:4)
	INTEGER*4 ONCE/0/
	INTEGER*4 LRECORD/0/,REST/0/,PAGES/0/
	DATA CFILES/CP0,CP1,CP2,CP3,CP4/
C
	INTEGER*4 I, WRITERECORD, READRECORD, SFIL, FILE, ST, LENGTH
	INTEGER*4 MAX
C
C NOTE: PAGESIZE IS THE SIZE OF ONE 'POOL' PAGE IN FULL WORDS
C	LTNUMPAG IS THE NUMBER OF PAGES NEEDED
C
	IF(ONCE.EQ.0) THEN
	  ONCE=-1
	  MAX=PAGESIZE*LTNUMPAG         !CHECKPOINT ALL
	  LENGTH=CHKPNTBUFLEN		!# OF WORDS TO CHKPNT AT ONCE
	  PAGES=MAX/LENGTH		!# OF CHKPNT BLOCKS TO WRITE
	  REST=MAX-(PAGES*LENGTH)	!# OF REMAINING WORDS TO WRITE
C***	  LRECORD=(PAGESIZE/64)*LTNUMPAG+1
	  LRECORD=(PAGESIZE/(SECSIZE/4))*LTNUMPAG+1
	  LENGTH=LENGTH*4          !XFER SIZE IN BYTES
	  REST=REST*4              !REMAINING BYTES
	ENDIF
C
C
C
	FILE=0
	IF(LCHKFIL.GT.0) FILE=LCHKFIL
	SFIL=CFILES(FILE)
	CALL OPENQW(3,SFNAMES(1,SFIL),4,0,0,ST)
	CALL IOQINIT(CFDB,3,CHKSEC*256)
	IF(ST.NE.0) THEN
	  CALL CHKMES(3,SFNAMES(1,SFIL),ST,0)
	  GOTO 9000
	ENDIF
C
C READ HEADER RECORD TO GET LENGTH OF
C CHECKPOINTED GAME DATA
C
	CALL READQW(CFDB,1,CHKHEADER,ST)
	IF(ST.NE.0) THEN
	  CALL CHKMES(4,SFNAMES(1,SFIL),ST,1)
	  GOTO 9000
	ENDIF
	CHKHEADER(CHKPNTDAY)=0
	CALL WRITEQW(CFDB,1,CHKHEADER,ST)
	IF(ST.NE.0) THEN
	  CALL CHKMES(5,SFNAMES(1,SFIL),ST,1)
	  GOTO 9000
	ENDIF
C
C
C
	CALL OPENQW(2,SFNAMES(1,LPR),4,0,0,ST)
	CALL IOQINIT(FDB,2,CHKSEC*256)
	IF(ST.NE.0) THEN
	  CALL CHKMES(3,SFNAMES(1,LPR),ST,0)
	  GOTO 9000
	ENDIF
C
C
	READRECORD=LRECORD
	WRITERECORD=(CHKSEC*256/SECSIZE)+1
	IF(LCHKFIL.LT.0)
     *     WRITERECORD=CHKHEADER(CHKGAMLEN)*CHKSEC*256/SECSIZE+1
C
C	CHECK, IF POOL PAGES ARE IN MEMORY, 'POOLPRO' WROTE THEM
C	TO THE DISK FILES
C
C	FIRST TIME DO CHECKPOINT EVEN IF POOLS ARE IN MEMORY
C
C****	IF(FILE .EQ. 0) GOTO 50      ;V04 
C
	IF( P(LTOPOL_RAM) .NE. LTOPOL_FIL_VALUE ) THEN
	    WRITERECORD = WRITERECORD + PAGES*(LENGTH/SECSIZE)
	    WRITERECORD = WRITERECORD+REST/SECSIZE
	    GOTO 1000
	ENDIF
C
50	CONTINUE
C
	DO 100 I=1,PAGES
	CALL READQIO(FDB,READRECORD,CHKPNTBUF,LENGTH,ST)
	IF(ST.NE.0) THEN
	  CALL CHKMES(4,SFNAMES(1,LPR),ST,READRECORD)
	  GOTO 9000
	ENDIF
	CALL WRITEQIO(CFDB,WRITERECORD,CHKPNTBUF,LENGTH,ST)
	IF(ST.NE.0) THEN
	  CALL CHKMES(5,SFNAMES(1,SFIL),ST,WRITERECORD)
	  GOTO 9000
	ENDIF
	READRECORD=READRECORD+LENGTH/SECSIZE
	WRITERECORD=WRITERECORD+LENGTH/SECSIZE
100	CONTINUE
C
C
	IF(REST.NE.0) THEN
	  CALL READQIO(FDB,READRECORD,CHKPNTBUF,REST,ST)
	  IF(ST.NE.0) THEN
	    CALL CHKMES(4,SFNAMES(1,LPR),ST,READRECORD)
	    GOTO 9000
	  ENDIF
	  CALL WRITEQIO(CFDB,WRITERECORD,CHKPNTBUF,REST,ST)
	  IF(ST.NE.0) THEN
	    CALL CHKMES(5,SFNAMES(1,SFIL),ST,WRITERECORD)
	    GOTO 9000
	  ENDIF
	  WRITERECORD=WRITERECORD+REST/SECSIZE
	ENDIF
C
C
1000	CONTINUE
	CALL WRITEQIO(CFDB,WRITERECORD,LSAVOVR,PAGESIZE*4,ST)
	IF(ST.NE.0) THEN
	  CALL CHKMES(5,SFNAMES(1,SFIL),ST,WRITERECORD)
	  GOTO 9000
	ENDIF
C
C UPDATE CHECKPOINT HEADER RECORD
C
	CHKHEADER(CHKPNTSER)=LCHKSER   !SERIAL # OF LAST TRANS
	CHKHEADER(CHKPNTBAL)=P(LSTCMD)
	CHKHEADER(CHKPNTTYP)=CHKPNTLTO
	CHKHEADER(CHKPNTDAY)=DAYCDC
	CALL WRITEQW(CFDB,1,CHKHEADER,ST)
	IF(ST.NE.0) THEN
	  CALL CHKMES(5,SFNAMES(1,SFIL),ST,1)
	  GOTO 9000
	ENDIF
	CALL CHKMES(6,SFNAMES(1,SFIL),0,0)
9000	CONTINUE
	CALL CLOSEQFIL(FDB)
	CALL CLOSEQFIL(CFDB)
	LCHKPNT=0
	RETURN
	END
