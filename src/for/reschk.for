C
C SUBROUTINE RESCHK
C
C RESCHK.FOR
C
C V23 01-JAN-2010 FJG ePASSIVE
C V22 05-JAN-2001 CS  PASCOM added.
C V21 29-NOV-2000 UXN TGLCOM ADDED.
C V20 29-SEP-2000 UXN OPSTXT() added.
C V19 05-JUN-2000 OXK SSOCOM added.
C V18 10-FEB-2000 UXN LSTOVR as a local variable removed. LTLSTOVR added.
C V17 26-NOV-1999 OXK TSPCOM added.
C V16 13-OCT-1999 RXK World Tour added.
C V15 13-MAY-1999 UXN SUPER TRIPLE ADDED.
C V14 18-DEC-1996 HXK Update from TEBE project (MXP,WXW,PXN,MJF)
C V13 28-NOV-1996 WXW Telebetting startup, changes MP/PXN/WXW.
C                     Duplex fixes.
C V12 03-JUL-1996 HXK Fixes for X.25/SP3 batch, phase 2
C V11 17-APR-1996 HXK Release of Finland for X.25, Telephone Betting, 
C                     Instant Pass Thru Phase 1
C V10 10-NOV-1995 HXK Further changes for Double, Couple
C V09 05-MAY-1995 HXK V5 entered into database again!!!!
C V08 22-FEB-1995 HXK TWAS BRILLIG AND THE BOROGOVES DID
C V07 15-OCT-1994 HXK Adding /developing Bingo (15.Oct.94)
C V06 12-OCT-1993 GXA Restore commons in same order as they are saved.
C V05 16-JUN-1993 SXH Added PPPCOM, V65COM, S234COM and SCNCOM
C V04 21-JAN-1993 DAB Initial Release
C                     Based on Netherlands Bible, 12/92, and Comm 1/93 update
C                     DEC Baseline
C V03 26-FEB-1996 wsm Added restoration of MSGCOM, included MSGCOM.DEF,
C                     removed GLOBAL.DEF.
C V02 07-OCT-1991 MTK INITAL RELEASE FOR NETHERLANDS
C V01 01-AUG-1990 XXX RELEASED FOR VAX
C
C
C SUBROUTINE TO RESTORE SYSTEM COMMONS FROM
C CHECKPOINT FILES.
C
C
C CALLING SEQUENCE:
C     CALL RESCHK(DATE,CERR)
C
C INPUT
C     DATE  - CURRENT CDC DATE
C
C OUTPUT
C     CERR  - ERROR RETURN (0 -NO ERROR, 1 - RESTORE ERROR)
C
C
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 2000 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW/EXT
	SUBROUTINE RESCHK(DATE,LSTSER,CERR)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'

	INCLUDE 'INCLIB:GLOBAL.DEF'
C***	INCLUDE 'INCLIB:MSGCOM.DEF'

	INCLUDE 'INCLIB:LTOCOM.DEF'
	INCLUDE 'INCLIB:SPTCOM.DEF'
	INCLUDE 'INCLIB:TGLCOM.DEF'
	INCLUDE 'INCLIB:KIKCOM.DEF'
C	INCLUDE 'INCLIB:NBRCOM.DEF'
	INCLUDE 'INCLIB:AGTCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
C====== INCLUDE 'INCLIB:WITCOM.DEF'
C====== INCLUDE 'INCLIB:SCRCOM.DEF'
C====== INCLUDE 'INCLIB:TSLCOM.DEF'
C====== INCLUDE 'INCLIB:SLOCOM.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:DESNET.DEF'
	INCLUDE 'INCLIB:CHKPNT.DEF'
C	INCLUDE 'INCLIB:POLCOM.DEF'
	INCLUDE 'INCLIB:POOLLTO.DEF'
        INCLUDE 'INCLIB:LTOPOL.DEF'
C====== INCLUDE 'INCLIB:BNGCOM.DEF'
C====== INCLUDE 'INCLIB:DBLCOM.DEF'
C====== INCLUDE 'INCLIB:CPLCOM.DEF'
C====== INCLUDE 'INCLIB:TRPCOM.DEF'
C====== INCLUDE 'INCLIB:TROCOM.DEF'
C====== INCLUDE 'INCLIB:SSCCOM.DEF'
C====== INCLUDE 'INCLIB:SSPCOM.DEF'
C====== INCLUDE 'INCLIB:STACOM.DEF'
C====== INCLUDE 'INCLIB:STRCOM.DEF'
C====== INCLUDE 'INCLIB:STROCOM.DEF'
C====== INCLUDE 'INCLIB:HASHMEM.DEF'
C====== INCLUDE 'INCLIB:SSOCOM.DEF'
        INCLUDE 'INCLIB:PASCOM.DEF'

        ! arguments
	INTEGER*4  DATE                        !
	INTEGER*4  LSTSER                      !
	INTEGER*4  CERR                        !

        ! variables
	INTEGER*4  FDB(7)                      !
	INTEGER*4  FDB1(7)                     !
	INTEGER*4  CHKFILES(5)                 !
	INTEGER*4  TRCADR                      !
	INTEGER*4  PAGENO                      !
	INTEGER*4  FIL1REC                     !
	INTEGER*4  LENGTH                      !
	INTEGER*4  BLOCK                       !
	INTEGER*4  TYPE                        !
	INTEGER*4  POOLSER                     !
	INTEGER*4  NOCHECK0                    !
	INTEGER*4  REC                         !
	INTEGER*4  POOLFILE                    !
	INTEGER*4  SER                         !
	INTEGER*4  ST                          !
	INTEGER*4  FILE                        !
	INTEGER*4  I                           !
	INTEGER*4  HIGHSER                     !
	INTEGER*4  COMMONFILE                  !
	INTEGER*4  COMMONSER                   !
	CHARACTER*60 PRMPT
C
	INTEGER*4   CHKTAB64(64,CNTSEC+SCMSEC+DAYSEC)
	INTEGER*4   CHKTAB(2048,CONCSB)         !
	EQUIVALENCE(CHKTAB(1,1),CHKTAB64(1,1))
C
	COMMON /CHKTAB/CHKTAB
C
	DATA REC/0/
	DATA CHKFILES/CP0,CP1,CP2,CP3,CP4/

	COMMON /NOCHECK0/ NOCHECK0
C
	NOCHECK0 = -1
C
C     THERE ARE TWO CHECKPOINT PHASES. LOTTO POOLS GO TO ONE PHASE
C     AND ALL OTHER INFORMATION GOES TO ANOTHER PHASE
C     PROGRAM WILL LOOK FOR LAST "BALANCED" CHECKPOINT WITH
C     POOL INFORMATION AND LAST CHECKPOINT WITH OTHER (COMMON)
C     INFORMATION. IF THERE ARE NO LOTTO POOLS ACTIVE P(PPOOLACT)
C     SHOULD BE SET TO 1
C
	CERR       =-1
	POOLSER    = 0
	POOLFILE   = 0
	COMMONSER  = 0
	COMMONFILE = 0
	HIGHSER    = LSTSER
C
	IF(LSTSER.EQ.0) HIGHSER=999999999
	IF(LSTSER.NE.0) LCHKSTOP=LSUSPPOL       !SUSPEND POOL & OVRPRO
C
C
	DO 10 I = 1, CHKTOT+1
	    CALL USRCLOSQ1(3)
	    FILE=CHKFILES(I)
	    CALL OPENQW(3,SFNAMES(1,FILE),4,0,0,ST)
	    IF(ST.NE.0) THEN
	        CALL FILERR(SFNAMES(1,FILE),1,ST,0)
	        GOTO 10
	    ENDIF
C
C   RESTART FROM LATEST CHECKPOINT FILE
C
	    REC=1
	    CALL IOQINIT(FDB,3,CHKSEC*256)
	    CALL READQW(FDB,REC,CHKHEADER,ST)
	    IF(ST.NE.0) THEN
	        CALL FILERR(SFNAMES(1,FILE),2,ST,REC)
	        GOTO 10
	    ENDIF
	    IF(DATE.NE.CHKHEADER(CHKPNTDAY)) GOTO 10
C
C   DETERMINE LATEST FILE
C
	    IF(I.EQ.1) THEN
	        COMMONSER  = CHKHEADER(CHKPNTSER)
	        COMMONFILE = FILE
	        POOLSER    = CHKHEADER(CHKPNTSER)
	        POOLFILE   = FILE
	    ELSE
	        SER  = CHKHEADER(CHKPNTSER)
	        TYPE = CHKHEADER(CHKPNTTYP)
	        IF(TYPE.NE.CHKPNTREG) THEN
	            IF(SER.LE.CHKHEADER(CHKPNTBAL)) THEN
	                IF(POOLSER.LT.SER.AND.SER.LT.HIGHSER) THEN
	                    POOLFILE = FILE
	                    POOLSER  = SER
	                ENDIF
	            ENDIF
	        ELSE
	            IF(SER.LE.CHKHEADER(CHKPNTBAL)) THEN
	                IF(COMMONSER.LT.SER.AND.SER.LT.HIGHSER) THEN
	                    COMMONFILE = FILE
	                    COMMONSER  = SER
	                ENDIF
	            ENDIF
	        ENDIF
	    ENDIF
10	CONTINUE
	
        IF(COMMONFILE.EQ.0.OR.
     *	  (P(POOLACT).EQ.0.AND.POOLFILE.EQ.0)) THEN
	    WRITE(PRMPT,920) DAYCDC
	    CALL OPSTXT(PRMPT)
	    CALL USRCLOSQ1(     3)
	    RETURN
	ENDIF
C
C IF ONE OF THE CHECKPOINT FILES IS CHECKPOINT 0
C START POOLS AND CHECKPOINT FILES FROM CHECKPOINT 0
C
	IF (COMMONFILE.EQ.CP0.OR.POOLFILE.EQ.CP0) THEN
	    COMMONFILE = CP0
	    POOLFILE   = CP0
	    POOLSER    = MIN0(POOLSER,COMMONSER)
	    COMMONSER  = POOLSER
	ENDIF
C
C RESTORE GAME COMMONS
C
	FILE=COMMONFILE
	CALL USRCLOSQ1(     3)

	CALL OPENQW(3,SFNAMES(1,FILE),4,0,0,ST)
	CALL IOQINIT(FDB,3,CHKSEC*256)
	IF(ST.NE.0) THEN
	    CALL FILERR(SFNAMES(1,FILE),1,ST,0)
	    RETURN
	ENDIF
C
C
	REC=2
D	CALL LIB$INIT_TIMER()
	BLOCK=(CHKSEC*256/SECSIZE)+1
C
C RESTORE CONCOM
C
C***	BLOCK=BLOCK+(CHKSEC*256/SECSIZE)
	LENGTH=CONCSB*CHKSEC*256
	IF(LSTSER.EQ.0) THEN
	  CALL READQIO(FDB,BLOCK,CONBLK(1,1),LENGTH,ST)
	ELSE
	  CALL READQIO(FDB,BLOCK,CHKTAB(1,1),LENGTH,ST)
	ENDIF
	IF(ST.NE.0) THEN
	    CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
	    CALL USRCLOSQ1(     3)
	    RETURN
	ENDIF
C
C RESTORE AGTCOM
C
	BLOCK  = BLOCK + LENGTH/SECSIZE
	LENGTH = AGTCSB*CHKSEC*256
	CALL READQIO(FDB,BLOCK,AGTBLK,LENGTH,ST)
	IF(ST.NE.0) THEN
	  CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
	  CALL USRCLOSQ1(     3)
	  RETURN
	ENDIF
C
C RESTORE SLOCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=SLOCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,SLOBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE LTOCOM
C
	BLOCK=BLOCK+LENGTH/SECSIZE
	LENGTH=LTOCSB*CHKSEC*256
	CALL READQIO(FDB,BLOCK,LTOBLK,LENGTH,ST)
	IF(ST.NE.0) THEN
	  CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
	  CALL USRCLOSQ1(     3)
	  RETURN
	ENDIF
C
C RESTORE SPTCOM
C
	BLOCK=BLOCK+LENGTH/SECSIZE
	LENGTH=SPTCSB*CHKSEC*256
	CALL READQIO(FDB,BLOCK,SPTBLK,LENGTH,ST)
	IF(ST.NE.0) THEN
	  CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
	  CALL USRCLOSQ1(     3)
	  RETURN
	ENDIF
C
C RESTORE TGLCOM
C
	BLOCK=BLOCK+LENGTH/SECSIZE
	LENGTH=TGLCSB*CHKSEC*256
	CALL READQIO(FDB,BLOCK,TGLBLK,LENGTH,ST)
	IF(ST.NE.0) THEN
	  CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
	  CALL USRCLOSQ1(     3)
	  RETURN
	ENDIF
C
C RESTORE KIKCOM
C
	BLOCK=BLOCK+LENGTH/SECSIZE
	LENGTH=KIKCSB*CHKSEC*256
	CALL READQIO(FDB,BLOCK,KIKBLK,LENGTH,ST)
	IF(ST.NE.0) THEN
	  CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
	  CALL USRCLOSQ1(     3)
	  RETURN
	ENDIF
C
C RESTORE NBRCOM
C
C	BLOCK=BLOCK+LENGTH/SECSIZE
C	LENGTH=NBRCSB*CHKSEC*256
C	CALL READQIO(FDB,BLOCK,NBRBLK,LENGTH,ST)
C	IF(ST.NE.0) THEN
C	  CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C	  CALL USRCLOSQ1(     3)
C	  RETURN
C	ENDIF
C
C RESTORE SCRCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=SCRCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,SCRBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE WITCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=WITCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,WITBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE TSLCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=TSLCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,TSLBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE BNGCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=BNGCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,BNGBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE DBLCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=DBLCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,DBLBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE CPLCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=CPLCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,CPLBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE SSCCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=SSCCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,SSCBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE SSPCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=SSPCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,SSPBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE TRPCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=TRPCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,TRPBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE TROCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=TROCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,TROBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE STACOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=STACSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,STABLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE STRCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=STRCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,STRBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE STROCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=STROCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,STROBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C
C RESTORE TSPCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=TSPCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,TSPBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE SSOCOM
C
C       BLOCK=BLOCK+LENGTH/SECSIZE
C       LENGTH=SSOCOMCSB*CHKSEC*256
C       CALL READQIO(FDB,BLOCK,SSOCOMBLK,LENGTH,ST)
C       IF(ST.NE.0) THEN
C         CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C         CALL USRCLOSQ1(     3)
C         RETURN
C       ENDIF
C
C RESTORE PASCOM
C
        BLOCK=BLOCK+LENGTH/SECSIZE
        LENGTH=PASCSB*CHKSEC*256
        CALL READQIO(FDB,BLOCK,PASBLK,LENGTH,ST)
        IF(ST.NE.0) THEN
          CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
          CALL USRCLOSQ1(     3)
          RETURN
        ENDIF
C
C RESTORE POLCOM
C
C	BLOCK=BLOCK+LENGTH/SECSIZE
C	LENGTH=POLCSB*CHKSEC*256
C	CALL READQIO(FDB,BLOCK,POLBLK,LENGTH,ST)
C	IF(ST.NE.0) THEN
C	  CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C	  CALL USRCLOSQ1(     3)
C	  RETURN
C	ENDIF
C
C RESTORE MSGCOM
C
C        BLOCK=BLOCK+LENGTH/SECSIZE
C        LENGTH=MSGCSB*CHKSEC*256
C        CALL READQIO(FDB,BLOCK,MSGBLK,LENGTH,ST)
C        IF(ST.NE.0) THEN
C          CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
C          CALL USRCLOSQ1(     3)
C          RETURN
C        ENDIF
         BLOCK=BLOCK+LENGTH/SECSIZE
D	 CALL LIB$SHOW_TIMER()
D	 TYPE*,IAM(),' reschk 1'
C
C
C SELECTIVE CLEAR OF CONCOM
C
	IF(LSTSER.EQ.0) THEN
	    P(CMDFRZ)=0
	    P(CMDFLU)=0
	    P(LOGFLG)=0
	    P(CHKFLG)=0
	    P(KIKFLG)=0
	    DO 100 I=1,MAXTSK
	        ACTTSK(I)=0
100	    CONTINUE
	ENDIF
C
C RESTORE LOTTO POOLS
C
	IF(P(POOLACT).EQ.0) THEN
	  FILE=POOLFILE
	  IF(FILE.NE.CP0) THEN
	    CALL USRCLOSQ1(     3)
	    CALL OPENQW(3,SFNAMES(1,FILE),4,0,0,ST)
	    CALL IOQINIT(FDB,3,CHKSEC*256)
	    IF(ST.NE.0) THEN
	      CALL FILERR(SFNAMES(1,FILE),1,ST,0)
	      CALL USRCLOSQ1(     3)
	      RETURN
	    ENDIF
	    BLOCK=CHKSEC*256/SECSIZE+1
	  ENDIF
C
C	  IF POOLS ARE RAM-BASED PUT THE DATA IN MEMORY ALSO
C
          IF(P(LTOPOL_RAM) .EQ. LTOPOL_FIL_VALUE) THEN
D            TYPE *,IAM(), ' POOLS ARE FILE_BASED'
          ELSE
D            TYPE *,IAM(), ' POOLS ARE RAM_BASED'
          ENDIF
C
	  CALL OPENQW(4,SFNAMES(1,LPR),4,0,0,ST)
	  CALL IOQINIT(FDB1,4,CHKSEC*256)
	  IF(ST.NE.0) THEN
	    CALL FILERR(SFNAMES(1,LPR),1,ST,0)
	    CALL USRCLOSQ1(     3)
	    CALL USRCLOSQ1(     4)
	    RETURN
	  ENDIF

	  FIL1REC=1
	  LENGTH=PAGESIZE*4
150	  CONTINUE

	  IF(LSTSER.NE.0.AND.LCHKSTOP.NE.LSUSPDON) THEN
	    CALL XWAIT(20,1,ST)
	    GOTO 150
	  ENDIF
D	  CALL LIB$INIT_TIMER()
	  DO 160 PAGENO = 1, LTNUMPAG
	      CALL READQIO(FDB,BLOCK,LTPAGE,LENGTH,ST)
	      IF(ST.NE.0) THEN
	          CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
	          CALL USRCLOSQ1(     3)
	          CALL USRCLOSQ1(     4)
	          RETURN
	      ENDIF

	      CALL WRITEQIO(FDB1,FIL1REC,LTPAGE,LENGTH,ST)
	      IF(ST.NE.0) THEN
	          CALL FILERR(SFNAMES(1,LPR),3,ST,BLOCK)
	          CALL USRCLOSQ1(     3)
	          CALL USRCLOSQ1(     4)
	          RETURN
	      ENDIF
C
              IF(P(LTOPOL_RAM)  .NE. LTOPOL_FIL_VALUE) THEN
                  CALL FASTMOV(LTPAGE,LTOPOL_SPACE((PAGENO-1)*PAGESIZE+1),
     1                         PAGESIZE)
              ENDIF
C
	      FIL1REC = FIL1REC + LENGTH/SECSIZE
	      BLOCK   = BLOCK+LENGTH/SECSIZE
160	  CONTINUE
D	  CALL LIB$SHOW_TIMER()
D	  TYPE*,IAM(),' reschk 2'
C
C     READ OVERFLOWS AND GAME DATA
C
D	  CALL LIB$INIT_TIMER()
	  CALL READQIO(FDB,BLOCK,LSAVOVR,LENGTH,ST) !AND PUT IN COMMON
	  IF(ST.NE.0) THEN
	      CALL FILERR(SFNAMES(1,FILE),2,ST,BLOCK)
	      CALL USRCLOSQ1(     3)
	      CALL USRCLOSQ1(     4)
	      RETURN
	  ENDIF
C
	  CALL FASTMOV(LSAVOVR,LTOVR,MAXOVR*2*LTNUMGAMES)
	  CALL FASTMOV(LTSAVLST,LTLSTOVR,LTNUMGAMES)
	  OVRBLK=LSAVBLK
	  CALL FASTMOV(SAVLTPOOL_TOT,LTPOOL_TOT,LTNUMGAMES)
D	  CALL LIB$SHOW_TIMER()
D	  TYPE*,IAM(),' reschk 3'
C
	  LCHKFIL=POOLFILE-1
	  LCHKSER=POOLSER
	  LCHKSTOP=0
	  CALL USRCLOSQ1(     4)
	ELSE
	   LCHKSTOP=0
	   POOLSER=COMMONSER
	   LCHKSER=POOLSER
	   LCHKFIL=POOLFILE-1
	ENDIF
C
C SET STARTING SERIAL NRS FOR POOLS AND COMMONS REPROCESSING
C
	P(COMSER) = COMMONSER
	P(POLSER) = POOLSER
	NXTSER    = MIN0(P(COMSER),P(POLSER))
	CERR=0
	IF(LSTSER.GT.0)THEN
	    CALL NOTIFY(TRCADR,NOTLOCCOM,COMMONFILE,NXTSER)
	    CALL NOTIFY(TRCADR,NOTLOCPOL,POOLFILE,0)
	ELSE
	   WRITE(PRMPT,900) (SFNAMES(I,COMMONFILE),I=1,5)
	   CALL OPSTXT(PRMPT)
	   IF(P(POOLACT).EQ.0) THEN 
               WRITE(PRMPT,910) (SFNAMES(I,POOLFILE),I=1,5)
	       CALL OPSTXT(PRMPT)
	   ENDIF
	ENDIF
	CALL USRCLOSQ1(3)
C
C SET RESTART FROM CHECKPOINT FLAG
C
	P(RCHECK) = 1
	CERR      = 0

	RETURN
C
900	FORMAT('Game commons restored from ',5A4)
910	FORMAT('Pool commons restored from ',5A4)
920	FORMAT('No valid checkpoint for day ',I6,' found ')
	END
