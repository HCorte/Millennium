C *** PROGRAM MSCMGR ***
C
C V04 20-MAR-95 SCD CHECK X2X_GAME_STATE SO WE WILL GRACEFULLY DIE UNDER
C		    PX2X
C V03 23-DEC-92 RRB RESTRUCTURE PROCESSING TO AVOID RECURSIVE
C                   ENTRY TO QUEUE MANAGEMENT. UPGRADE FOR NEW MSC REV.
C                   REMOVED MSCPRO.EXE NOW PART OF MSCMGR.
C V02 27-NOV-91 RRB ABORT MSCPRO IF FATAL ERROR
C V01 22-JAN-91 RRB VAX INITIAL RELEASE
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode Island,
C and contains confidential and trade secret information. It may not be
C transferred from the custody or control of GTECH except as authorized in
C writing by an officer of GTECH. Neither this item nor the information it
C contains may be used, transferred, reproduced, published, or disclosed,
C in whole or in part, and directly or indirectly, except as expressly
C authorized by an officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose:
C	THIS TASK ESTABLISHES AN INTERFACE TO THE TELENEX
C	MATRIX SWITCH CONTROLLER VIA A RS232 ASCII CONNECTION.
C
C	IT CONTROLS LOCAL AND NETWORK COMMUNICATIONS PORT CONFIGURATION
C	IN THE EVENT OF PORT FAILURES.
C
C	REFER TO :	MSC_MESTRAP.FOR
C			MSC_TIMTRAP.FOR
C
C	SEE ALSO:	MSC_RCVBUF.FOR
C			MSC_SNDBUF.FOR
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM MSCMGR
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:MSCCOM.DEF'
	INCLUDE 'INCLIB:MSCEVN.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:DESNET.DEF'
C
	INCLUDE '($IODEF)'
        INCLUDE '($SSDEF)'
        INCLUDE '($SYSSRVNAM)'
C
	INTEGER*4   I, BUF1, BUF2, FLAG, REPLY
	INTEGER*4   MSCCSW                    !COMMON SIZE IN WORDS
	INTEGER*4   NEXT_ATTEMPT              !WAIT INTERVAL FOR CONNECT
C                                              !TO DEC SERVER
	INTEGER*4   ST, STATUS, FLGSTS
C
	INTEGER*4 NOFTLSIG
	EXTERNAL  NOFTLSIG
C
	INTEGER*4 MSC_EXEC
	EXTERNAL  MSC_EXEC
C
	CALL LIB$ESTABLISH(NOFTLSIG)
C
	CALL COPYRITE
	CALL SNIF_AND_WRKSET
C
C CLEAR MSCCOM
C
C %LOC() RETURNS BYTE ADDRESS OF WORD
C
	MSCCSW=(((%LOC(MSC_LAST)+4)-%LOC(MSC_FIRST))+3)/4
	CALL FASTSET(0,MSC_FIRST,MSCCSW)
C
C SET INITIAL VALUES!
C
C FORCE MSC CONFIGURATION TO BE CHECKED 
C AND SET MSC STATUS TO CONNECT REQUEST.
C
	MSCSTS = MSC_REQ_ONLINE
	MSC_SETUP_REQ_CNT = MSC_SETUP_REQ_LIMIT + 1
	MSC_AUTO_SWITCH = AUTO_SWITCH_DISABLED
	MSC_WRITE_IN_PROG = .FALSE.
	MSC_READ_IN_PROG = .FALSE.
	MSC_CONF_FLAG = CONF_VERIFIED
	NEXT_ATTEMPT = MAX_CONNECTION_WAIT !SET DEFAULT SERVER CONNECT RETRY
        CALL FASTMOV(X2XPL_STATE,MSC_SAVE_PORT_STATE,X2X_LOCAL_PORTS)
C
C SET UP TIMER EVENT FLAGS
C
	DO 20 I = 1,MSC_NUM_TIMTRAPS
	   MSC_TIMER_FLAGS(I) = I
20	CONTINUE
C
C CREATE THE COMMON EVENT FLAG CLUSTER.
C
        STATUS=SYS$ASCEFC(%VAL(MSC_EVENTS),MSC_EVENT_NAME,0,0)
        IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
C
C CREATE MASK OF ACKNOWLEDGEMENT EVENTS ON WHICH TO TRAP
C
        MSC_ACK_MASK = IBSET(MSC_ACK_MASK,MOD(MSC_ACK_FLAG,
     *                                          MSC_EVENTS))
        MSC_ACK_MASK = IBSET(MSC_ACK_MASK,MOD(MSC_NAK_FLAG,
     *                                          MSC_EVENTS))
        MSC_ACK_MASK = IBSET(MSC_ACK_MASK,MOD(MSC_TOUT_FLAG,
     *                                          MSC_EVENTS))
C
C CLEAR EVENT FLAGS.
C
	DO 100 FLAG = MSC_EVENTS,MSC_EVENTS+MSC_NUM_TRAPS-1
	   STATUS=SYS$CLREF(%VAL(FLAG))
100	CONTINUE
C
C SETUP THE MAILBOX FOR INTERTASK MESSAGES.
C IF MAILBOX DOES NOT EXIST, CREATE IT.
C
        STATUS=SYS$ASSIGN(MSC_MESNAME,MSC_MESCHANNEL,,)
        IF(.NOT.STATUS) THEN
          STATUS=SYS$CREMBX(%VAL(1),MSC_MESCHANNEL,,,
     *                      %VAL('FD00'X),,MSC_MESNAME)
          IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
        ENDIF
C
C DEFINE QUEUES
C
	CALL FASTSET(0,MSCFREE,MSCBNUM+2)
	CALL FASTSET(0,MSCEXEC,MSCBNUM+2)
	CALL DEFLST(MSCFREE,MSCBNUM)
	CALL DEFLST(MSCEXEC,MSCBNUM)
C
C INIT BUFFERS AND SET UP FREE LIST
C
	DO 200 BUF1=1,MSCBNUM
	   CALL FASTSET(0,MSCBUF(1,BUF1),MSCBLEN)
	   BUF2 = BUF1
	   CALL MSCRELB(BUF2)
200	CONTINUE
C
C READ CONFIGURATION INFORMATION FROM MSCCTRL.FIL
C
	CALL GETCTRL(REPLY)
	IF(REPLY.NE.0) THEN
	   TYPE*,IAM(),'Error establishing configuration information.'
	   TYPE*,IAM(),'Bad or missing configuration file.'
	   CALL GSTOP(GEXIT_FATAL)
	ENDIF
C
C WAIT FOR X2X TO COME UP
C
300     CONTINUE
	IF(X2X_GAME_STATE.EQ.X2X_GAMES_SHUTDOWN) GOTO 1000		!V04
	IF(X2X_GAME_STATE.NE.X2X_GAMES_UP) THEN
	  CALL XWAIT(1,2,ST)     !WAIT SOME
	  GOTO 300
 	ENDIF
C
C OPEN SERVER CONNECTION
C
        CALL MSCOPEN(LAT_NAME(NODEID), LAT_CHANNEL, ST)
C
C  IF UNABLE TO OPEN CONNECTION, INCREMENT WAIT TIME AFTER EACH 
C  UNSUCCESSFULL ATTEMPT. (UNTIL WAIT MAX)
C
        IF(ST.NE.0) THEN
           CALL OPS('ERROR ESTABLISHING LINK WITH SERVER ',ST,ST)
	   NEXT_ATTEMPT = NEXT_ATTEMPT + 10
	   IF(NEXT_ATTEMPT.GE.MAX_CONNECTION_WAIT) THEN
	      NEXT_ATTEMPT=MAX_CONNECTION_WAIT
	   ENDIF
           CALL XWAIT(NEXT_ATTEMPT,2,ST)
           GOTO 300
        ENDIF
        CALL OPS('LINK WITH SERVER ESTABLISHED',0,0)
        MSC_CONNECT_FLAG = MSC_OPENED
C
C ARM MESSAGE AND TIMER TRAPS TRAPS
C
        CALL MSC_START_MESS                        ! MESSAGE TRAP
        DO 400 I = 1,MSC_NUM_TIMTRAPS
           CALL MSC_START_TIME(I)                  ! TIMER TRAP(S)
           CALL XWAIT(1,2,ST)
400     CONTINUE
C
C PLACE TASK IN TRAP WAIT STATE. NOTE: TASK WILL STILL
C SERVICE AST TRAPS WHILE WAITING FOR TASK EVENT FLAG TO BE SET.
C
C ====================== MAIN LOOP =====================
C
1000    CONTINUE
	IF(X2X_GAME_STATE.EQ.X2X_GAMES_SHUTDOWN) THEN
	  GOTO 8000
 	ENDIF
C
        STATUS=SYS$WAITFR(%VAL(MSC_EVENTS),%VAL(MSC_EXEC_FLAG))
        IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
C
D	TYPE*,IAM(),'MSCMGR HATH AWAKEN'
        STATUS=SYS$READEF(%VAL(MSC_EXEC_FLAG),FLGSTS)
        IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
C
C TRAP TO MSC_EXEC
C
        IF(STATUS.EQ.SS$_WASSET) THEN
          STATUS=SYS$CLREF(%VAL(MSC_EXEC_FLAG))
          IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
          STATUS=SYS$DCLAST(MSC_EXEC,%VAL(0),) !TRAP TO MSC TSK TRAP
          IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
        ELSE IF (STATUS.NE.SS$_WASCLR) THEN
          TYPE *,IAM(),'MSCMGR: INVALID TASK EVENT FLAG'
        ENDIF
        GOTO 1000
C
C PLACE SHUTDOWN HOUSEKEEPING HERE!!!!!!!!!!!
C
8000	CONTINUE
	CALL MSCCLOSE(LAT_CHANNEL,ST)
	CALL GSTOP(GEXIT_SUCCESS)
	END
