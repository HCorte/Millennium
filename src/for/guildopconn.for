C GUIDOPCONN.FOR
C
C V02 13-NOV-2000 UXN GUI prefix added.
C V01 16-JUN-1993 MP  INITIAL RELEASE FOR VAX (Produced From TCPASST).
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991-1993 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C		This routine allows passive connections on as many channels
C		as specified by GUI_MAX_CONN parameter.
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GUITCPPDOPCONN
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:GUIMCOM.DEF'
	INCLUDE 'INCLIB:GUILCOM.DEF'
	INCLUDE 'INCLIB:INETDEF.DEF'
C
        INCLUDE '($IODEF)'
        INCLUDE '($SSDEF)'
        INCLUDE '($SYSSRVNAM)'
C
	EXTERNAL  GUITCPPCOIOCOMP
C
	INTEGER*4 STATUS	!STATUS RETURNED FROM QIO
	INTEGER*4 IFUNC	        !FUNCTION CODE
C
C SOCKET PARAMETERS.
C
	INTEGER*2   SCK_PARM(2)			!SOCKET PARAMETERS
	BYTE        BSCK_PARM(4)		!BYTE PARAMETERS
	EQUIVALENCE (SCK_PARM,BSCK_PARM)
C
	INTEGER*4   GUITCPPNETBYT
	INTEGER*4   NUMCONC
	INTEGER*4   DESCRIP_P3(2)
C
	INTEGER*4   RETLEN			!RETURNED BUFFER LENGTH
	INTEGER*4   LOCPRT			!LOCAL PORT NUMBER
	INTEGER*4   CONN_INX			! CONNECTION INDEX
C
        RECORD /SOCKADR/    LOCAL_HOST
C
C STRUCTURE USED TO PASS PARAMETERS TO QIO CALLS (ITEMLIST 2).
C
        STRUCTURE /ITLST_1/
          INTEGER*4 LGTH
          INTEGER*4 RMT_ADRS
          INTEGER*4 RETLTH
        END STRUCTURE
        RECORD /ITLST_1/    RHST_ADRS
C
C STRUCTURE USED TO PASS PARAMETERS 5 TO SETMODE
C
        STRUCTURE /P5STR/
          INTEGER*2 LEN
          INTEGER*2 OPT
          INTEGER*4 ADR
        END STRUCTURE
        RECORD /P5STR/	  P5PARM
C
C socket options structure
C
	INTEGER*4	SOCK_OPTIONS
	PARAMETER	(SOCK_OPTIONS=6)
	STRUCTURE /ITLST_2/
          INTEGER*2 LEN
          INTEGER*2 OPT
          INTEGER*4 ADR
	END STRUCTURE
	RECORD /ITLST_2/ ITLST_2_SAMPLE
	RECORD /ITLST_2/ P5LST(SOCK_OPTIONS)
C
C
	INTEGER*4 NO_DELY
	INTEGER*4 RE_USE
	INTEGER*4 KEEP_ALIVE
	INTEGER*4 IND
C
        RECORD /GUI_IOSSTRUCT/ LOCAL_IOSB
	INTEGER*4 CONN_WAIT	!WAIT TIME
	INTEGER*4 CONNS_POSTED	!connections open
C
	INTEGER*4   BLANK
	DATA	    BLANK/'    '/
C
C GET A CHANNEL NUMBER ASSIGNED TO THE DEVICE.
C
	IF(GUI_CHAN_SETUP.NE.-1) GOTO 100
	STATUS=SYS$ASSIGN('UCX$DEVICE',GUI_CHAN_SETUP,,)
	IF(.NOT.STATUS) THEN
	    GUI_CHAN_SETUP=-1
	    CALL FASTSET(BLANK,GUI_MES_BUF,33)
	    WRITE(GUI_MES_CBUF,9000) STATUS
9000	    FORMAT('GUILDOPCONN: Error ASSIGNING setup chan to UCX  ',I8)
	    CALL WRITEBRK(GUI_MES_CBUF)
	    GOTO 8000
	ENDIF
C
C SETUP PARAMETER 1.
C
	SCK_PARM(1)= INET$C_TCP
	SCK_PARM(2)= INET_PROTYP$C_STREAM
C
C ITEM LIST FOR LOCAL IP ADDRESS.
C
	IF(GUI_PORT.GT.999) THEN
	  LOCPRT=GUI_PORT
	ELSE
	  LOCPRT=GUITCP_LOCAL_PORT_DEFAULT
	  GUI_PORT=GUITCP_LOCAL_PORT_DEFAULT
	ENDIF
C
	LOCAL_HOST.INET_FAMILY= INET$C_AF_INET
	LOCAL_HOST.INET_PORT=GUITCPPNETBYT(LOCPRT)
	LOCAL_HOST.ADRS = INET$C_INADDR_ANY
	LOCAL_HOST.BLKB=' '
	DESCRIP_P3(1)=16
	DESCRIP_P3(2)=%LOC(LOCAL_HOST)
C
C socket option parameters
C
	IND = 1
	P5LST(IND).LEN = 4
	P5LST(IND).OPT = UCX$C_TCP_NODELAY
	P5LST(IND).ADR = %LOC(NO_DELY)
	NO_DELY   = 1
C
C buffer size has to be determined from throughput and delivery time 
C requirements - additional test are needed
C
C***	IND = IND + 1
C***	P5LST(IND ).LEN = 4
C***	P5LST(IND ).OPT = UCX$C_RCVBUF
C***	P5LST(IND ).ADR = %LOC(RCV_SIZ)
C***	RCV_SIZ    = 2 * 4096
C
C***	IND = IND + 1
C***	P5LST(IND ).LEN = 4
C***	P5LST(IND ).OPT = UCX$C_SNDBUF
C***	P5LST(IND ).ADR = %LOC(SND_SIZ)
C***	SND_SIZ    = 2 * 4096
C
	IND = IND + 1
	P5LST(IND ).LEN = 4
	P5LST(IND ).OPT = UCX$M_REUSEADDR
	P5LST(IND ).ADR = %LOC(RE_USE)
	RE_USE     = 1
C
	IND = IND + 1
	P5LST(IND ).LEN = 4
	P5LST(IND ).OPT = UCX$M_KEEPALIVE
	P5LST(IND ).ADR = %LOC(KEEP_ALIVE)
C
C The following value together with UCX commands:
C SET PROTOCOL GUITCP /DROP_TIMER=6 and
C SET PROTOCOL GUITCP /PROBE_TIMER=1
C give the ability to detect the Ethernet cable disconnect
C

	KEEP_ALIVE = 6
C
C linger blocks CLOSE operation, so we do not use it
C
C***	IND = IND + 1
C***	P5LST(IND ).LEN = 8
C***	P5LST(IND ).OPT = UCX$M_LINGER
C***	P5LST(IND ).ADR = %LOC(LING_OPT)
C***	LING_OPT(1) = 0
C***	LING_OPT(2) = 0
C
C fill in the descriptor which points to the params
C
	P5PARM.LEN = SIZEOF(ITLST_2_SAMPLE) * IND
	P5PARM.OPT = UCX$C_SOCKOPT
	P5PARM.ADR = %LOC( P5LST )
C
C CREATE THE SOCKET.
C
	IFUNC=IO$_SETMODE
	STATUS=SYS$QIOW(,%VAL(GUI_CHAN_SETUP),
     *                   %VAL(IFUNC),
     *                   %REF(LOCAL_IOSB),
     *			 ,
     *			 ,
     *                   SCK_PARM,		   !P1
     *                   ,			   !P2
     *                   ,			   !P3
     *                   ,			   !P4
     *                   P5PARM,		   !P5
     *                   )			   !P6
	IF(.NOT.STATUS) THEN
	  CALL FASTSET(BLANK,GUI_MES_BUF,33)
	  WRITE(GUI_MES_CBUF,9010) STATUS
9010	  FORMAT('GUILDOPCONN: Error stating create socket ',I8)
	  CALL WRITEBRK(GUI_MES_CBUF)
	  IF(STATUS .NE. SS$_DUPLNAM) GOTO 7000
	ELSE IF(LOCAL_IOSB.STAT .NE. SS$_NORMAL) THEN
	  CALL FASTSET(BLANK,GUI_MES_BUF,33)
	  WRITE(GUI_MES_CBUF,9020) LOCAL_IOSB.STAT
9020	  FORMAT('GUILDOPCONN: Error completing create socket  ',I8)
	  CALL WRITEBRK(GUI_MES_CBUF)
	  IF(LOCAL_IOSB.STAT .NE. SS$_DUPLNAM) GOTO 7000
	ENDIF
C
	IF(GUI_DBG_UNIT.NE.0) THEN
D 	  TYPE *,IAM(),'GUILDOPCONN: socket created...'
	ENDIF
C
C BIND THE SOCKET.
C
	IFUNC=IO$_SETMODE
	NUMCONC=GUI_MAX_CONN
	STATUS=SYS$QIOW(,%VAL(GUI_CHAN_SETUP),
     *                   %VAL(IFUNC),
     *                   %REF(LOCAL_IOSB),
     *			 ,
     *			 ,
     *                   ,			   !P1
     *                   ,			   !P2
     *                   DESCRIP_P3,               !P3
     *                   %DESCR(NUMCONC),          !P4
     *                   ,)			   !P5, P6
	IF(.NOT.STATUS) THEN
	  CALL FASTSET(BLANK,GUI_MES_BUF,33)
	  WRITE(GUI_MES_CBUF,9030) STATUS
9030	  FORMAT('GUILDOPCONN: Error stating bind socket ',I8)
	  CALL WRITEBRK(GUI_MES_CBUF)
	  GOTO 7000
	ELSE IF(LOCAL_IOSB.STAT .NE. SS$_NORMAL) THEN
	  CALL FASTSET(BLANK,GUI_MES_BUF,33)
	  WRITE(GUI_MES_CBUF,9040) LOCAL_IOSB.STAT
9040	  FORMAT('GUILDOPCONN: Error completing bind socket  ',I8)
	  CALL WRITEBRK(GUI_MES_CBUF)
	  GOTO 7000
	ENDIF
C
	IF(GUI_DBG_UNIT.NE.0) THEN
D 	  TYPE *,IAM(),'GUILDOPCONN: socket created...'
	ENDIF
C
100	CONTINUE
C
C	Do all potential Connections
C
	CONNS_POSTED = 0
C
	DO 1000 CONN_INX=1, GUI_MAX_CONN
C
	  IF(GUI_CONN_STS(CONN_INX).NE.GUI_CONN_STS_DISCON) GOTO 1000
	  GUI_CONN_STS(CONN_INX)=GUI_CONN_STS_CONINP
C
	  GUI_CONN_LAST_MSN_IN(CONN_INX)= 0
	  GUI_CONN_LAST_MSN_OUT(CONN_INX)=0
	  GUI_CONN_LAST_TIME(CONN_INX)	= 0
	  GUI_READS(CONN_INX)		= 0
	  GUI_READERRS(CONN_INX)	= 0
	  GUI_READLERR(CONN_INX)	= 0
	  GUI_WRITES(CONN_INX)		= 0
	  GUI_WRITEERRS(CONN_INX)	= 0
	  GUI_WRITELERR(CONN_INX)	= 0
C
	  IF(GUI_CONN_CHAN(CONN_INX).EQ.-1) THEN
	    STATUS=SYS$ASSIGN('UCX$DEVICE',GUI_CONN_CHAN(CONN_INX),,)
	    IF(.NOT.STATUS) THEN
		GUI_CONN_CHAN(CONN_INX)=-1
		CALL FASTSET(BLANK,GUI_MES_BUF,33)
		WRITE(GUI_MES_CBUF,9100) STATUS
9100		FORMAT('GUILDOPCONN: Conn ',I3,
     *			' error ASSIGNING chan ',I8)
		CALL WRITEBRK(GUI_MES_CBUF)
		GOTO 800
	    ENDIF
	  ENDIF
C
C SETUP FOR REMOTE HOST ADDRESS.
C
	  RHST_ADRS.LGTH =16
	  RHST_ADRS.RMT_ADRS = %LOC(GUI_CONN_RHOST_ADD(1,CONN_INX))
	  RHST_ADRS.RETLTH = %LOC(GUI_CONN_RHOST_RETLEN(CONN_INX))
	  RETLEN=0
C
C ACCEPT A CONNECTION FROM A CLIENT.
C
	  IFUNC=IO$_ACCESS .OR. IO$M_ACCEPT
	  STATUS=SYS$QIO(,%VAL(GUI_CHAN_SETUP),
     *                   %VAL(IFUNC),
     *                   %REF(GUI_CONN_IOSB(CONN_INX)),
     *			 GUITCPPCOIOCOMP,
     *			 GUITCP_CONNECTIONS(CONN_INX),
     *                   ,                         !P1
     *                   ,			   !P2
     *                   RHST_ADRS,                !P3
     *                   GUI_CONN_CHAN(CONN_INX), !P4
     *                   ,)			   !P5 AND P6
	  IF(.NOT.STATUS) THEN
	    CALL FASTSET(BLANK,GUI_MES_BUF,33)
	    WRITE(GUI_MES_CBUF,9200) STATUS
9200	    FORMAT('GUILDOPCONN: Error starting ACCEPT connection ',I8)
	    CALL WRITEBRK(GUI_MES_CBUF)
	    GOTO 700
	  ENDIF
C
	  CONNS_POSTED = CONNS_POSTED + 1
C
	  IF(GUI_DBG_UNIT.NE.0) THEN
D	    TYPE *,IAM(),'PASSIVE CONNECTION',CONN_INX,' POSTED ON CHAN: ',
D     *		        GUI_CONN_CHAN(CONN_INX)
	  ENDIF
C
	  GOTO 1000
C
700	  CONTINUE
	  CALL GUITCPPDODASGN(GUI_CONN_CHAN(CONN_INX), CONN_INX)
C
800	  CONTINUE
	  GUI_CONN_STS(CONN_INX) = GUI_CONN_STS_DISCON
	  GUI_CONNERRS(CONN_INX) = GUI_CONNERRS(CONN_INX) + 1
	  GUI_CONNLERR(CONN_INX) = STATUS
C
C	  TRY TO CONNECT LATER
C
	  CONN_WAIT=GUI_CONN_WAIT
	  CALL GUITCPPSTARTTIME(GUITCP_TIME_PCON,CONN_WAIT)
C
1000	CONTINUE
C
	IF(CONNS_POSTED.GT.0) THEN
	  CALL FASTSET(BLANK,GUI_MES_BUF,33)
	  WRITE(GUI_MES_CBUF,9300) CONNS_POSTED
9300	  FORMAT('GUILDOPCONN: New connections posted: ',I3)
	  CALL WRITEBRK(GUI_MES_CBUF)
	ENDIF
C	
	GOTO 10000
C
C
7000	CONTINUE
	CALL GUITCPPDODASGN(GUI_CHAN_SETUP, 0)
C
8000	CONTINUE
C
C	Do all individual connections
C
	DO 8100 CONN_INX=1, GUI_MAX_CONN
	  CALL GUITCPPDODASGN(GUI_CONN_CHAN(CONN_INX), CONN_INX)
	  GUI_CONN_STS(CONN_INX) = GUI_CONN_STS_DISCON
	  GUI_CONNERRS(CONN_INX) = GUI_CONNERRS(CONN_INX) + 1
	  IF(.NOT.STATUS) THEN
	    GUI_CONNLERR(CONN_INX) = STATUS
	  ELSE
	    GUI_CONNLERR(CONN_INX) = LOCAL_IOSB.STAT
	  ENDIF
8100	CONTINUE
C
C	TRY TO CONNECT LATER
C
	CONN_WAIT=GUI_CONN_WAIT
	CALL GUITCPPSTARTTIME(GUITCP_TIME_PCON,CONN_WAIT)
C
10000	CONTINUE
C
	RETURN
C
	END
