C
C SUBROUTINE RLOG
C $Log:   GXAFXT:[GOLS]RLOG.FOV  $
C  
C     Rev 1.0   17 Apr 1996 14:45:08   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 17:31:24   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - rlog.for **
C
C RLOG.FOR
C
C V02 21-JUN-2002 JHR IMPLEMENTATION GLOBAL 210
C                     REPLACED HOLD WITH WAIT FOR 5 MILLISECONDS IN ORDER TO
C                     AVOID THE DEADLOCK BETWEEN THE LOGGER AND NETMGR
C                     LOGGER WAKES UP NETMGR BEFORE NETMGR HOLDS ITSELF.
C
C V01 01-AUG-90 XXX RELEASED FOR VAX
C
C
C LOGGER READ SUBROUTINE
C READ TRANSACTION FROM APPROPIATE LOGGER MEMORY BUFFER.
C IF BUFFER NOT CURRENTLY IN MEMORY REQUEST BUFFER
C TO BE READ AND WAIT FOR COMPLETION.
C
C IF RECORD TYPE IS NOT SET TO ONE OR TWO (ONE RECORD TRANSACTION,
C OR FIRST RECORD OF A MULTI-RECORD TRANSACTION) THEN RETURN WITH
C A LOGGER READ ERROR. IF RECORD IS A FIRST RECORD OF A MULTI-
C RECORD TRANSACTION THEN RETURN ALL THREE TRANSACTION RECORDS.
C
C
C CALLING SEQUENCE:
C     CALL RLOG(SERIAL,RECORD,TASK,STATUS)
C INPUT
C     SERIAL   -  TRANSACTION SERIAL NUMBER
C     RECORD   -  TRANSACTION LOG RECORD
C     TASK     -  TASK NUMBER OF CALLING TASK
C OUTPUT
C     STATUS   - (0-OK,-1 - LOGGER READ ERROR)
C
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE RLOG(SERIAL,RECORD,TASK,STATUS)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:LOGCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:DESLOG.DEF'
C
	INTEGER*4 RECORD(LREC*3), K, LENGTH, TYPE, BL, ST, OFFSET
	INTEGER*4 INDEX, BLOCK, STATUS, TASK, SERIAL
	LOGICAL WFLAG
C
C
	WFLAG=.TRUE.
	GOTO 5
C
C ENTRY NRLOG - DON'T WAIT BETWEEN TRIES FOR COMMON ACCESS
C
	ENTRY NRLOG(SERIAL,RECORD,TASK,STATUS)
	WFLAG=.FALSE.
	GOTO 5
C
C CHECK IF TRANSACTION HAS BEEN LOGGGED
C YET, IF NOT RETURN STATUS OF -1.
C
5	CONTINUE
	STATUS=0
	IF(MOD(SERIAL,SYSOFF).GT.MOD(HRSER,SYSOFF).OR.SERIAL.LE.0)THEN
	    STATUS=-1
	    RETURN
	ENDIF
C
C GET TRANSACTION BLOCK AND INDEX
C
	CALL GETBI(SERIAL,BLOCK,INDEX,OFFSET)
	OFFSET=OFFSET+LOGHDR-1
C
C SCAN MEMORY RESIDENT FILE BLOCKS FOR
C THIS BLOCK.
C
10	CONTINUE
	IF(LOKON(P(LOGFLG))) THEN
15	  CONTINUE
	  IF(P(LOGFLG).NE.0) THEN
	    IF(WFLAG) CALL XWAIT(5,1,ST)
	    GOTO 15
	  ENDIF
	  GOTO 10
	ENDIF
C
C
	  DO 1000 BL=1,NUMLOG
	  IF(LOGBUF(BLONUM,BL).NE.BLOCK) GOTO 1000
C
C IF STATUS EQUALS READY FOR I/O THEN
C READ TRANSACTION FROM BUFFER.
C
	    IF(LOGBUF(BSTATE,BL).EQ.LGRDY.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGUSD.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGRRW.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGROU) THEN
C
C EXTRACT RECORD TYPE FROM LOG BUFFER
C IF RECORD TYPE IS INVALID RETURN WITH ERROR
C IF FIRST RECORD OF A MULTI-RECORD TRANSACTION
C THEN DETERMINE HOW MANY RECORDS ARE USED.
C
C***	      TYPE=LOGBUF(OFFSET+LREC-1,BL)
	      CALL ILBYTE(TYPE, LOGBUF(OFFSET,BL), LREC1-1)
	      TYPE=IAND(TYPE,7)
	      IF(TYPE.NE.LREG.AND.TYPE.NE.LONE) THEN
	        IF(LOGBUF(BSTATE,BL).EQ.LGRRW) LOGBUF(BSTATE,BL)=LGUSD
	        CALL LOKOFF(P(LOGFLG))
	        STATUS=-1
	        RETURN
	      ENDIF
	      LENGTH=LREC
	      IF(TYPE.EQ.LONE) THEN
C***	        TYPE=LOGBUF(OFFSET+LREC*2-1,BL)
		CALL ILBYTE(TYPE, LOGBUF(OFFSET,BL), LREC2-1)
	        TYPE=IAND(TYPE,7)
	        IF(TYPE.EQ.LEND) LENGTH=LREC*2
	        IF(TYPE.EQ.LTWO) LENGTH=LREC*3
	      ENDIF
C
	        CALL FASTMOV(LOGBUF(OFFSET,BL),RECORD(1),LENGTH)
	        OFFSET=OFFSET+LENGTH
	        IF(LENGTH.LT.LREC*3) THEN
	          CALL FASTSET(0,RECORD(LENGTH+1),LREC*3-LENGTH)
	        ENDIF
C
C IF BUFFER STATUS IS READY FOR RE-WRITE, RELEASE BUFFER FOR USE
C
	      IF(LOGBUF(BSTATE,BL).EQ.LGRRW) LOGBUF(BSTATE,BL)=LGUSD
C
C ALWAYS EXIT CRITICAL REGION
C
	      CALL LOKOFF(P(LOGFLG))
C
	      RETURN
	    ELSE
C
C IF ANY OTHER BLOCK STATUS ADD THIS TASKS
C ID NUMBER TO TASK MAP, KICK LOGGER AND
C WAIT FOR COMPLETION.
C
	      LOGBUF(TSKMAP,BL)=IOR(LOGBUF(TSKMAP,BL),LOGID(TASK))
C
C ALWAYS EXIT CRITICAL REGION
C
	      CALL LOKOFF(P(LOGFLG))
C
	      CALL RELSE(TSKNAM(LOG),ST)
              CALL XWAIT(5,1,ST)         ! V02
CV02	      CALL HOLD(0,ST)
	      GOTO 10
	    ENDIF
1000	  CONTINUE
C
C BLOCK NOT FOUND ALLOCATE A USED BLOCK
C AND REQUEST BLOCK TO BE READ.
C ROUND ROBIN SEARCH TO GIVE EVERYONE A CHANCE.
C
	  DO 2000 K=1,NUMLOG
	  BL=SBLOCK
	  BL=MOD(BL,NUMLOG)+1
	  SBLOCK=BL
	  IF(LOGBUF(BSTATE,BL).NE.LGUSD) GOTO 2000
	  LOGBUF(BLONUM,BL)=BLOCK
	  LOGBUF(LOGCNT,BL)=0
	  LOGBUF(BLTAPE,BL)=0
	  LOGBUF(BSTATE,BL)=LGRIN
	  LOGBUF(TSKMAP,BL)=IOR(LOGBUF(TSKMAP,BL),LOGID(TASK))
C
C ALWAYS EXIT CRITICAL REGION
C
	  CALL LOKOFF(P(LOGFLG))
C
	  CALL RELSE(TSKNAM(LOG),ST)
          CALL XWAIT(5,1,ST)           ! V02
CV02	  CALL HOLD(0,ST)
	  GOTO 10
2000	  CONTINUE
C
C NO BUFFERS AVAILABLE ADD TASKS ID
C NUMBER TO A ACTIVE LOGGER BUFFER
C SO LOGGER WILL KICK US WHEN A BUFFER
C BECOMES AVAILABLE.
C
	LOGBUF(TSKMAP,1)=IOR(LOGBUF(TSKMAP,1),LOGID(TASK))
C
C ALWAYS EXIT CRITICAL REGION
C
	CALL LOKOFF(P(LOGFLG))
C
	CALL RELSE(TSKNAM(LOG),ST)
        CALL XWAIT(5,1,ST)           ! V02
CV02	CALL HOLD(0,ST)
	GOTO 10
	END
