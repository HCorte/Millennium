C
C SUBROUTINE X2STCONF
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]X2STCONF.FOV                                 $
C  $Date::   17 Apr 1996 16:35:34                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - x2stconf.for;1 **
C
C X2STCONF.FOR
C
C V07 16-MAR-96 wsm Determine network ports for X.21 as well, not just X.25.
C V06 10-MAR-94 SCD Add X2XC_DIAL_OV_OVERRIDE (especially important for
C                   X.28 GVTs)
C V05 22-AUG-94 GPR USE DIAL ENABLE FROM STATION CLASS - Integrate UK 
C		    changes into X2X Baseline
C V04 19-JUL-94 WS MULTINETWORK CHANGES - Integrate UK changes 
C		   into X2X Baseline
C V03  8-MAR-94 JWE Add support for X.21 station
C V02 14-APR-91 DAS TEST STN TYPE BEFORE TESTING NUMPORTS
C V01 01-DEC-91 DAS RELEASED FOR VAX (NETHERLANDS)
C
C  This subroutine uses the station configuration record fields
C| of the X2XSTN.FIL that are maintained in X2Xcom and creates the output
C  configuration station message.  The network ports sent in the configuration
C  response are determined by X2NETPRT.
C| ( All necessary fields of X2XSTN.FIL, X2XSCL.FIL, and X2XNPC.FIL
C| have been updated in X2Xcom.)
C
C Calling sequence:
C
C     CALL X2STCONF(TRABUF,MESS,MESLEN)
C
C Input parameters:
C
C     TRABUF      Int*4(TRALEN)       Transaction buffer
C
C Output parameters:
C
C     MESS        Int*4(*)            Output message
C     MESLEN      Int*2               Length of message buffer
C                                     Read error MESLEN=-1
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE X2STCONF(TRABUF,MESS,MESLEN)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:PRMPRO.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:X2STMES.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:X2XTTN.DEF'
        INCLUDE 'INCLIB:PRMDLL.DEF'
        INCLUDE 'INCLIB:X2XREL.DEF'
C
	INTEGER*2   MESLEN                          !Output message length
	INTEGER*4   MESS(*)                         !Output message
	INTEGER*4   NETPORTS(X2X_MAXPRT_ASSIGN)     !Network ports to use
	INTEGER*4   NUMPORTS                        !Number of network ports
	INTEGER*4   DIALPORTS(X2X_MAXDIAL_ASSIGN)   !Dailup ports to use
        INTEGER*4   X32PORTS(X2X_MAXX32_ASSIGN)     !X.32.25 PORTS
	INTEGER*4   NUMDIAL                         !Number of dialup ports
        INTEGER*4   NUMX32                          !Number of X.32 ports
	INTEGER*4   TEMP                            !Work variable
	INTEGER*4   OFF                             !Data offset relative to hdr
	INTEGER*4   LSTBYT                          !Byte offset into buffer
	INTEGER*4   ADR_LEN                         !Length of add. flds (bytes)
        INTEGER*4   DISMODE                         !Real disconnection mode
        INTEGER*4   TEMP_ADR(2)                     !Work variable
        INTEGER*4   NPORT, DPORT, XPORT
	INTEGER*4   I, FLAGS, STATE, CHKVAL, STN, CLASS
	INTEGER*4   FE_SUBNETWORK, CLASS_SUBNETWORK, LAST_SAP	!V04
        LOGICAL     OLD_PROTO
	CHARACTER   C1TEMP(4)*1                     !Work variable
	EQUIVALENCE (TEMP,C1TEMP)
C
	INTEGER*4 ICHAR
	BYTE      BTEMP
C
C INITIALIZE VARIABLES.
C
	STN=TRABUF(TXSTN)
	MESLEN=0
	OFF=X2STMES_DATA-1
	LSTBYT=0
C
C DETERMINE IF THIS IS THE OLD STATION PROTOCOL OR NEW
C
        OLD_PROTO = .TRUE.
        IF((TRABUF(TXSSDTU).EQ.X2STMES_DATATYPE_DEFAULT_CONF2)
     *     .OR. (TRABUF(TXSSDTU).EQ.X2STMES_DATATYPE_RESET2))
     *          OLD_PROTO = .FALSE.
C
C CHECK FOR VALID STATION NUMBER.
C
	IF(CHKVAL(STN,1,X2X_STATIONS,' STATION NUMBER ').NE.0) THEN
D 	  TYPE *,'BAD STATION NUMBER ',STN
	  MESLEN=-1
	  GOTO 8000
	ENDIF
C
C CHECK TO ENSURE THE STATION INFORMATION
C EXISTS.
C
	IF(BX2XS_STATE(STN) .LE. 0) THEN
	  CALL OPS('X2STCONF:Station does not exist',STN,TRABUF(TSER))
D         TYPE *,'STATE ERROR: VALUE = ',BX2XS_STATE(STN)
	  MESLEN=-1
	  GOTO 8000
	ENDIF
C 
	CLASS = X2XS_STNCLS(STN)		    ! V04 (MMRY RESIDENT)
C
C CHECK TO ENSURE THE STATION CLASS INFORMATION
C EXISTS.
C
	IF(BX2XC_STATE(CLASS) .LE.0) THEN
	  CALL OPS('X2STCONF:Station class does not exist ',
     *	            X2XS_STNCLS(STN),0)
D          TYPE *,' CLASS ERROR'
	  MESLEN=-1
	  GOTO 8000
	ENDIF
C
C STORE THE COMMAND CODE - NOTE: DIFFERS BASED ON UPLINE MESSAGE.
C
        IF((TRABUF(TXSSDTU).EQ.X2STMES_DEF_CONF_REQ) .OR.
     *     (TRABUF(TXSSDTU).EQ.X2STMES_DATATYPE_DEFAULT_CONF2)) THEN
	  CALL ISBYTE(X2STMES_DEF_CONF,MESS,OFF+X2STMES_CMD-1)
	  LAST_SAP=ZEXT(BX2XS_SAP(STN))					!V04
	  IF (LAST_SAP.NE.0) THEN					!V04
	    CLASS_SUBNETWORK=X2XC_SUBNETWORK(CLASS)			!V04
	    FE_SUBNETWORK=X2XE_SUBNETWORK(LAST_SAP)			!V04
	    IF (CLASS_SUBNETWORK.NE.FE_SUBNETWORK) 			!V04
     *	      CALL OPS('Wrong station snet, stn/sap ',STN,LAST_SAP)	!V04
	  ENDIF								!V04
	ELSE
	  CALL ISBYTE(X2STMES_CONF,MESS,OFF+X2STMES_CMD-1)
	ENDIF
C
C STORE STATION CONFIGURATION INTO MESSAGE.
C
	CALL ISBYTE(X2STMES_CONF,MESS,OFF+X2STMES_CMD-1)
	TEMP=0
	C1TEMP(1)=X2XS_CONF(STN)
	IF (X2XS_TYPE(STN).EQ.X2XST_BCST) 				!V04
     *		     TEMP=0						!V04
	CALL ISBYTE(TEMP,MESS, OFF+X2STMES_CONF_CNTNO-1)
	CALL I4TOBUF2(STN,MESS,OFF+X2STMES_CONF_STNO-1)
C
	CALL I4TOBUF2(X2XC_INTIM(CLASS),MESS,OFF+X2STMES_CONF_INTIM-1)
	CALL I4TOBUF2(X2XC_OUTTIM(CLASS),MESS,OFF+X2STMES_CONF_OUTTIM-1)
	CALL I4TOBUF2(X2XC_RESTIM(CLASS),MESS,OFF+X2STMES_CONF_REPTIM-1)
	CALL I4TOBUF2(X2XC_INTTIM(CLASS),MESS,OFF+X2STMES_CONF_TRATIM-1)
C
C USE CLASS STATS. INTERVAL PARAMETER. GLOBAL IS USED FOR FE STATISTICS
C
        CALL I4TOBUF2(X2XC_STSTIM(CLASS),MESS,OFF+X2STMES_CONF_STATIM-1)
C
	CALL I4TOBUF4(X2X_SYSTIM,MESS,OFF+X2STMES_CONF_SYSTIM-1)
C
	BTEMP=0
	IF(BX2XC_MSTENA(CLASS) .EQ.0) CALL BSET(BTEMP,7)	
	IF(BX2XC_DIAL_ENABLE(CLASS) .EQ.0) CALL BSET(BTEMP,6)
C
C CHECK THE STATION STATE, AND IF THE STATION IS DISABLED,
C DISABLE MASTER ENABLE, PREVENTING THE STATION FROM BEGINNING
C NORMAL OPERATIONS, AND SET DISCONNECTION TO UNCONDITIONAL.
C
	STATE=BX2XS_STATE(STN)	
	IF(STATE.EQ.X2XS_DISABLED) THEN
	  CALL BCLR(BTEMP,7)
	  FLAGS=X2STMES_RE+X2STMES_DIS_UNC
	  CALL ISBYTE(FLAGS,MESS,X2STMES_FLAGS-1)
	ENDIF
C
C
C IF STATION IS (TO BE) ACTIVE IN THE RELAY WITH RESET
C THEN THE HOST RESPONDS TO HELP REQUEST WITH MDS SET
C
C DETERMINE IF STN IN RELAY (REQUESTD OR ACTIVE) GROUP
C
C
C* USES  X2XR_STATION_STATE(STN), WITH STATES
C*   not-in-relay, online-relay,restart-relay,reset-relay
C* MDS IS ACTIVATED ONLY FOR reset_relay STATE,
C*   i.e. between shutup and wakeup messages
C
        IF(X2XR_STATION_STATE(STN) .EQ. X2XR_RESET_RELAY) THEN
           CALL BCLR(TEMP,7)                           
        ENDIF
C
	CALL ISBYTE(BTEMP,MESS,OFF+X2STMES_CONF_MSTENA-1)
	CALL ILBYTE(BTEMP,MESS,OFF+X2STMES_CONF_MSTENA-1)
	CALL ISBYTE(X2XC_RETRY(CLASS),MESS,OFF+X2STMES_CONF_STNRET-1)
C
        IF(.NOT.OLD_PROTO) THEN
          LSTBYT=X2STMES_CONF_ABSTIM+2
C
C Allow for old X.21 "Phase 0" stations...
C
        ELSE IF(BX2XS_CONN_TYPE(STN) .EQ. X2XSCT_X21SWC)THEN
	  LSTBYT = X2STMES_CONF_OUTCNT + 1
        ELSE
          LSTBYT=X2STMES_CONF_XIDLEN+1
        ENDIF
C
C ================= UPDATE NETWORK PORT CONFIGURATION ===========
C
C DETERMINE WHICH NETWORK PORTS TO ASSIGN TO THE
C STATION.  NOTE:  THE X2XSCL RECORD IS PASSED TO X2NETPORT,
C ALLOWING THE ROUTINE TO ASSIGN SPECIFIC PORTS IF THEY ARE
C DEFINED IN THE RECORD.
C
CV04	CALL X2NETPRT(STN,NUMPORTS,NETPORTS)
	IF (BX2XS_CONN_TYPE(STN).EQ.X2XSCT_X25SVC .OR.			!V04
     *      BX2XS_CONN_TYPE(STN).EQ.X2XSCT_X21SWC)			!V07
     *	  	CALL X2NETPRT(STN,NUMPORTS,NETPORTS)			!V04
C
C UPDATE THE OUTCALL PARAMETER OFFSET AND THE OUTCALL
C PARAMETER COUNT.
C
	CALL ISBYTE(LSTBYT-1,MESS,OFF+X2STMES_CONF_OUTOFF-1)
	CALL ISBYTE(NUMPORTS,MESS,OFF+X2STMES_CONF_OUTCNT-1)
C
	DO 200 I=1,NUMPORTS
C
C
C STORE THE PRIMARY OUTCALL INFORMATION INTO THE OUTPUT BUFFER.
C
          NPORT = ABS(NETPORTS(I))
	  IF(I.EQ.1) THEN
	    TEMP=X2STMES_CONF_OUTVAL                     ! Set outcall bit
	    IF(BX2XPN_FAST(NPORT).EQ.0)                ! Set fast select
     *	      TEMP=IOR(TEMP,X2STMES_CONF_FASTSEL)
	    IF(BX2XPN_REVCHRG(NPORT).EQ.0)             !Set reverse charging
     *	      TEMP=IOR(TEMP,X2STMES_CONF_REVERSE)
C
            IF(X2XC_DISX25RAM(CLASS).GT.0) THEN
              DISMODE = X2XC_DISX25RAM(CLASS)
            ELSE
              DISMODE=X2XPN_DDIS(NPORT)
            ENDIF
	    TEMP=TEMP+IAND(DISMODE,X2STMES_CONF_DEFDIS) ! Def disconnect
	    CALL ISBYTE(TEMP,MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+X2STMES_CONF_OUTFLG
	    CALL ISBYTE(X2XPN_RETCNT(NPORT),MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+X2STMES_CONF_OUTRET
	    CALL I4TOBUF2(X2XPN_RETTIM(NPORT),MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+X2STMES_CONF_OUTINT
	    CALL ISBYTE(X2XPN_ADDLEN(NPORT),MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+X2STMES_CONF_OUTLEN1
C
C A NEGATIVE PORT NUMBER INDICATES THAT A SPECIFIC PORT HAS
C BEEN ASSIGNED, SO USE THE NETWORK ADDRESS INSTEAD OF THE
C HUNT GROUP ADDRESS.
C
	    IF(NETPORTS(I).LT.0) THEN
              TEMP_ADR(1) = X2XPN_ADRESS(1,NPORT)
              TEMP_ADR(2) = X2XPN_ADRESS(2,NPORT)
	    ELSE
              TEMP_ADR(1) = X2XPN_HUNT_ADR(1,NPORT)
              TEMP_ADR(2) = X2XPN_HUNT_ADR(2,NPORT)
	    ENDIF
            CALL X2QSHFT(TEMP_ADR,64-(X2XPN_ADDLEN(NPORT)*4))
            CALL I4TOBUF4(TEMP_ADR(1),MESS,OFF+LSTBYT-1)
            LSTBYT=LSTBYT+4
            CALL I4TOBUF4(TEMP_ADR(2),MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+4
C
C STORE THE ALTERNATE OUTCALL ADDRESSES.
C
	  ELSE
	    CALL ISBYTE(X2XPN_ADDLEN(NPORT),MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+X2STMES_CONF_OUTLEN1
	    ADR_LEN = ((X2XPN_ADDLEN(NPORT)+1)/2)     !Size in bytes
            IF(NETPORTS(I).LT.0) THEN
              TEMP_ADR(1) = X2XPN_ADRESS(1,NPORT)
              TEMP_ADR(2) = X2XPN_ADRESS(2,NPORT)
            ELSE
              TEMP_ADR(1) = X2XPN_HUNT_ADR(1,NPORT)
              TEMP_ADR(2) = X2XPN_HUNT_ADR(2,NPORT)
            ENDIF
            CALL X2QSHFT(TEMP_ADR,64-(X2XPN_ADDLEN(NPORT)*4))
            IF(ADR_LEN.LE.4) THEN
              CALL NMOVBYT(TEMP_ADR(1),1,MESS,(OFF+LSTBYT),ADR_LEN)
            ELSE
              CALL NMOVBYT(TEMP_ADR(1),1,MESS,(OFF+LSTBYT),4)
              CALL NMOVBYT(TEMP_ADR(2),1,MESS,(OFF+LSTBYT+4),
     *                     ADR_LEN-4)
            ENDIF
            LSTBYT = LSTBYT + ADR_LEN 
	  ENDIF
200     CONTINUE
C
C Old X.21 stations don't know about dialup, X.32, or much of anything else
C
	IF(BX2XS_CONN_TYPE(STN) .EQ. X2XSCT_X21SWC)THEN
C
C UPDATE MESSAGE LENGTH.
C
	    GOTO 7999
	ENDIF
C
C =========== UPDATE DIALUP INFORMATION INTO MESSAGE ==========
C
C GET THE DIALUP PORTS TO ASSIGN AND
C UPDATE THE OUTCALL PARAMETER OFFSET AND THE OUTCALL
C PARAMETER COUNT.
C
	NUMDIAL=0
CV04        IF(BX2XS_DIAL_ENABLE(I).EQ.0)
        IF(BX2XC_DIAL_ENABLE(CLASS).EQ.0)			      !V05
     *	      CALL X2DIALPT(STN,0,NUMDIAL,DIALPORTS)
	CALL ISBYTE(LSTBYT-1,MESS,OFF+X2STMES_CONF_DIALOFF-1)
	CALL ISBYTE(NUMDIAL,MESS,OFF+X2STMES_CONF_DIALCNT-1)
C
	DO 300 I=1,NUMDIAL
C
C STORE THE PRIMARY OUTCALL INFORMATION INTO THE OUTPUT BUFFER.
C
          DPORT = ABS(DIALPORTS(I))                  
	  IF(I.EQ.1) THEN
	    TEMP=X2STMES_CONF_OUTVAL                 !Set outcall bit
            IF (X2XC_DIAL_OV_OVERRIDE(CLASS).NE.0)       ! V06
     *                TEMP=0                             ! V06
            IF(ICHAR(X2XPN_FAST(DPORT)).EQ.0)        !Set fast select
     *        TEMP=IOR(TEMP,X2STMES_CONF_FASTSEL)
            IF(ICHAR(X2XPN_REVCHRG(DPORT)).EQ.0)     !Set reverse charging
     *        TEMP=IOR(TEMP,X2STMES_CONF_REVERSE)
C
            IF(X2XC_DISDUPRAM(CLASS).GT.0) THEN
               DISMODE=X2XC_DISDUPRAM(CLASS)
            ELSE
               DISMODE=X2XPN_DDIS(DPORT)
            ENDIF
C
            TEMP=TEMP+IAND(DISMODE,X2STMES_CONF_DEFDIS) !Def disconnect
	    CALL ISBYTE(TEMP,MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+X2STMES_CONF_DIAL_OUTFLG
	    CALL ISBYTE(X2XPN_RETCNT(DPORT),MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+X2STMES_CONF_DIAL_OUTRET
	    CALL I4TOBUF2(X2XPN_RETTIM(DPORT),MESS,OFF+LSTBYT-1)
	    LSTBYT=LSTBYT+X2STMES_CONF_DIAL_OUTINT
	  ENDIF
C
C A NEGATIVE PORT NUMBER INDICATES THAT A SPECIFIC PORT HAS
C BEEN ASSIGNED, SO USE THE NETWORK ADDRESS INSTEAD OF THE
C HUNT GROUP ADDRESS.
C
          CALL ISBYTE(X2XPN_ADDLEN(DPORT),MESS,OFF+LSTBYT-1)
	  LSTBYT=LSTBYT+X2STMES_CONF_DIAL_OUTLEN
          ADR_LEN = ((X2XPN_ADDLEN(DPORT)+1)/2)
          IF(DIALPORTS(I).LT.0) THEN
            TEMP_ADR(1) = X2XPN_ADRESS(1,DPORT)
            TEMP_ADR(2) = X2XPN_ADRESS(2,DPORT)
          ELSE
            TEMP_ADR(1) = X2XPN_HUNT_ADR(1,DPORT)
            TEMP_ADR(2) = X2XPN_HUNT_ADR(2,DPORT)
          ENDIF
          CALL X2QSHFT(TEMP_ADR,64-(X2XPN_ADDLEN(DPORT)*4))
          IF(ADR_LEN.LE.4) THEN
            CALL NMOVBYT(TEMP_ADR(1),1,MESS,(OFF+LSTBYT),ADR_LEN)
          ELSE
            CALL NMOVBYT(TEMP_ADR(1),1,MESS,(OFF+LSTBYT),4)
            CALL NMOVBYT(TEMP_ADR(2),1,MESS,(OFF+LSTBYT+4),
     *                   ADR_LEN-4)
          ENDIF
          LSTBYT = LSTBYT + ADR_LEN 
300	CONTINUE
C
C =========== STORE X.32 PARAMETER INFORMATION INTO MESSAGE ==========
C
        IF(OLD_PROTO) THEN
           CALL ISBYTE(0,MESS,OFF+X2STMES_CONF_XIDOFF-1)
           CALL ISBYTE(0,MESS,OFF+X2STMES_CONF_XIDLEN-1)
        ELSE
C
C =========== UPDATE X.32 INFORMATION INTO MESSAGE ==========
C
C GET THE X.32 NETWORK PORTS TO ASSIGN AND
C UPDATE THE OUTCALL PARAMETER OFFSET AND THE OUTCALL PARAMETER COUNT.
C
           NUMX32 = 0
           CALL X2X32PRT(STN,NUMX32,X32PORTS)
           CALL ISBYTE(LSTBYT-1,MESS,OFF+X2STMES_CONF_X32OFF-1)
           CALL ISBYTE(NUMX32,MESS,OFF+X2STMES_CONF_X32CNT-1)
C
C STORE THE PRIMARY OUTCALL INFORMATION INTO THE OUTPUT BUFFER.
C
           DO 400 I=1,NUMX32

             XPORT = ABS(X32PORTS(I))
             IF(I.EQ.1) THEN
               TEMP=X2STMES_CONF_OUTVAL                 !Set outcall bit
               IF(ICHAR(X2XPN_FAST(XPORT)).EQ.0)        !Set fast select
     *           TEMP=IOR(TEMP,X2STMES_CONF_FASTSEL)
               IF(ICHAR(X2XPN_REVCHRG(XPORT)).EQ.0)     !Set reverse charging
     *           TEMP=IOR(TEMP,X2STMES_CONF_REVERSE)
               IF(X2XC_DISDUPRAM(CLASS).GT.0) THEN
                  DISMODE=X2XC_DISDUPRAM(CLASS)
               ELSE IF(X2XC_DISDUPRAM(CLASS).GT.0) THEN
                  DISMODE=X2XC_DISX25RAM(CLASS)
               ELSE
                  DISMODE=X2XPN_DDIS(XPORT)
               ENDIF
C
C X.32 SECTION FOLLOWS THE LAYOUT OF THE X25 SECTION
C USE THE FIELD LENGTHS AS DEFINED BY X25
C
               TEMP=TEMP+IAND(DISMODE,X2STMES_CONF_DEFDIS) !Def disconnect
               CALL ISBYTE(TEMP,MESS,OFF+LSTBYT-1)
               LSTBYT=LSTBYT+X2STMES_CONF_OUTFLG
               CALL ISBYTE(X2XPN_RETCNT(XPORT),MESS,OFF+LSTBYT-1)
               LSTBYT=LSTBYT+X2STMES_CONF_OUTRET
               CALL I4TOBUF2(X2XPN_RETTIM(XPORT),MESS,OFF+LSTBYT-1)
               LSTBYT=LSTBYT+X2STMES_CONF_OUTINT
               CALL ISBYTE(X2XPN_ADDLEN(XPORT),MESS,OFF+LSTBYT-1)      
               LSTBYT=LSTBYT+X2STMES_CONF_OUTLEN1
C
C STORE THE PRIMARY X.32.25 ADDRESS
C
C A NEGATIVE PORT NUMBER INDICATES THAT A SPECIFIC PORT HAS
C BEEN ASSIGNED, SO USE THE NETWORK ADDRESS INSTEAD OF THE
C HUNT GROUP ADDRESS.
C
               IF(X32PORTS(I).LT.0) THEN
                 TEMP_ADR(1) = X2XPN_ADRESS(1,XPORT)
                 TEMP_ADR(2) = X2XPN_ADRESS(2,XPORT)
               ELSE
                 TEMP_ADR(1) = X2XPN_HUNT_ADR(1,XPORT)
                 TEMP_ADR(2) = X2XPN_HUNT_ADR(2,XPORT)
               ENDIF
               CALL X2QSHFT(TEMP_ADR,64-(X2XPN_ADDLEN(XPORT)*4))
               CALL I4TOBUF4(TEMP_ADR(1),MESS,OFF+LSTBYT-1)
               LSTBYT=LSTBYT+4
               CALL I4TOBUF4(TEMP_ADR(2),MESS,OFF+LSTBYT-1)
               LSTBYT=LSTBYT+4
C
C STORE THE ALTERNATE OUTCALL ADDRESSES.
C
             ELSE
               CALL ISBYTE(X2XPN_ADDLEN(XPORT),MESS,OFF+LSTBYT-1)
               LSTBYT=LSTBYT+X2STMES_CONF_OUTLEN1
               ADR_LEN = ((X2XPN_ADDLEN(XPORT)+1)/2)
               IF(NETPORTS(I).LT.0) THEN
                 TEMP_ADR(1) = X2XPN_ADRESS(1,XPORT)
                 TEMP_ADR(2) = X2XPN_ADRESS(2,XPORT)
               ELSE
                 TEMP_ADR(1) = X2XPN_HUNT_ADR(1,XPORT)
                 TEMP_ADR(2) = X2XPN_HUNT_ADR(2,XPORT)
               ENDIF
               CALL X2QSHFT(TEMP_ADR,64-(X2XPN_ADDLEN(XPORT)*4))
               IF(ADR_LEN.LE.4) THEN
                 CALL NMOVBYT(TEMP_ADR(1),1,MESS,(OFF+LSTBYT),ADR_LEN)
               ELSE
                 CALL NMOVBYT(TEMP_ADR(1),1,MESS,(OFF+LSTBYT),4)
                 CALL NMOVBYT(TEMP_ADR(2),1,MESS,(OFF+LSTBYT+4),
     *                        ADR_LEN-4)
               ENDIF
               LSTBYT = LSTBYT + ADR_LEN 
             ENDIF
400        CONTINUE
C
C =========== STORE UID PARAMETER INFORMATION INTO MESSAGE ==========
C
           CALL ISBYTE(0,MESS,OFF+X2STMES_CONF_UIDOFF-1)
           CALL ISBYTE(0,MESS,OFF+X2STMES_CONF_UIDLEN-1)
C
C =========== STORE NIGHT GAME PARAMETER INFORMATION INTO MESSAGE ==========
C
           CALL I4TOBUF2(X2XC_SLPTIME(CLASS),MESS,
     *                   OFF+X2STMES_CONF_SLPTIME-1)
           CALL ISBYTE(X2XC_AFTMAX(CLASS),MESS,
     *                 OFF+X2STMES_CONF_AFTMAX-1)
C
C =========== STORE FACILITIES PARAMETER INFORMATION INTO MESSAGE ==========
C
           CALL ISBYTE(0,MESS,OFF+X2STMES_CONF_FACLTY-1)
           CALL ISBYTE(0,MESS,OFF+X2STMES_CONF_AUXFAC-1)
C
C =========== STORE ABSOLUTE DISCONNECT TIMER INFORMATION INTO MESSAGE =====
C
           CALL I4TOBUF2(X2XC_ABS_TIM(CLASS),MESS,
     *                   OFF+X2STMES_CONF_ABSTIM-1)
        ENDIF
C
C
C UPDATE MESSAGE LENGTH.
C
7999	CONTINUE
	MESLEN=LSTBYT-1
C
C CHECK TO SEE IF PORTS ARE REALLY NECCESARY FOR THE TYPE OF STATION
C REQUESTING CONFIGURATION
C
        IF((BX2XS_CONN_TYPE(STN) .NE. X2XSCT_ASYPVC)  .AND.
     *     (BX2XS_CONN_TYPE(STN) .NE. X2XSCT_X28PAD)  .AND.
     *     (BX2XS_CONN_TYPE(STN) .NE. X2XSCT_USAT_PVC).AND.
     *     (BX2XS_CONN_TYPE(STN) .NE. X2XSCT_GTECH_DIAL).AND.
     *	   (NUMDIAL.EQ.0 .AND. NUMPORTS.EQ.0)) THEN
D	     TYPE *,'NO PORTS....'
             MESLEN=-1
        ENDIF
	X2XS_RESET_CNT(STN)=X2XS_RESET_CNT(STN)+1
C
C PROGRAM EXIT.
C
8000	CONTINUE
	RETURN
	END
