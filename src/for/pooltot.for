C
C SUBROUTINE POOLTOT
C $Log:   GXAFXT:[GOLS]POOLTOT.FOV  $
C  
C     Rev 1.0   17 Apr 1996 14:26:30   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 17:19:54   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - pooltot.for **
C
C POOLTOT.FOR
C
C     08-APR-91 MP  ELIMINATED NON-USED VARIABLE 'BASE'
C		    ADDED CODE TO HANDLE RAM POOLS
C V01 01-AUG-90 XXX RELEASED FOR VAX
C
C V02 50-JUL-89 WS RELEASED FOR SWEDEN
C V01 01-JUN-88 XXX RELEASED FOR MICHIGAN
C
C MODIFIED TO READ POOLOVR1.FIL
C====================================================================
C
C     POOLTOT(FDB,TOTAL,FILE,GAME,BUFFER,BUFFER_SIZE)
C                         GET TOTAL # OF SHARES
C     IN - FDB - FILE DESCRIPTOR BLOCK
C     FILE -     1 IF ON LINE SET OF FILES, 2 IF POOLOVR1.FIL USED
C     GAME -     GAME #
C     BUFFER_SIZE  - BUFFER SIZE
C     BUFFER -   BUFFER FOR I/O
C     OUT -      TOTAL # BET
C
C
C     USES LOGICAL UNIT 1
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE POOLTOT(FDB,TOTAL,FIL,GAM,BUFFER,BUFFER_SIZE)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:POOLLTO.DEF'
	INCLUDE 'INCLIB:LTOPOL.DEF'
C
	INTEGER*4  ADDSIZE
	PARAMETER (ADDSIZE=8)
C
	INTEGER*4 OFF1, LENGTH, TOT, ADDCMB, OFFSET, NUMPAGES
	INTEGER*4 PAGE_RATIO, ST1, RECN1, ST, RECN, OVERFLOW_BLOK
	INTEGER*4 F_INDEX, OFF, MAXCMB, FASTBIN, INWORD, BASE_PAGE
	INTEGER*4 NUMCMB, TOTOVR, BUFFER_SIZE, GAM, FIL, TOTAL
	INTEGER*4 BUFFER(BUFFER_SIZE), ACT_SECT
C
	INTEGER*4 OVERFLOWS(2,MAXOVR),FDB(7),PFDB(7)
C
	INTEGER*4 I4
	INTEGER*2 I2(2)
	EQUIVALENCE (I4,I2)
C
	TOTOVR=0
	TOTAL=0
	NUMCMB=0
C
	BASE_PAGE=LTPOOL_GAMPAG(GAM)
	INWORD=LTPOOL_INWORD(BASE_PAGE)
C
	MAXCMB=FASTBIN(LTPOOLNR(GAM),LTPOOLBET(GAM))
	DO 10, OFF=1,MAXIND
	   IF (LTPOOL_GAMENR(TSPT,OFF).EQ.GAM) MAXCMB=3**LTPOOLNR(GAM)
10	CONTINUE
D	TYPE *,IAM(),'GAME ',GAM,' HAS ',MAXCMB,' COMBINATIONS '
C
C
C     READ OVERFLOWS AND NUMBER OF OVERFLOW BLOCKS IN THE FILE
C
	IF (FIL.EQ.1) THEN
	   CALL FASTMOV(LTOVR(1,1,GAM),OVERFLOWS(1,1),MAXOVR*2)
	   F_INDEX=LO1
	   OVERFLOW_BLOK=OVRBLK
	ELSE
	   ACT_SECT=LTOSEC*256/SECSIZE
C***	   RECN=LTOSEC*LTNUMPAG+1+(GAM-1)*MAXOVR*8/256
	   RECN=ACT_SECT*LTNUMPAG+1+(GAM-1)*MAXOVR*8/SECSIZE
	   CALL READQIO(FDB,RECN,OVERFLOWS,MAXOVR*8,ST)
C
C***	   RECN1=LTOSEC*LTNUMPAG+1+LTNUMGAMES*MAXOVR*8/256
	   RECN1=ACT_SECT*LTNUMPAG+1+LTNUMGAMES*MAXOVR*8/SECSIZE
	   CALL READQIO(FDB,RECN1,OVERFLOW_BLOK,4,ST1)
C
	   IF (ST.NE.0.OR.ST1.NE.0) THEN
	      TYPE *,IAM(), 'Cannot read overflows ',ST,ST1,RECN,RECN1
	      CALL GPAUSE
	      RETURN
	   ENDIF
	   F_INDEX=LO2
	ENDIF
C
C     READ ALL PAGES
C
	PAGE_RATIO=PAGESIZE/BUFFER_SIZE
	NUMPAGES=PAGE_RATIO*LTNUMPAG
	DO 70 RECN=1,NUMPAGES              !READ PAGES
	  IF (LTPOOL_PAGGAM((RECN-1)/PAGE_RATIO+1).NE.GAM) GOTO 70
          IF(FIL .EQ. 1 .AND. P(LTOPOL_RAM) .NE. LTOPOL_FIL_VALUE) THEN
	    CALL FASTMOV(LTOPOL_SPACE((RECN-1)*BUFFER_SIZE+1),
     1	      BUFFER, BUFFER_SIZE)
          ELSE
	    CALL READQW(FDB,RECN,BUFFER,ST)
	    IF (ST.NE.0) THEN
	    CALL FILERR(SFNAMES(1,F_INDEX),2,ST,RECN)
		CALL GPAUSE
	    ENDIF
	  ENDIF
	  OFFSET=1
	  ADDCMB=ADDSIZE*INWORD
	  IF (INWORD.EQ.8) THEN
	    DO 40, OFFSET=1,BUFFER_SIZE,ADDSIZE
	      CALL POOLADD(BUFFER(OFFSET),ADDSIZE,TOT)
	      TOTAL=TOTAL+TOT
	      NUMCMB=NUMCMB+ADDCMB
	      IF (NUMCMB.GE.MAXCMB) GOTO 80   !ALL READ
40	    CONTINUE
	  ELSEIF (INWORD.EQ.4) THEN
	    DO 50, OFFSET=1,BUFFER_SIZE,ADDSIZE
	      CALL BYTADD32(BUFFER(OFFSET),TOT)
C***        IF (TOT.NE.0) TYPE *,IAM(),'offset ,page ',OFFSET,RECN
	      TOTAL=TOTAL+TOT
	      NUMCMB=NUMCMB+ADDCMB
	      IF (NUMCMB.GE.MAXCMB) GOTO 80   !ALL READ
50	    CONTINUE
	  ELSEIF (INWORD.EQ.2) THEN
	    DO 60, OFFSET=1,BUFFER_SIZE
	      I4=BUFFER(OFFSET)
	      TOTAL=TOTAL+I2(1)+I2(2)
	      NUMCMB=NUMCMB+2
	      IF (NUMCMB.GE.MAXCMB) GOTO 80   !ALL READ
60	    CONTINUE
	  ENDIF
C
70	CONTINUE
C
80	CONTINUE
D	TYPE *,IAM(),' TOTAL ',total
C
	DO 100, OFF=1,MAXOVR-1
	IF (OVERFLOWS(2,OFF).EQ.0) GOTO 200
	TOTOVR=TOTOVR+OVERFLOWS(2,OFF)
100	CONTINUE
C
200	CONTINUE
D	TYPE *,IAM(),'TOTOVR ',TOTOVR
	IF (OVERFLOW_BLOK.EQ.0) GOTO 240
C
210	CONTINUE
	IF (FIL.EQ.1) THEN
	   CALL OPENW(1,SFNAMES(1,LO1),4,0,0,ST)   !POOL OVERFLOW FILE
	ELSE
	   CALL OPENW(1,SFNAMES(1,LO2),4,0,0,ST)   !POOL OVERFLOW FILE
	ENDIF
C
	IF (ST.NE.0) THEN
	  CALL FILERR(SFNAMES(1,F_INDEX),1,ST,0)
	  TYPE *,IAM(),' Correct the problem and continue.'
	  CALL GPAUSE
	  GOTO 210
	ENDIF
	LENGTH=MAXOVR*8/256
	CALL IOINIT(PFDB,1,LENGTH*256)     !INITIALISE FOR I/O
C
C     READ FROM POOLOVR.FIL      ;READ OVERFLOWS FROM FILE
C
	DO 230, OFF=1,OVERFLOW_BLOK
	CALL READW(PFDB,OFF,OVERFLOWS(1,1),ST)
	  IF (ST.NE.0) THEN
	  CALL FILERR(SFNAMES(1,F_INDEX),2,ST,OFF)
	    CALL GPAUSE
	  ENDIF
	IF (OVERFLOWS(1,MAXOVR).NE.GAM) GOTO 230
	DO 220, OFF1=1,MAXOVR-1
	IF (OVERFLOWS(2,OFF1).EQ.0) GOTO 230
	TOTOVR=TOTOVR+OVERFLOWS(2,OFF1)
220	CONTINUE
230	CONTINUE
240	CONTINUE
C***  TYPE *,IAM(),'TOTOVR ',TOTOVR
C
	CALL CLOSEFIL(PFDB)
	TOTAL=TOTAL+TOTOVR
C***  TYPE *,IAM(),'TOTAL ',TOTAL
	RETURN
	END
