C
C V02 16-NOV-1999 OXK Corrected spelling error
C V01 ??-???-???? ??? Original version
C
C	THRULOG2.FOR
C	___________
C
C	THE FUNCTION OF THIS PROGRAM IS TO WRITE TMF DATA BLOCK ON THE REMOTE
C	 SYSTEM
C	THIS PROGRAM WILL INITIALISE THRUCOM (COMMON TO SEND DATA TO REMOTE 
C	SYSTEM) AND WILL DEQUEUE THE DATA FROM THRU_SENDQUE OR THRU_DELAYQUE
C	AND WILL SEND IT TO THE REMOTE SYSTEM
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	PROGRAM THRULOG2
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE	'INCLIB:LOGCOM.DEF'
	INCLUDE 'INCLIB:THRUCOM.DEF'
C
	INTEGER*4   SEND_FDB(7), MFDB(7), BFDB(7)
	INTEGER*4   SEND_LUN
	PARAMETER (SEND_LUN=1)
	INTEGER*4   STATUS, ST, ST1, BLOCK_NO, BUF_NO
	INTEGER*4   LOCAL_BUF(DBLOCK)
	LOGICAL	    BACKUP_TM
	CHARACTER*40 REMOTE_NAME /'REMSYSX:REMOTE.FIL'/
	BYTE	I1_REMOTE_NAME(40)
	EQUIVALENCE (REMOTE_NAME,I1_REMOTE_NAME)

	INTEGER*4   OPEN_ATTEMPT, DAYSTS_CNT
	INTEGER*4   DAYSTS_CNT_MAX
	PARAMETER (DAYSTS_CNT_MAX = 13)
C
	INTEGER*4   SYSTEM

	INTEGER*4   NEXT,VALUE

	INTEGER*4   I4NAME(2)
	BYTE	    I1NAME(8)
	EQUIVALENCE (I1NAME,I4NAME)
	BYTE	SPACE/' '/
	BYTE	NUMERIC(0:9) /'0','1','2','3','4','5','6','7','8','9'/
	
        INTEGER*4 REM_LOG_ACTIVE/0/

	CALL GETNAM(I4NAME)
C

	DO 2, NEXT=8,1,-1
	    IF (I1NAME(NEXT).EQ.SPACE) GOTO 2
	    DO 1, VALUE=0,9
		IF (I1NAME(NEXT).EQ.NUMERIC(VALUE)) THEN
		    SYSTEM=VALUE
		    IF (SYSTEM.GT.THRU_SYSTEMS) SYSTEM=1
		    GOTO 3
		ENDIF
1	    CONTINUE
	    SYSTEM=1
	    GOTO 3
2	CONTINUE
	SYSTEM=1
3	CONTINUE

        SYSTEM=2   ! temporary

	I1_REMOTE_NAME(7)=NUMERIC(SYSTEM)
C
	CALL COPYRITE
C
C INITIALIZE AND OPEN TMF FILES

	OPEN_ATTEMPT=0
	DAYSTS_CNT=0

	CALL THRUINI

C	OPEN LOCAL TM

	BACKUP_TM=.FALSE.
	CALL OPENW(2,SFNAMES(1,PTMF),4,0,0,ST)
	CALL IOINIT(MFDB,2,32*256)
	IF(ST.NE.0) THEN
	  CALL OPS('Cannot open master TM ',ST,0,0)
	  CALL GSTOP(GEXIT_SUCCESS)
	ENDIF
C
	IF(P(DISKSW).NE.0) THEN
	  CALL OPENW(3,SFNAMES(1,BTMF),4,0,0,ST)
	  CALL IOINIT(BFDB,3,32*256)
	  IF(ST.NE.0) THEN
	    CALL OPS('Cannot open BACKUP TM ',ST,0,0)
	  ENDIF
	  BACKUP_TM=.TRUE.
	ENDIF

C
	IF (THRU_DELAY_WAIT.EQ.0) THRU_DELAY_WAIT=40
	IF (THRU_LOOP_WAIT.EQ.0) THRU_LOOP_WAIT=100
C
C	INITIALISATION LOOP, THIS LOOP IS ENTERED WHEN SUBSYSTEM IS DISABLED
C	OR WHEN THERE IS A WRITE ERROR

5	CONTINUE
	IF (DAYSTS.NE.DSCLOS) THEN
	    DAYSTS_CNT=0
	ELSE
	    DAYSTS_CNT=DAYSTS_CNT+1
	    IF (DAYSTS_CNT.EQ.DAYSTS_CNT_MAX) STOP 'Bye bye boys'
	ENDIF
	IF (P(REM_LOG).NE.REM_LOG_ACTIVE) THEN
	    CALL XWAIT(100,1,ST)
	    GOTO 5
	ENDIF 
C
C MAY PROCEED NOW
C
C	OPEN REMOTE FILE, REINITIALISE  IF CANNOT OPEN THE FILE
 
	CALL OPEN_REMOTE(SEND_LUN,REMOTE_NAME,4,0,0,ST)
	IF (ST.NE.0) THEN
	   OPEN_ATTEMPT=OPEN_ATTEMPT+1
	   IF (MOD(OPEN_ATTEMPT,10).EQ.1) 
     *	      CALL OPS(' Error opening remote file ',ST,OPEN_ATTEMPT)
	   CALL XWAIT(1300,1,ST)
	   GOTO 5
	ENDIF
	CALL IOINIT(SEND_FDB, SEND_LUN,DBLOCK*4)
C
C MAIN LOOP 

10	CONTINUE
	CALL XWAIT(THRU_LOOP_WAIT,1,ST)
	IF (DAYSTS.NE.DSCLOS) THEN
	    DAYSTS_CNT=0
	ELSE
	    DAYSTS_CNT=DAYSTS_CNT+1
	    IF (DAYSTS_CNT.GE.DAYSTS_CNT_MAX) STOP 'Bye bye boys'
	ENDIF
C
C IF REMOTE LOGGING NOT ACTIVE GO TO INITIALISATIO LOOP
20	CONTINUE
	IF (P(REM_LOG).NE.REM_LOG_ACTIVE) THEN
	    CALL CLOSEFILE(SEND_FDB)
	    CALL XWAIT(100,1,ST)
	    GOTO 5
	ENDIF 
C
C	TRY TO GET BUFFER TO SEND FROM THRU_SENDQUE

	CALL RTL(BUF_NO,THRU_SENDQUE(1,SYSTEM),ST)
	IF (ST.NE.GLIST_STAT_EMPTY) THEN
	    BLOCK_NO=THRU_BUF_LOG_BLOCK(BUF_NO,SYSTEM)
C
C PUT ENCRYPTION HERE IF YOU NEED IT

	    CALL WRITEW(SEND_FDB,BLOCK_NO,THRU_BUF(1,BUF_NO,SYSTEM),STATUS)

C	    RELEASE TH BUFFER TO FREE QUEUE

	    CALL ABL(BUF_NO,THRU_FREEQUE(1,SYSTEM),ST)
	    IF (STATUS.NE.0) THEN
	      CALL OPS('Error writing to remote',BLOCK_NO,STATUS)
	      CALL ABL(BLOCK_NO,THRU_DELAYQUE(1,SYSTEM),ST)	      
	      CALL CLOSEFILE(SEND_FDB)
	      CALL XWAIT(100,1,ST)
	      GOTO 5
	    ENDIF
	    GOTO 20
	ENDIF
C
C TRY TO GET DATA FRORM "DELAY" QUEUE
	CALL RTL(BLOCK_NO,THRU_DELAYQUE(1,SYSTEM),ST)
	IF (ST.EQ.GLIST_STAT_EMPTY) GOTO 10
C
C	READ BLOCK FIRST IN TM OR TM BACKUP
30	CONTINUE
	CALL READW(MFDB,BLOCK_NO,LOCAL_BUF,ST)
	IF (ST.NE.0 .AND. BACKUP_TM) THEN 
	    CALL READW(BFDB,BLOCK_NO,LOCAL_BUF,ST1)
	    IF (ST1.NE.0) THEN
		CALL OPS('Error reading TM block ',BLOCK_NO,ST) 
		CALL OPS('read ERROR  ',ST,ST1)
		STOP 'Bye bye boys'
	    ENDIF
	ELSEIF (ST.NE.0) THEN
	    CALL OPS('Error reading TM block ',BLOCK_NO,ST)
	    STOP 'Bye bye boys'
	ENDIF
C
C PUT ENCRYPTION HERE IF YOU NEED IT
C
C WRITE TO REMOTE

	CALL WRITEW(SEND_FDB,BLOCK_NO,LOCAL_BUF,STATUS)
	IF (STATUS.NE.0) THEN
	   CALL OPS('Error writing to remote',BLOCK_NO,STATUS)
	   CALL ABL(BLOCK_NO,THRU_DELAYQUE(1,SYSTEM),ST)	      
	   CALL CLOSEFILE(SEND_FDB)
	   CALL XWAIT(100,1,ST)
	   GOTO 5
	ENDIF
	CALL XWAIT(THRU_DELAY_WAIT,1,ST)
	GOTO 10
	END
