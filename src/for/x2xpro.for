C
C PROGRAM X2XPRO
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]X2XPRO.FOV                                   $
C  $Date::   17 Apr 1996 16:43:58                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - x2xpro.for;1 **
C
C X2XPRO.FOR
C
C V08 01-AUG-2000 UXN TYPE* REPLACED WITH OPSTXT()
C V07 16-MAR-1995 DAS CHECK FOR VALID LENGTH BEFORE WRITING TO PTL
C V05 12-DEC-1994 DAS Integrate UK changes into X2X Baseline
C V03 16-AUG-1994 GPR USE X2FWOPEN AND X2FWCLOSE
C V02 03-MAY-1994 GPR USE I4 FOR TER
C V01 01-DEC-1991 DAS RELEASED FOR VAX (NETHERLANDS)
C
C X.21/X.25 GTP.
C PASSIVE SIDE.
C WILL REACT ON UPLINE COMMANDS AND LOG THEM IN THE TMF AND XMF.
C RELAY REQUESTS ARE HANDLED SEPARATELY.
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM X2XPRO
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:PRMLOG.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:X2FCOM.DEF'
	INCLUDE 'INCLIB:X2XSTN.DEF'
	INCLUDE 'INCLIB:X2XSCL.DEF'
	INCLUDE 'INCLIB:X2XNPC.DEF'
	INCLUDE 'INCLIB:X2XRCL.DEF'
	INCLUDE 'INCLIB:X2XRCD.DEF'
	INCLUDE 'INCLIB:X2XTTN.DEF'
C
	INTEGER*4   BUFFER(80)
	INTEGER*4   MAXPTL                      !Max entries in X2X.FIL
	INTEGER*4   LAYER, DIR, CHKVAL, SAP, STATION, XCODE
	INTEGER*4   XLAYER, XTYPE, BUF, STATUS, TASK, ST
	INTEGER*4   TER                         ! V02
	LOGICAL     RESPOND                     !Response message
	CHARACTER   CSFNAMES(MAXFIL)*20         !System file names
	EQUIVALENCE(SFNAMES,CSFNAMES)
C
	LOGICAL	    TRACE_MESSAGE, RELAY_MESSAGE, LOG_MESSAGE
C
	CALL COPYRITE
	CALL SNIF_AND_WRKSET
C
C OPEN THE X2X.FIL FILE TO DETERMINE THE NUMBER OF
C POSSIBLE RECORDS.
C
	CALL OPENW(1,SFNAMES(1,X2F),4,0,0,ST)
	IF(ST.NE.0) THEN
	  CALL OS32ER(5,CSFNAMES(X2F),'OPENX',ST,0)
	  CALL GPAUSE
	ENDIF
C
C GET THE NUMBER OF RECORDS.
C
	CALL GETFSIZ(1,MAXPTL)
	CALL USRCLOS1(1)
	MAXPTL=MAXPTL-X2FBSIZ           !Leave at least 1 empty block
C
C OPEN X2X FILE
C
	CALL X2FWOPEN					!V03
C
C OPEN CONFIG FILES
C
C****	CALL OPENW(1,SFNAMES(1,XSTN),4,0,0,ST)				
C****	CALL IOINIT(X2XSTN_FDB,1,X2XSTN_SECT*256)			
C****	IF(ST.NE.0) THEN						
C****	   CALL OS32ER(5,CSFNAMES(XSTN),'OPENX',ST,0)			
C****	   CALL GPAUSE	
C****	ENDIF								
C									
C****	CALL OPENW(2,SFNAMES(1,XSCL),4,0,0,ST)				
C****	CALL IOINIT(X2XSCL_FDB,2,X2XSCL_SECT*256)			
C****	IF(ST.NE.0) THEN						
C****	   CALL OS32ER(5,CSFNAMES(XSCL),'OPENX',ST,0)			
C****	   CALL GPAUSE	
C****	ENDIF								
C									
C****	CALL OPENW(3,SFNAMES(1,XNPC),4,0,0,ST)				
C****	CALL IOINIT(X2XNPC_FDB,3,X2XNPC_SECT*256)			
C****	IF(ST.NE.0) THEN						
C****	   CALL OS32ER(5,CSFNAMES(XNPC),'OPENX',ST,0)			
C****	   CALL GPAUSE	
C****	ENDIF								
C
	CALL OPENW(4,SFNAMES(1,XRCL),4,0,0,ST)
	CALL IOINIT(X2XRCL_FDB,4,X2XRCL_SECT*256)
	IF(ST.NE.0) THEN
	   CALL OS32ER(5,CSFNAMES(XRCL),'OPENX',ST,0)
	   CALL GPAUSE
	ENDIF
C
	CALL OPENW(7,SFNAMES(1,XRCD),4,0,0,ST)
	CALL IOINIT(X2XRCD_FDB,7,X2XRCD_SECT*256)
	IF(ST.NE.0) THEN
	   CALL OS32ER(5,CSFNAMES(XRCD),'OPENX',ST,0)
	   CALL GPAUSE
	ENDIF
C
C****	CALL OPENW(8,SFNAMES(1,XTTN),4,0,0,ST)
C****	CALL IOINIT(X2XTTN_FDB,8,X2XTTN_SECT*256)
C****	IF(ST.NE.0) THEN
C****	   CALL OS32ER(5,CSFNAMES(XTTN),'OPENX',ST,0)
C****	   CALL GPAUSE
C****	ENDIF
C
	TASK=X2P
5	CONTINUE
C
C WAIT FOR SOMETHING TO DO
C IF END OF DAY THEN CALL GSTOP(GEXIT_SUCCESS)
C
10	CONTINUE
	IF (X2X_DEBUG.EQ.32768) STOP
        IF(X2X_GAME_MODE .EQ. X2X_GAMEM_DAY) THEN
	  IF(DAYSTS.EQ.DSCLOS) THEN
	     CALL X2FWCLOSE				!V03
C****	     CALL CLOSEFIL(X2XSTN_FDB)
C****	     CALL CLOSEFIL(X2XSCL_FDB)
C****	     CALL CLOSEFIL(X2XNPC_FDB)
	     CALL CLOSEFIL(X2XRCL_FDB)
	     CALL CLOSEFIL(X2XRCD_FDB)
	     CALL OPSTXT('OK')
	     CALL GSTOP(GEXIT_SUCCESS)
          ENDIF
          IF(DAYSTS.EQ.DSSUSP) THEN
	    CALL HOLD(0,STATUS)
	    IF(DAYSTS.EQ.DSOPEN) GOTO 5
	    GOTO 10
	  ENDIF
C
	ELSEIF(X2X_GAME_MODE .EQ. X2X_GAMEM_NIGHT) THEN
          IF(X2X_GAME_STATE .EQ. X2X_GAMES_SHUTDOWN) THEN
             CALL X2FWCLOSE				  !V03
C****             CALL CLOSEFIL(X2XSTN_FDB)
C****             CALL CLOSEFIL(X2XSCL_FDB)
C****             CALL CLOSEFIL(X2XNPC_FDB)
             CALL CLOSEFIL(X2XRCL_FDB)
             CALL CLOSEFIL(X2XRCD_FDB)
             CALL OPSTXT('OK')
             CALL GSTOP(GEXIT_SUCCESS)
           ENDIF 
         ENDIF
C
	CALL HOLD(0,STATUS)
C
C GET BUFFER NUMBER FROM TOP OF QUEUE.
C IF NO WAGERS QUEUED, GO BACK TO WAIT STATE.
C
20	CONTINUE
	CALL TOPQUE(TASK,BUF)
	IF(BUF.EQ.0) THEN
	   IF(X2XPRO_FLUSH.NE.0) THEN
	      CALL X2FLUSH
	      X2XPRO_FLUSH=0
	   ENDIF
	   GOTO 10
	ENDIF
C
C THE BUFFER ALWAYS CONTAINS AN UPLINE COMMAND OR RESPONSE.
C IT MAY COME ON THREE DIFFERENT LAYERS.
C IT'S EITHER CORRECT (AS X2XMGR THINKS) OR INCORRECT. IF IT'S
C INCORRECT THE ERROR CODE IS SET. WE COPY THE CODE TO TXPTL .
C IF IT'S CORRECT (SYNTACTICALLY) WE MAKE UP THE TXPTL BASED ON THE MESSAGE.
C THE LAYER, THE MESSAGE COMES FROM, IS SET.
C SOME INFO IS DECODED INTO THE HEADER BY X2XMGR.
C
C GET THE COMMAND/ERORR FLAG, LAYER AND CODE (ERROR).
C
	CALL MOV2TOI4(XTYPE,PRO(INPTAB,BUF),X2PRO_MESTYP-1)!1ST AND 2ND BYTE
	CALL ILBYTE(XLAYER,PRO(INPTAB,BUF),X2PRO_TRATYP-1) !3RD BYTE
	CALL ILBYTE(XCODE,PRO(INPTAB,BUF),X2PRO_STATUS-1)  !6TH BYTE
	CALL MOV2TOI4(STATION,PRO(INPTAB,BUF),X2PRO_STATION-1)!7TH AND 8TH
	CALL MOV2TOI4(TER,PRO(INPTAB,BUF),X2PRO_TERMINAL-1)!4TH AND 5TH ! V02
	CALL ILBYTE(SAP,PRO(INPTAB,BUF),X2PRO_SSAP-1)      !9TH BYTE
C
	CALL FASTSET(0,TRABUF,TRALEN)
C
C DECODE PERMANENT PART OF THE TRANSACTION. SOME OF IT MAY BE NULL
C
	TRABUF(TSTAT) =GOOD
	TRABUF(TERR)  =NOER
	TRABUF(TCDC)  =DAYCDC
	TRABUF(TTYP)  =TSPE
	TRABUF(TSFUN) =TSX2X
C
	TRABUF(TXLAY) =XLAYER
	TRABUF(TXPTL) =XCODE
	TRABUF(TXSTN) =STATION          !STATION AS X2XMGR SEES IT
	TRABUF(TXSAP) =SAP              !SAP AS X2XMGR SEES IT
C
	TRABUF(TSER)  =PRO(SERIAL,BUF)
	TRABUF(TTIM)  =PRO(TSTAMP,BUF)
	TRABUF(TSIZE) =HPRO(NUMLRC,BUF)
        TRABUF(TINTRA)=1
	TRABUF(TTER)  =TER
C
	TRACE_MESSAGE =.FALSE.
	RELAY_MESSAGE =.FALSE.
	IF(TRABUF(TXPTL).EQ.X2ERR_GLO_TRACE_TER_INP .OR.
     *	   TRABUF(TXPTL).EQ.X2ERR_GLO_TRACE_TER_OUT) 
     *					  TRACE_MESSAGE =.TRUE.
C
        IF(HPRO(TRCODE,BUF).EQ.TYPX2X_RELAY_DELACK .OR.
     *       HPRO(TRCODE,BUF).EQ.TYPX2X_RELAY_DELERR .OR.
     *       HPRO(TRCODE,BUF).EQ.TYPX2X_RELAY) RELAY_MESSAGE =.TRUE.
	LOG_MESSAGE=.FALSE.
	IF (TRACE_MESSAGE .OR. 
     *	  (X2X_LOG_ENABLE.EQ.0.AND..NOT.RELAY_MESSAGE) .OR.
     *	  (RELAY_MESSAGE.AND.X2X_RELAY_LOG_ENABLE.EQ.0)) 
     *					      LOG_MESSAGE=.TRUE.

	IF(CHKVAL(XCODE,1,X2ERR_MAX_ERR,' PTL CODE ').NE.0.OR.
     *	   XTYPE.NE.X2X_MESTYP_CMD) THEN
C
	   TRABUF(TERR) =XERR
	   TRABUF(TSTAT)=REJT
	ENDIF
C
C SWITCH ON LAYER NUMBER TO DECODE MORE TRABUF STUFF FROM MESSAGE AND
C MESSAGE HEADER (SET BY X2XMGR).
C
C STATION, SAP, FEID, ETC.
C
	IF(XLAYER.EQ.X2X_TRATYP_XPORT) THEN       !GTP
C
	   CALL DGTP(PRO(INPTAB,BUF),TRABUF)
C
	ELSEIF(XLAYER.EQ.X2X_TRATYP_FE) THEN      !FE
C
	   CALL DFE(PRO(INPTAB,BUF),TRABUF)
C
	ELSEIF(XLAYER.EQ.X2X_TRATYP_STTN) THEN    !STATION
C
	   CALL DSTN(PRO(INPTAB,BUF),TRABUF)
C
	ELSEIF(XLAYER.EQ.X2X_TRATYP_GLO) THEN     !GLOBAL
C
           TRABUF(TSDT5)=PRO(CDT3,BUF)
           TRABUF(TSDT6)=PRO(CDT4,BUF)
	   CALL DGLO(PRO(INPTAB,BUF),TRABUF)
C
	ELSE
C
	   TRABUF(TERR) =XERR
	   TRABUF(TSTAT)=REJT
	   TRABUF(TXPTL)=X2ERR_LAY              !WRONG XLAYER
C
C OTHERWISE TXPTL IS SET TO XCODE OR IS SET BY US.
C
	ENDIF  !TRANSACTION READ  D
C
C NOW PRINT IT ON THE CONSOLE.
C BE SELECTIVE. USE TRABUF(TXPTL) TO DETERMINE IF AND HOW TO PRINT.
C USE X2X_PRINT_...  TABLES TO MAKE THE DECISION.
C X2X_PRINT_MSG IS GLOBAL FOR DATA/ERROR AND TRANSP/SAP/STATION MESSAGES
C WITH GOOD STATUS SO WE COULD USE X2PRINT HERE AND IN COMMAND PROCESSING.
C INDEX INTO X2X FILE IS SET.
C
C NOTE: THE BACKWARD INDEX IS DEFAULTED TO STATION; HOWEVER, IF
C LOGGING A TERMINAL MESSAGE BY UTILIZING THE GLOBAL PROTOCOL LAYER,
C THE BACKWARD INDEX WILL BE REPLACED WITH THE TERMINAL BACKWARD INDEX
C IN PROXGLO.
C
	IF (LOG_MESSAGE) THEN
	    TRABUF(TXIDX)=P(X2XIDX)+1
	    IF(TRABUF(TXIDX).GT.MAXPTL) THEN
		TRABUF(TXIDX)=1
		X2XPRO_ROUND_ROBIN=1
	    ENDIF
	    IF(STATION.GE.1.AND.STATION.LE.X2X_STATIONS) THEN
		TRABUF(TXBAK)=X2XS_ALARM_INDEX(STATION)
	    ENDIF
	ENDIF
C
C**   TYPE*,'DECODED TRABUF ',TRABUF
C
	CALL X2PRINT(TRABUF)
C
C LOG IT IN YOUR OWN FILE. PUT IN THE BUFFER WHAT YOU DON'T PUT IN THE
C WRKTAB (BASICALLY RAW MESSAGE).
C
	DIR=XLOG_DIR_IN
C
C NOTE: IF CAME ON THE GLOBAL PROTOCOL LEVEL, AND THE
C PTL CODE IS A TRACE, SET THE DIRECTION ACCORDING TO
C THE PTL NUMBER.
C
	IF(XLAYER.EQ.X2X_TRATYP_GLO) THEN
	  IF(TRABUF(TXPTL).EQ.X2ERR_GLO_TRACE_TER_INP) THEN
	    DIR=XLOG_DIR_IN
	    TRABUF(TXBAK)=X2XT_TRACE_INDEX(TER)
	    X2XT_TRACE_INDEX(TER)=TRABUF(TXIDX)
	   ELSEIF(TRABUF(TXPTL).EQ.X2ERR_GLO_TRACE_TER_OUT) THEN
	    DIR=XLOG_DIR_OUT
	    TRABUF(TXBAK)=X2XT_TRACE_INDEX(TER)
	    X2XT_TRACE_INDEX(TER)=TRABUF(TXIDX)
	  ENDIF
	ENDIF
C
C SET BACKLINK, BEFORE BUFFER IS LOGGED TO DISK
C
	IF(TRABUF(TXPTL).EQ.X2ERR_BADADR .OR.
     *	   TRABUF(TXPTL).EQ.X2ERR_INV_STN_PROTOCOL) THEN
  	    TRABUF(TXBAK)=X2XS_BAD_ADRESS
	    X2XS_BAD_ADRESS=TRABUF(TXIDX)
	ENDIF
C
C WRITE THE BUFFER TO THE X2X FILE.
C
	IF (LOG_MESSAGE) THEN
	    CALL XTOLOG(TRABUF,PRO(INPTAB,BUF),BUFFER,DIR,HPRO(INPLEN,BUF))
	    CALL X2FWRITE(BUFFER,TRABUF(TXIDX),STATUS)!LOG TO HIGHER INDEX
C
C REMEMBER THAT P(X2XIDX) = LAST WRITTEN INDEX, SO DONT INCREASE IT
C BEFORE YOU CALL X2FWRITE; IT RELIES ON IT.
C
	    P(X2XIDX)=TRABUF(TXIDX)
	ENDIF
C
        IF (X2X_GAME_MODE.EQ.X2X_GAMEM_DAY) THEN
           CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
           CALL WLOG(PRO(SERIAL,BUF),PRO(WRKTAB,BUF),TASK)
D	   TYPE*,'TM TRANSACTION   ',PRO(SERIAL,BUF)
D	   CALL DMPHEX(PRO(WRKTAB,BUF),16*4)
        ENDIF
C
C PROCESS TRANSACTION.
C PREPARE OUTPUT IF THERE IS ONE.
C SWITCH ON XTYPE AGAIN.
C
	RESPOND=.FALSE.
C
	IF(TRABUF(TSTAT).EQ.GOOD) THEN        !IT'S A GOOD COMMAND
C
	   CALL X2XEXEC(TRABUF)  !EXECUTE ACTION
C                              ;WHICH HAS TO BE REPROCESSED (IF THERE IS ANY)
C                              ;PROBABLY NOTHING FOR NOW
C
C PREPARE THE REQUIRED OUTPUT AND EXECUTE ACTION WHICH HAS AN ON-LINE
C SIGNIFICANCE AND IS NOT TO BE REPROCESSED.
C
	   IF(XLAYER.EQ.X2X_TRATYP_GLO) THEN      !GLO
C
	      CALL PROXGLO(TRABUF,BUF,BUFFER(XLOG_MES),
     *	                   RESPOND,HPRO(OUTLEN,BUF),BUF)
C
	   ELSEIF(XLAYER.EQ.X2X_TRATYP_XPORT) THEN  !GTP
C
	      CALL PROXGTP(TRABUF,PRO(OUTTAB,BUF),BUFFER(XLOG_MES),
     *	                   RESPOND,HPRO(OUTLEN,BUF),BUF)
C
	   ELSEIF(XLAYER.EQ.X2X_TRATYP_FE) THEN   !FE
C
	      CALL PROXFE(TRABUF,PRO(OUTTAB,BUF),BUFFER(XLOG_MES),
     *	                  RESPOND,HPRO(OUTLEN,BUF),BUF)
C
	   ELSEIF(XLAYER.EQ.X2X_TRATYP_STTN) THEN  !STATION
C
	      CALL PROXSTN(TRABUF,PRO(OUTTAB,BUF),BUFFER(XLOG_MES),
     *	                   RESPOND,HPRO(OUTLEN,BUF),BUF)
C
	   ELSE
	      CALL OPS('**** ILLEGAL LAYER ****',TRABUF(TSER),LAYER)
	   ENDIF
C
C X2X-LOG THE OUTPUT MESSAGE TOO; FOR DIAGNOSTICS; LATER SHOULD BE REMOVED
C
C
C IT MAY BE POSSIBLE FOR HPRO(OUTLEN,BUF) TO BE NEGATIVE FROM ONE OF THE
C ABOVE ROUTINES                               
C
           IF(HPRO(OUTLEN,BUF) .LE. 0) THEN
	     TRABUF(TERR) = XERR
	     TRABUF(TSTAT)= REJT
             RESPOND = .FALSE.
           ENDIF
C
	   IF(RESPOND .AND. LOG_MESSAGE) THEN
	      TRABUF(TXIDX)=P(X2XIDX)+1
C
	      DIR=XLOG_DIR_OUT
	      CALL XTOLOG(TRABUF,PRO(OUTTAB,BUF),BUFFER,DIR,
     *	                  HPRO(OUTLEN,BUF))
	      CALL X2FWRITE(BUFFER,TRABUF(TXIDX),STATUS)!LOG TO HIGHER INDEX
	      P(X2XIDX)=TRABUF(TXIDX)                   !THEN INCREASE IT
	   ENDIF
C
	ENDIF
C
C QUEUE TRANSACTION TO LOGGER OUTPUT QUEUE.
C IF RESPOND FLAG IS NOT SET X2XMGR WILL REALEASE THE BUFFER.
C LOGGER SHOULD ONLY SEND THOSE TO COMMUNICATIONS WHICH HAVE
C THE DESTINATION BITS SET AS NEEDED
C
	IF(.NOT.RESPOND) THEN
	   HPRO(X2X_DEST,BUF)=IOR(X2DEST_RELEASE,HPRO(X2X_DEST,BUF))
	ENDIF
C
D     TYPE*,'OUTPUT MESSAGE SENT OUT OF LENGTH ',HPRO(OUTLEN,BUF)
D	1   ,' BUF ',BUF
D     CALL DMPHEX(PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
C
C IF THE TRANSACTION IS A RELAY BUFFER, REQUEUE IT TO
C X2XREL TASK FOR PROCESSING.
C
        IF (X2X_GAME_MODE.EQ.X2X_GAMEM_DAY) THEN
          IF(HPRO(TRCODE,BUF).EQ.TYPX2X_RELAY_DELACK .OR.
     *       HPRO(TRCODE,BUF).EQ.TYPX2X_RELAY_DELERR .OR.
     *       HPRO(TRCODE,BUF).EQ.TYPX2X_RELAY) THEN
             CALL X2RADDBF(BUF)
          ELSE
            CALL QUETRA(LOG,BUF)
          ENDIF
        ELSEIF (X2X_GAME_MODE.EQ.X2X_GAMEM_NIGHT) THEN
          CALL X2ADDPRO(BUF)
        ELSE
           CALL OPS(' INVALID GAME MODE ',X2X_GAME_MODE,0)
        ENDIF
        CALL DQUTRA(TASK,BUF)
C
	GOTO 20
	END
