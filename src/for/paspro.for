C
C PASPRO.FOR
C
C V05 30-SEP-2010 FJG Minor bugs with SUPR
C V04 23-APR-2010 RXK Reprocessing subroutine REPPRO_PAS separated
C V03 31-MAR-2010 RXK Changes for ePassive
C                 FJG PASIOSUBS inclussion
C V02 12-FEB-2001 UXN WAIT_APUQUE added. TYPE* REPLACED WITH OPSTXT()
C V01 14-DEC-00   CS  INITIAL RELEASE FOR PORTUGAL
C
C PASSIVE UNSOLD TICKETS PROCESSING TASK
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode Island,
C and contains confidential and trade secret information. It may not be
C transferred from the custody or control of GTECH except as authorized in
C writing by an officer of GTECH. Neither this item nor the information it
C contains may be used, transferred, reproduced, published, or disclosed,
C in whole or in part, and directly or indirectly, except as expressly
C authorized by an officer of GTECH, pursuant to written agreement.
C
C Copyright 1993 GTECH Corporation. All rights reserved.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM PASPRO
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:QUECOM.DEF'
	INCLUDE 'INCLIB:PRMLOG.DEF'
	INCLUDE 'INCLIB:AGTCOM.DEF'
	INCLUDE 'INCLIB:PASCOM.DEF'
        INCLUDE 'INCLIB:CHKSUMCM.DEF'
        INCLUDE 'INCLIB:PASIOSUBS.DEF'
C
C LOCAL VARIABLES
C
	INTEGER*4 TASK,MESS(EDLEN),ST,STAT
	INTEGER*4 LBUF(LREC*3)
        INTEGER*4 TER,TYPE,BUF,OFFSET
	INTEGER*4 DUMMY,LSTSUP,ACTSUP,ERCODE
	INTEGER*4 LSTSER,LASTRA(TRALEN),STATUS,GAME,AGAME
        INTEGER*4 WRKBUF(TRALEN)  
        INTEGER*4 QUEFLAG
        INTEGER*4 I

        INTEGER*4 MAXAVAILABLE(PMAXSAL,NUMPAS)
        COMMON /MAXAVAIL/ MAXAVAILABLE
!
!===============================================================================
!       THIS SHOULD BE INCLUDED IN SUBRUTINES THAT USES TPFS
!===============================================================================
        record /stpasfdb/  pasfdb(pagemi,numpas)
        common /pastruct/ pasfdb        
!===============================================================================        
C
        LOGICAL    SYNTERR

	INTEGER*4 DAY_SUSPENDED
	PARAMETER (DAY_SUSPENDED = 1)	
	DATA LSTSUP/1/
	DATA ACTSUP/1/
C
C
	CALL COPYRITE
	CALL SNIF_AND_WRKSET
C
C IDENTIFY THIS TASK
C
	TASK    = PST
	MESS(1) = PST
5	CONTINUE
	BASECHKSUM=IAND(DAYCDC,'FFFF'X)
C
10      CONTINUE
        IF(DAYSTS.EQ.DSCLOS) THEN
          CALL LISTTOP(DUMMY,REPQUEPAS(1,RQPASPRO),ST)
          IF(ST.EQ.GLIST_STAT_EMPTY) CALL GSTOP(GEXIT_SUCCESS)
        ENDIF
C
        IF(DAYSTS.EQ.DSSUSP) THEN
          CALL CLSIDX
          LSTSUP=DAY_SUSPENDED
20        CONTINUE
          CALL HOLD(0,ST)
          IF(DAYSTS.EQ.DSOPEN) GOTO 5
          IF(DAYSTS.EQ.DSCLOS) CALL GSTOP(GEXIT_SUCCESS)
          GOTO 20
        ENDIF
        CALL HOLD(0,ST)

30      CONTINUE
        ACTSUP = MIN(P(SUPWAG),P(SUPCAN),P(SUPRET))
        IF(ACTSUP.NE.LSTSUP) THEN
          IF(ACTSUP.EQ.0) THEN
            LSTSUP=ACTSUP
            CALL OPNIDX
            CALL GETMAXAVAIL
          ELSE
            CALL LISTTOP(DUMMY,REPQUEPAS(1,RQPASPRO),ST)
            IF(ST.EQ.GLIST_STAT_EMPTY) THEN
              LSTSUP=ACTSUP
              CALL CLSIDX
            ENDIF
          ENDIF
        ENDIF

        CALL TOPQUE(TASK,BUF)
        CALL REPPAS(STAT,LSTSUP)
        IF(BUF.LE.0.AND.STAT.NE.0) GOTO 10
        IF(BUF.LE.0) GOTO 30
C
C BUILD TRANSACTION
C
	CALL FASTSET(0,TRABUF,TRALEN)

	TER  = HPRO(TERNUM,BUF)
	TYPE = HPRO(TRCODE,BUF)
        IF(TYPE.EQ.TYPEPC.OR.TYPE.EQ.TYPEPD) GOTO 1000 

	TRABUF(TSTAT) = GOOD
	TRABUF(TERR)  = NOER
        TRABUF(TTYP)  = TWAG
	TRABUF(TTER)  = TER
	TRABUF(TAGT)  = AGTTAB(AGTNUM,TER)
	TRABUF(TCDC)  = DAYCDC
        TRABUF(TCDC_SOLD) = DAYCDC
	TRABUF(TSER)  = PRO(SERIAL,BUF)
	TRABUF(TTIM)  = PRO(TSTAMP,BUF)
	TRABUF(TSIZE) = HPRO(NUMLRC,BUF)
C
C CHECK LONG QUEUE FLAG: THRESHOLD
C
        QUEFLAG = PRO(WRKTAB,BUF)
        IF(QUEFLAG.NE.0) THEN
           TRABUF(TTYP)  = TRET
           TRABUF(TSTAT) = REJT
           TRABUF(TERR)  = SUPR
           TRABUF(TGAMTYP) = TPAS
           TRABUF(TGAMIND) = ISHFT(ZEXT(BPRO(BINPTAB+5,BUF)),-4) 
           TRABUF(TTRN)    = IAND(ZEXT(BPRO(BINPTAB,BUF)),15)
           GOTO 85
        ENDIF 
C
C DECODE MESSAGE FORMAT
C
        SYNTERR  = .FALSE.
	CALL DPAS(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
        IF(TRABUF(TERR).NE.NOER) SYNTERR=.TRUE.
C
C CHECK AGENT AND SYSTEM STATUS
C
        GAME  = TRABUF(TGAM)
        IF(TRABUF(TTYP).EQ.TWAG) THEN
           AGAME = 0
           IF(GAME.NE.0) AGAME=AGTGAM(GFLAGS,GAME,TER)
           IF(TSBIT(AGTTAB(AGTTYP,TER),AGTWAG)) TRABUF(TERR)=SUPR
           IF(TSBIT(AGAME,AGTWAG))              TRABUF(TERR)=SUPR
           IF(TSBIT(P(SUPGWA),GAME))            TRABUF(TERR)=SUPR
           IF(P(SUPWAG).NE.0)                   TRABUF(TERR)=SUPR
C
C PRIVILEGED TERMINALS CAN NOT WAGER
C
           IF(TSBIT(AGTTAB(AGTTYP,TER),AGTPRV)) TRABUF(TERR) = SUPR
C
        ELSEIF(TRABUF(TTYP).EQ.TRET) THEN

           IF(P(SUPRET).NE.0)                   TRABUF(TERR)=SUPR
           IF(TSBIT(P(SUPGRE),GAME))            TRABUF(TERR)=SUPR  

        ENDIF  

	IF(AGTHTB(AOPSTS,TER).NE.SIGNON)        TRABUF(TERR)=NOTON

        IF( TRABUF(TTYP).EQ.TRET .AND.
     *      (BTEST(AGTTAB(AGTTYP,TER),AGTTRN)) ) TRABUF(TERR)=TRIN

	IF(P(SYSSTS).EQ.SYSDRW)                 TRABUF(TERR) = SDRW
	IF(P(SYSSTS).EQ.SYSDOR)                 TRABUF(TERR) = SDOR

	IF(TRABUF(TERR).NE.NOER)                TRABUF(TSTAT)= REJT
C
C RETRY PROCESSING OF PPASSIVE RETURNS
C
        LSTSER = AGTTAB(ALSTRA,TER)
        IF(LSTSER.EQ.0) GOTO 80
        IF(HPRO(SIMMOD,BUF).EQ.-999) GOTO 80    !NO RETRIES FOR SIM

	IF(TRABUF(TTYP).EQ.TRET) THEN 
	    IF(TRABUF(TTRN).EQ.AGTHTB(ATRNUM,TER)) THEN
		CALL RLOG(LSTSER,LBUF,TASK,STATUS)
CV02
		IF(STATUS.NE.0) THEN
		   CALL WAIT_APUQUE
		   CALL RLOG(LSTSER,LBUF,TASK,STATUS)
	        ENDIF
CEV02
		IF(STATUS.EQ.0) THEN
		    CALL LOGTRA(LASTRA,LBUF)

		    IF( (LASTRA(TTYP).EQ.TWAG) .AND.
     *		        (LASTRA(TTRN).EQ.TRABUF(TTRN)) .AND.
     *			(LASTRA(TGAM).EQ.TRABUF(TGAM)) .AND.
     *			(LASTRA(TPEMIS1).EQ.TRABUF(TPEMIS1)) .AND.
     *			(LASTRA(TPKEY1).EQ.TRABUF(TPKEY1)) .AND.
     *		        (LASTRA(TSTAT).EQ.TRABUF(TSTAT)) ) THEN

			TRABUF(TSTAT) = REJT
			TRABUF(TERR)  = RETY

			DO OFFSET=TPTCK,TRALEN
			    TRABUF(OFFSET)=LASTRA(OFFSET)
			ENDDO

			CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
			CALL OUTPAS(LASTRA,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
			GOTO 100
		    ENDIF
		ENDIF
	    ENDIF  ! end of retry of a return transaction
C
C RETRY OF EPASSIVE WAGER
C 
        ELSE
          IF(TRABUF(TWEPOP).EQ.EPASSAL) THEN
C
C IF TERMINAL RETRY, AND TRANSACTION STATUS IS GOOD, AND
C TRANSACTION SEQUENCE NUMBER MATCHES THE LAST SEQUENCE
C NUMBER FOR THIS TERMINAL, CONTINUE RETRY PROCESSING, ELSE
C PROCESS AS NORMAL.
C
            IF(TRABUF(TTRN).EQ.AGTHTB(ATRNUM,TER)) THEN
              IF(TRABUF(TCHK).NE.ZEXT(AGTHTB(ACHKSM,TER)) .OR. SYNTERR) THEN

                 CALL RLOG(LSTSER,LBUF,TASK,ST)
                 IF (ST.NE.0) THEN
                    CALL WAIT_APUQUE
                    CALL RLOG(LSTSER,LBUF,TASK,ST)
                 ENDIF
                 IF(ST.NE.0) GOTO 80

                 CALL LOGTRA(WRKBUF,LBUF)
                 IF(WRKBUF(TSTAT).NE.GOOD)          GOTO 80
                 IF(WRKBUF(TTYP).NE.TWAG)           GOTO 80
                 IF(WRKBUF(TCHK).NE.TRABUF(TCHK))   GOTO 80
                 IF(WRKBUF(TTRN).NE.TRABUF(TTRN))   GOTO 80
                 IF(WRKBUF(TGAM).NE.TRABUF(TGAM))   GOTO 80
                 IF(WRKBUF(TWAMT).NE.TRABUF(TWAMT)) GOTO 80
                 DO I=TWEPOP,TWEPSF
                    IF(WRKBUF(I).NE.TRABUF(I))      GOTO 80
                 ENDDO
              ENDIF

              TRABUF(TSTAT) = REJT
              TRABUF(TERR ) = RETY
              TRABUF(TWEPSD)= AGTTAB(AGTEPS,TER)

              CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
              TRABUF(TSER)  = AGTTAB(ALSTRA,TER)
              TRABUF(TSTAT) = GOOD
              CALL OUTPAS(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
              GOTO 90
            ENDIF  !end of retry of a wager 
          ENDIF
	ENDIF
C
C UPDATE FINANCIAL INFORMATION AND QUEUE TRANSACTION TO LOGGER OUTPUT QUEUE
C
80      CONTINUE
	IF(TRABUF(TTYP).EQ.TRET.AND.TRABUF(TSTAT).EQ.GOOD) CALL PROUPD_PAS(TRABUF)	    
        IF(TRABUF(TTYP).EQ.TWAG.AND.TRABUF(TSTAT).EQ.GOOD) CALL UPDPAS(TRABUF)  
	IF(TRABUF(TSTAT).EQ.GOOD) THEN
           IF(TRABUF(TTYP).EQ.TWAG.AND.TRABUF(TWEPOP).EQ.EPASSAL.OR.
     *        TRABUF(TTYP).EQ.TRET) THEN
     	      IF(TRABUF(TSTAT).EQ.GOOD) CALL UPDSUB(TRABUF)
              PERFRM(1,GAME)=PERFRM(1,GAME)+1
	   ENDIF
	ENDIF
85      CONTINUE
	CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
C
C SEND MESSAGE BACK TO TERMINAL
C
	CALL OUTPAS(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
C
C QUEUE TRANSACTION TO LOGGER OUTPUT QUEUE
C
90      CONTINUE
        AGTHTB(ATRNUM,TER) = TRABUF(TTRN)
        IF(TRABUF(TSTAT).NE.GOOD.AND.TRABUF(TERR).NE.RETY) THEN
            AGTHTB(ACHKSM,TER)=-1
        ELSE
            AGTHTB(ACHKSM,TER)=TRABUF(TCHK)
        ENDIF
C
C SEND BUFFER TO APULOG( MEMORY UPDATES AND REQUEUEING TO LOGGER )
C AND TAKE IT OUT OF THIS TASK'S QUEUE
C
100	CONTINUE
	AGTHTB(ATRNUM,TER)=TRABUF(TTRN)
        IF(TRABUF(TSTAT).NE.GOOD.AND.TRABUF(TERR).NE.RETY) THEN
            AGTHTB(ACHKSM,TER)=-1
        ELSE
            AGTHTB(ACHKSM,TER)=TRABUF(TCHK)
        ENDIF
	CALL QUETRA(APU,BUF)
	CALL DQUTRA(TASK,BUF)
C
C IF SYNTAX ERROR THEN PRINT MESSAGE ON CONSOLE
C
	IF(P(SUPSYN).EQ.0.AND.SYNTERRCOD.NE.0.AND.
     *    TRABUF(TERR).NE.NOTON) THEN
	  MESS(2)=TEGEN
	  MESS(3)=10
	  MESS(4)=SYNTERRCOD
	  MESS(5)=TER
	  MESS(6)=TRABUF(TGAMTYP)
	  MESS(7)=TRABUF(TGAMIND)
	  MESS(8)=TRABUF(TSER)
	  CALL QUEMES(MESS)
	ENDIF
C
	GOTO 30
C
C
C PROCESS EPASSIVE CANCELLATIONS AND DELETIONS.
C CANCELLATION AND WAGER ARE ENCODED IN THE WORK
C AREA OF THE PROCOM BUFFER (FROM CANPRO/INCPRO).
C UPDATE SALES DATA FOR EPASSIVE CANCELLATIONS 
C AND GET BACK TO TABLES PREVIOUSLY SOLD NUMBER
C
1000    CONTINUE
        CALL LOGTRA(TRABUF,PRO(WRKTAB,BUF))
C
        IF(TRABUF(TTYP).EQ.TINC) THEN
           AGTHTB(ATRNUM,TER)=-1             ! no retries for internal cancels
        ELSE
           AGTHTB(ATRNUM,TER)=TRABUF(TTRN)
        ENDIF
        AGTHTB(ACHKSM,TER)=-1

        TERMCHKSUM = TRABUF(TCHK)
        ERCODE     = TRABUF(TSUBERR) ! carry ERCODE from 1st phase transaction.

        IF(TRABUF(TSTAT).EQ.REJT) GOTO 1100

        CALL RLOG(TRABUF(TWCSER),LBUF,TASK,STATUS)
        IF (STATUS.NE.0) THEN
            CALL WAIT_APUQUE
            CALL RLOG(TRABUF(TWCSER),LBUF,TASK,STATUS)
        ENDIF

        CALL LOGTRA(WRKBUF,LBUF)
        IF(STATUS.NE.0.OR.WRKBUF(TSER).NE.TRABUF(TWCSER).OR.
     *     WRKBUF(TSTAT).NE.GOOD) THEN
            TRABUF(TSTAT)=REJT
            TRABUF(TERR)=INVL
            CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
            ERCODE=1
        ELSE
            CALL UPDPAS(TRABUF)    
            IF(TRABUF(TSTAT).EQ.REJT) THEN
               CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
               IF(TRABUF(TERR).EQ.EPNR) THEN
                  ERCODE=5
               ELSE  
                  ERCODE=6
               ENDIF  
            ELSE
               WRKBUF(TSTAT)=VOID
               IF(TRABUF(TTYP).EQ.TINC) WRKBUF(TSTAT)=INCA
               WRKBUF(TWCSER)=TRABUF(TSER)
               WRKBUF(TWCTER)=TRABUF(TTER)
               CALL TRALOG(WRKBUF,LBUF)
               CALL UPDSUB(TRABUF)
               CALL WLOG(WRKBUF(TSER),LBUF,TASK)
               ERCODE=0
           ENDIF
        ENDIF
C
1100    CONTINUE
C
        IF(TRABUF(TTYP).EQ.TCAN) THEN
           CALL OUTCAN(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF),ERCODE)
        ELSE
           CALL OUTDEL(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
        ENDIF

        HPRO(TRCODE,BUF)=TYPREG
        CALL QUETRA(APU, BUF)
        CALL DQUTRA(TASK,BUF)

        GOTO 30
        END           
