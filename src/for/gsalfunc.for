C
C     FILE   : GSALFUNC.FOR
C     AUTHOR : J.H.R
C     VERSION: 01            DATE: 09 / 02 / 2001
C
C
C V03 31-JAN-2012 FRP Set amounts to F11.2 in DSP_TOTSAL_INFO
C V02 11-MAR-2010 RXK CLAIMS REPLACED WITH RETURNS
C V01 JHR INITIAL RELEASE FOR PORTUGAL PROJECT
C
C SUBROUTINES AND FUNCTIONS EFINITION USED FOR GSALES PROCEDURES / TASKS
C
C     **************************************************************************
C
C        THIS ITEM IS THE PROPERTY OF GTECH CORPORATION, POVIDENCE, RHODE
C     ISLAND, AND CONTAINS CONFIDENTIAL AND TRADE SECRET INFORMATION. IT MAY
C     NOT BE TRANSFERRED FROM THE CUSTODY OR CONTROL OF GTECH EXCEPT AS AUTO -
C     RIZED IN WRITING BY AN OFFICER OF GTECH. NEITHER THIS ITEM NOR THE
C     INFORMATION IT CONTAINS MAY BE USED, TRANSFERRED, REPRODUCED, PUBLISHED
C     OR DISCLOSED, IN WHOLE OR IN PART, AND DIRECTLY OR INDIRECTLY, EXCEPT AS
C     EXPRESSLY AUTHORIZED BY AN OFFICER OR GTECH, PURSUANT TO WRITTEN AGREEMENT
C
C     Copyright 2000 GTECH Corporation. All Rigth Reserved
C
C     **************************************************************************
C
C FUNCTION TO GET ACTUAL SYSTEM DATE - HOUR ( SET IT IN OUTPUT FORMAT ) 
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      CHARACTER * 17 FUNCTION GET_ACT_DATE_HOUR
      IMPLICIT NONE
C
C VARIABLES DEFINITION TO SET ACTUAL DATE HOUR
C
      INTEGER * 4 ACTHOUR(2)        ! ACTUAL HOUR
      INTEGER * 4 ACTDATE(3)        ! ACTUAL DATE
C
      CHARACTER * 17 OUTDATEHOUR    ! OUTPUT DATE HOUR FORMAT
C
C GET ACTUAL SYSTEM DATE HOUR AND SET IN OUTPUT FORMAT
C
      CALL ICLOCK(1, ACTHOUR)
      CALL XDAT(ACTDATE)
      WRITE(OUTDATEHOUR, 100) ACTDATE(3), ACTDATE(2), ACTDATE(1), ACTHOUR
C
C WRITE DATE - HOUR TO RETURN FUNCTION
C
      GET_ACT_DATE_HOUR = OUTDATEHOUR
C
C FORMATS DEFINITION TO SET ACTUAL DATE HOUR
C
100   FORMAT(I2.2, '/', I2.2, '/', I2.2, ' ', 2A4)
C
C THIS IS THE END TO SET ACTUAL DATE HOUR
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_YYYYMMDD_CDC
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET CDC DATE IN YYYYMMDD FORMAT
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      CHARACTER * 8 FUNCTION GET_YYYYMMDD_CDC(IMPCDC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET CDC DATE IN YYYYMMDD FORMAT
C
      INCLUDE 'INCLIB:DATBUF.DEF'
C
C PARAMETERS DEFINION TO GET CDC DATE IN YYYYMMDD FORMAT
C
      INTEGER * 4 IMPCDC            ! IMPUT CDC
C
C VARIABLES DEFINITION TO GET CDC DATE IN YYYYMMDD FORMAT
C
      INTEGER * 2 DATE(12)          ! DATE ARRAY
C
      CHARACTER * 8 OUTDATE         ! OUTPUT DATE IN YYYYMMDD FORMAT
C
C SET CDC DATE IN DAY, MONTH, YEAR VALUES
C
      DATE(VCDC) = IMPCDC
      CALL CDATE(DATE)
      IF(DATE(VYEAR) .GT. 77) THEN
        DATE(VYEAR) = DATE(VYEAR) + 1900
      ELSE
        DATE(VYEAR) = DATE(VYEAR) + 2000
      ENDIF
C
C WRITE CDC DATE IN YYYYMMDD OUTPUT FORMAT
C
      WRITE(OUTDATE, 100) DATE(VYEAR), DATE(VMON), DATE(VDAY) 
C
C WRITE FORMATED DATE TO RETURN FUNCTION
C
      GET_YYYYMMDD_CDC = OUTDATE      
C
C FORMATS DEFINITION TO GET CDC DATE IN YYYYMMDD FORMAT
C
100   FORMAT(I4.4, I2.2, I2.2)
C
C THIS IS THE END TO GET CDC DATE IN YYYYMMDD FORMAT
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_JULIAN_CDC
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET JULIAN VALUE STARTING FROM CDC VALUE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_JULIAN_CDC(IMPCDC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET JULIAN VALUE STARTING FROM CDC
C
      INCLUDE 'INCLIB:DATBUF.DEF'
C
C PARAMETERS DEFINION TO GET JULIAN VALUE STARTING FROM CDC
C
      INTEGER * 4 IMPCDC            ! IMPUT CDC
C
C VARIABLES DEFINITION TO GET JULIAN VALUE STARTING FROM CDC
C
      INTEGER * 2 DATE(12)          ! DATE ARRAY
C
C SET CDC DATE IN DATE ARRAY TO GET JULIAN
C
      DATE(VCDC) = IMPCDC
      CALL CDATE(DATE)
C
C WRITE JULIAN VALUE TO RETURN FUNCTION
C
      GET_JULIAN_CDC = DATE(VJUL)
C
C THIS IS THE END TO GET JULIAN VALUE STARTING FROM CDC
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_HHMMSS_TIME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET TIME IN HHMMSS FORMAT STARTING FROM TIME IN SECONDS
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      CHARACTER * 6 FUNCTION GET_HHMMSS_TIME(TIME)
      IMPLICIT NONE
C
C PARAMETER DEFINION TO GET TIME IN HHMMSS FORMAT STARTING FROM TIME IN SECONDS
C
      INTEGER * 4 TIME             ! IMPUT TIME IN SECONDS
C
      CHARACTER * 6 OUTTIME        ! OUTPUT TIME IN HHMMSS FORMAT
C
C VARIABLE DEFINITION TO GET TIME IN HHMMSS FORMAT STARTING FROM TIME IN SECONDS
C
      INTEGER * 4 SECONDS           ! SECONDS TIME
      INTEGER * 4 MINUTES           ! MINUTES TIME
      INTEGER * 4 HOURS             ! HOURS TIME
C
C SET HOURS TIME, MINUTES TIME AND SECONDS TIME
C
      HOURS = TIME / 3600
      MINUTES = MOD(TIME, 3600) / 60
      SECONDS = MOD(MOD(TIME, 3600), 60)
C
C WRITE TIME DATE IN HHMMSS OUTPUT FORMAT
C
      WRITE(OUTTIME, 100) HOURS, MINUTES, SECONDS 
C
C WRITE FORMATED TIME TO RETURN FUNCTION
C
      GET_HHMMSS_TIME = OUTTIME      
C
C FORMATS DEFINITION TO GET TIME IN HHMMSS FORMAT STARTING FROM TIME IN SECONDS
C
100   FORMAT(I2.2, I2.2, I2.2)
C
C THIS IS THE END TO GET TIME IN HHMMSS FORMAT STARTING FROM TIME IN SECONDS
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GSHEADER
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION DEFINITION TO WRITE HEADER IN GSALES FILES LOADERS
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GSHEADER(VERSION)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO WRITE HEADER IN GSALES FILES LOADERS
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:GSALES.DEF'
C
C PARAMETERS DEFINION TO WRITE GSALES HEADER
C
      INTEGER * 4 VERSION           ! HEADER VERSION
C
C VARIABLES DEFINITION TO WRITE GSALES HEADER
C
      INTEGER * 4 COIN              ! COIN USED ( 1 EUROS, 2 ESCUDOS )
C
C  GET CURRENCY COIN ( ALWAYS IN EUROS, PORTUGAL WILL WORK WITH EUROS )
C
      COIN = 1
C
C WRITE INFORMATION IN FILE REGISTER 
C
      WRITE(FILREC, 100) VERSION,                       ! VERSION
     *                   GET_YYYYMMDD_CDC(DAYCDC),      ! YYYYMMDD DATE
     *                   COIN,                          ! COIN ( EUROS )
     *                   GET_ACT_DATE_HOUR()            ! ACTUAL DATE - HOUR
      FILRECLNG = 4 + 8 + 2 + 17
C
C WRITE INFORMATION IN GSALES FILE
C
      WRITE(IDFIL, 200) FILREC(1:FILRECLNG)
C
C FORMATS DEFINITION TO WRITE HEADER IN GSALES FILES LOADERS
C
100   FORMAT(I4.4, A8, I2.2, A17)
200   FORMAT(A)
C
C THIS IS THE END TO WRITE HEADER IN GSALES FILES LOADERS
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GSFOOTER
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION DEFINITION TO WRITE FOOTER IN GSALES FILES LOADERS
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GSFOOTER
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO WRITE FOOTER IN GSALES FILES LOADERS
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:GSALES.DEF'
C
C WRITE INFORMATION IN FILE REGISTER 
C
      WRITE(FILREC, 100) 'EOF',                   ! CONSTANT PARAMETER
     *                    FILRECCNT,              ! NUMBER OF RECORDS WRITTEN
     *                    GET_ACT_DATE_HOUR()     ! ACTUAL DATE - HOUR
      FILRECLNG = 3 + 9 + 17
C
C WRITE INFORMATION IN GSALES FILE
C
      WRITE(IDFIL, 200) FILREC(1:FILRECLNG)
C
C FORMATS DEFINITION TO WRITE FOOTER IN GSALES FILES LOADERS
C
100   FORMAT(A3, I9.9, A17)
200   FORMAT(A)
C
C THIS IS THE END TO WRITE FOOTER IN GSALES FILES LOADERS
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_FREE_IDFIL
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET FREE IDENTIFICATION FILE NUMBER
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_FREE_IDFIL(CHECKIDFIL)
      IMPLICIT NONE
C
C INCLUDE DEFINITIONS TO GET FREE IDENTIFICATION FILE NUMBER
C
      INCLUDE '(LIB$ROUTINES)'
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO GET FREE IDENTIFICATION FILE NUMBER
C
      INTEGER * 4 CHECKIDFIL          ! CHECK IDFIL (0: NO, 1: YES )
C
C VARIABLES DEFINITION TO GET FREE IDENTIFICATION FILE NUMBER
C
      INTEGER * 4 FSTS                ! FUNCTION STATUS
      INTEGER * 4 IDFIL               ! IDENTIFICATION FILE
C
C GET FREE IDENTIFICATION FILE NUMBER
C
      FSTS = LIB$GET_LUN(IDFIL)
      IF(FSTS .EQ. 0 .OR. IDFIL .LE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Getting Identifiation File'
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C CHECK IDENTIFICATION FILE 
C
      IF(CHECKIDFIL .NE. 0 .AND. IDFIL .GT. 100) IDFIL = MOD(IDFIL, 100)
C
C WRITE FREE IDENTIFICATION FILE TO RETURN FUNCTION
C
       GET_FREE_IDFIL = IDFIL 
C
C THIS IS THE END TO GET FREE IDENTIFICATION FILE NUMBER
C
      END


C ******************************************************************************
C
C     SUBROUTINE: DELETE_FILE_NAME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO DELETE FILE THAT WE SET IN PARAMETER FUNCTION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE DELETE_FILE_NAME(FILENAME)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO DELETE FILE NAME
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO DELETE FILE NAME
C
      CHARACTER * (*) FILENAME            ! FILE NAME TO DELETE
C
C VARIABLES DEFINITION TO DELETE FILE NAME
C
      INTEGER * 4 FSTS                    ! FUNCTION STATUS
C
C IF FILENAME EXITS, DELETE IT
C
      CALL DFILX(FILENAME, 0, 0, FSTS)
      IF(FSTS. EQ. 4) FSTS = 0             ! IF FILE DON'T EXIST, NO PROBLEM
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Deleting File: ', FILENAME
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C THIS IS THE END TO DELETE FILE NAME
C
      END


C ******************************************************************************
C
C     SUBROUTINE: OPEN_FILE_NAME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO OPEN FILE THAT WE SET IN PARAMETER FUNCTION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE OPEN_FILE_NAME(IDFIL, FILENAME)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO OPEN FILE NAME
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO OPEN FILE NAME
C
      INTEGER * 4 IDFIL                   ! IDENTIFICATION FILE
C
      CHARACTER * (*) FILENAME            ! FILE NAME TO OPEN
C
C VARIABLES DEFINITION TO OPEN FILE NAME
C
      INTEGER * 4 FSTS                    ! FUNCTION STATUS
C
C OPEN FILE NAME ( NAME IT'S SET IN FUNCTION PARAMETER )
C
      OPEN(UNIT = IDFIL,
     *     FILE = FILENAME,
     *     IOSTAT = FSTS,
     *     FORM = 'FORMATTED',
     *     RECL = 2048,
     *     STATUS = 'NEW',
     *     RECORDTYPE = 'STREAM_CR')
C
C CHECK FOR OPEN FILE ERROR
C
      IF(FSTS .NE. 0)THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Opening File: ', FILENAME
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C THIS IS THE END TO OPEN FILE NAME
C
      END


C ******************************************************************************
C
C     SUBROUTINE: OPEN_SYS_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO OPEN SYSTEM FILE NAME
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE OPEN_SYS_FILE(SYSIDFIL, FILTYPE, FILE)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO OPEN SYSTEM FILE NAME
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:GSALES.DEF'
C
C PARAMETERS DEFINITION TO OPEN SYSTEM FILE NAME
C
      INTEGER * 4 SYSIDFIL     ! SYSTEM IDENTIFICATION FILE
      INTEGER * 4 FILTYPE      ! FILE TYPE ( 1: MTMF01.FIL FILE, 2: GAME FILE )
      INTEGER * 4 FILE         ! FILE TO OPEN
C
C VARIABLES DEFINITION TO OPEN SYSTEM FILE NAME
C
      INTEGER * 4 FSTS         ! FUNCTION STATUS
      INTEGER * 4 CNTA         ! COUNTER A
      INTEGER * 4 FILENAME(5)  ! FILE NAME
C
C OPEN TRANSACTION FILE NAME TYPE
C
      IF(FILTYPE .EQ. MTMFIL) THEN
        CALL FASTMOV(SFNAMES(1, FILE), FILENAME, 5)
        CALL OPENWY(SYSIDFIL, FILENAME, 0, 4, 0, FSTS)
        CALL TOPEN(SYSIDFIL)
      ENDIF
C
C OPEN DRAW FILE NAME
C
      IF(FILTYPE .EQ. GAMFIL .OR. FILTYPE .EQ. DAFFIL) THEN
        IF(FILTYPE .EQ. GAMFIL) CALL FASTMOV(GFNAMES(1, FILE), FILENAME, 5)
        IF(FILTYPE .EQ. DAFFIL) CALL FASTMOV(SFNAMES(1, FILE), FILENAME, 5)
        CALL OPENW(SYSIDFIL, FILENAME, 4, 0, 0, FSTS)
      ENDIF
C
C CHECK IF FILE NAME OPEN ERROR
C
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE 100, IAM(), (FILENAME(CNTA), CNTA = 1, 5)
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C FORMATS DEFINITION TO OPEN SYSTEM FILE NAME
C
100   FORMAT(X, A, 'Error Opening File: ', 5A4)
C
C THIS IS THE END TO OPEN SYSTEM FILE NAME
C
      END


C ******************************************************************************
C
C     SUBROUTINE: DSP_TOTSAL_INFO
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO DISPLAY TOTAL GSALES SALES ( COUNTER AND AMOUNTS )
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE DSP_TOTSAL_INFO(TITLE, POS)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO DISPLAY TOTAL GSALES SALES
C
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:GSALES.DEF'
C
C PARAMETERS DEFINITION TO DISPLAY TOTAL GSALES SALES
C
      INTEGER * 4 TITLE           ! TITLE TO DISPLAY WITH TOTAL SALES
      INTEGER * 4 POS             ! POSITION TO DISPLAY
C
C DISPLAY ALL INFORMATION TO USER ( COUNTER AND AMOUNTS )
C
        WRITE(6, 100) TITLE,
     *                IDNINT(TOTSAL(POS, 1)), TOTSAL(POS, 2),
     *                IDNINT(TOTSAL(POS, 3)), TOTSAL(POS, 4),
     *                IDNINT(TOTSAL(POS, 5)), TOTSAL(POS, 6),
     *                IDNINT(TOTSAL(POS, 7)), TOTSAL(POS, 8)       
C
C FORMATS DEFINITION TO DISPLAY TOTAL GSALES SALES
C
100   FORMAT(X, A4, 4(X, I7, X, F11.2))
C
C THIS IS THE END TO DISPLAY TOTAL GSALES SALES
C
       END


C ******************************************************************************
C
C     SUBROUTINE: UPDATE_TOTSAL_INFO
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 12 / 02 / 2001
C
C ******************************************************************************
C 
C FUNCTION TO UPDATE TOTAL GSALES SALES ( COUNTER AND AMOUNTS )
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE UPDATE_TOTSAL_INFO(GAME, TOTAMT, TRNTOTTCK)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO UPDATE TOTAL GSALES SALES
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:GSALES.DEF'
C
C PARAMETERS DEFINITION TO UPDATE TOTAL GSALES SALES
C
      INTEGER * 4 GAME                ! GAME NUMBER TO UPDATE
      INTEGER * 4 TOTAMT              ! TOTAL AMOUNT TO UPDATE
      INTEGER * 4 TRNTOTTCK           ! TRANSACTION TOTAL TICKETS COUNTER
C
C VARIABLES DEFINITION TO UPDATE TOTAL GSALES SALES
C
      INTEGER * 4 POS                 ! POSITION TO UPDATE COUNTER AND AMOUNT
C
C SET POSITION TO UDATE CONUNTERS AND AMOUNTS
C
      POS = TRNTYP * 2 - 1
      IF(TRNTYP .EQ. TRET) POS = (TRET  - 2) * 2 - 1
C
C UPDATE TOTAL COUNTER AND TOTAL AMOUNT
C
      TOTSAL(GAME, POS) = TOTSAL(GAME, POS) + DFLOAT(TRNTOTTCK)
      POS = POS + 1
      TOTSAL(GAME, POS) = TOTSAL(GAME, POS) + (DFLOAT(TOTAMT) / P(PRFACTOR))
C
C THIS IS THE END TO UPDATE TOTAL GSALES SALES
C
      END 


C ******************************************************************************
C
C     SUBROUTINE: READ_DRAW_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 13 / 02 / 2001
C
C ******************************************************************************
C 
C FUNCTION TO READ DRAW FILE INFORMATION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE READ_DRAW_FILE(DRAW, GNUM, FDB, FILEREC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO READ DRAW FILE INFORMATION
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
C
C PARAMETERS DEFINITION TO READ DRAW FILE INFORMATION
C
      INTEGER * 4 DRAW              ! DRAW NUMBER
      INTEGER * 4 GNUM              ! GAME NUMBER
      INTEGER * 4 FDB(*)            ! FILE DESCRIPTOR BLOCK
      INTEGER * 4 FILEREC(*)        ! FILE REGISTER
C
C VARIABLES DEFINITION TO READ DRAW FILE INFORMATION
C
      INTEGER * 4 CNTA              ! COUNTER A
      INTEGER * 4 FSTS              ! FUNCTION STATUS
C
C GET DRAW NUMBER AND READ FILE NAME FOR THIS DRAW NUMBER
C
      CALL READW(FDB, DRAW, FILEREC, FSTS)
C
C CHECK IF READ FILE ERROR
C
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE 100, IAM(), DRAW, (GFNAMES(CNTA, GNUM), CNTA = 1, 5)
        TYPE *, IAM()
        CALL GPAUSE 
      ENDIF
C
C FORMATS DEFINITION TO READ DRAW FILE INFORMATION
C
100   FORMAT(X, 'Error Reading Draw: ', I6.6, ' For File Name: ', 5A4)
C
C THIS IS THE END TO READ DRAW FILE INFORMATION
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_SANTA_CASA_DRW_NUM
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 13 / 02 / 2001
C
C ******************************************************************************
C 
C FUNCTION TO GET SANTA CASA DRAW NUMBER STARTING FROM INTERNAL DRAW NUMBER
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GET_SANTA_CASA_DRW_NUM(DRAWSCF, GNUM)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET SANTA CASA DRAW NUMBER
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
C
C PARAMETERS DEFINITION TO GET SANTA CASA DRAW NUMBER
C
      INTEGER * 4 DRAWSCF           ! DRAW SANTA CASA FORMAT
      INTEGER * 4 GNUM              ! GAME NUMBER
C
C VARIABLES DEFINITION TO GET SANTA CASA DRAW NUMBER
C
      INTEGER * 4 YEAR              ! DRAW YEAR
      INTEGER * 4 WEEK              ! DRAW WEEK
      INTEGER * 4 FSTS              ! FUNCTION STATUS
C
C GET DRAW YEAR / DRAW WEEK
C
      CALL GETWEK(DRAWSCF, GNUM, WEEK, YEAR, FSTS)
C
C CHEK IF ERROR GETTING DRAW YEAR / DRAW WEEK
C
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Getting Santa Casa Draw Number'
        TYPE *, IAM()
        CALL GPAUSE 
      ENDIF
C
C SET SANTA CASA DRAW NUMBER FORMAT
C
      DRAWSCF = WEEK * 10000 + YEAR 
C
C THIS IS THE END TO GET SANTA CASA DRAW NUMBER
C
      END


C ******************************************************************************
C
C     SUBROUTINE: CHECK_PASSIVE_STATUS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 16 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO CHECK IF VALIDATION STATUS IS OK OR NOT 
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      LOGICAL FUNCTION CHECK_PASSIVE_STATUS(TRABUF, TCKS)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO CHECK IF VALIDATION STATUS IS OK OR NOT
C
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:DESTRA.DEF'
C
C PRAMETERS DEFINITION TO CHECK IF VALIDATION STATUS IS OK OR NOT
C
      INTEGER * 4 TCKS             ! NUMBER OF TICKETS COUNTER
C
C VARIABLES DEFINITION TO TO CHECK IF VALIDATION STATUS IS OK OR NOT
C
      INTEGER * 4 WINSTS           ! WINNER STATUS      
C
C GET VALIDATION STATUS
C
      WINSTS = TRABUF(TPSTS1 + OFFTRA * (TCKS - 1))
C
C CHECK IF TRANSACTION IT'S WAGER AND STATUS IS RETURND
C
      IF(TRABUF(TTYP) .EQ. TRET .AND. WINSTS .EQ. RETURND) THEN
        CHECK_PASSIVE_STATUS = .TRUE.
        RETURN
      ENDIF
C
C CHECK IF TRANSACTION IT'S WAGER AND STATUS IS RETURND AFTHER DRAW
C
      IF(TRABUF(TTYP) .EQ. TRET .AND. WINSTS .EQ. RETAFDR) THEN
        CHECK_PASSIVE_STATUS = .TRUE.
        RETURN
      ENDIF
C
C CHECK IF TRANSACTION IT'S VALIDATION AND STATUS IS VWINNER
C
      IF(TRABUF(TTYP) .EQ. TVAL .AND. WINSTS .EQ. VWINNER) THEN
        CHECK_PASSIVE_STATUS = .TRUE.
        RETURN
      ENDIF
C
C TRANSACTION PASSIVE STATUS IS NOT OK
C
      CHECK_PASSIVE_STATUS = .FALSE.
      RETURN
C
C THIS IS THE END TO CHECK IF VALIDATION STATUS IS OK OR NOT
C
      END


C ******************************************************************************
C
C     SUBROUTINE: CREATE_GSALES_END_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 07 / 05 / 2001
C
C ******************************************************************************
C
C FUNCTION TO CREATE GSLAES END FILE ( EMPTY FILE WITH .FIN EXTENSION )
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE CREATE_GSALES_END_FILE(FILENAME)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO CREATE GSLAES END FILE
C
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:GSALES.DEF'
C
C PARAMETERS DEFINION TO CREATE GSLAES END FILE
C
      CHARACTER * (*) FILENAME        ! FILENAME TO CREATE
C
C VARIABLES DEFINITION TO CREATE GSLAES END FILE
C
      INTEGER * 4 IDFILE              ! IDENTIFICATION FILE                  
C
C DELETE ACTUAL END FILE FOR GSALES IF THIS FILE EXISTS
C
      CALL DELETE_FILE_NAME(FILENAME)
C
C GET FREE IDENTIFICATION FILE NUMBER
C
      IDFILE = GET_FREE_IDFIL(0)
C
C OPEN YYYYDDMM_xxxxxx.FIN FILE ( FILE TO DETERMINE END GSALES PROCEDURE )
C
      CALL OPEN_FILE_NAME(IDFILE, FILENAME)
C
C CLOSE YYYYDDMM_xxxxxx.FIN FILE
C
      CALL USRCLOS1(IDFILE)
C
C THIS IS THE END TO CREATE GSLAES END FILE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: PRNT_AMT
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 21 / 05 / 2001
C
C ******************************************************************************
C
C FUNCTION TO PRINT GSALES AMOUNT WITH DOT
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      CHARACTER * 12 FUNCTION PRNT_AMT(AMOUNT, DECIMALS)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO PRINT GSALES AMOUNT WITH DOT
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
C
C PARAMETERS DEFINITION TO PRINT GSALES AMOUNT WITH DOT
C
      INTEGER * 4 AMOUNT         ! AMOUNT TO PRINT
      INTEGER * 4 DECIMALS       ! NUMBER OF DECIMALS TO PRINT
C
C VARIABLES DEFINITION TO PRINT GSALES AMOUNT WITH DOT
C
      INTEGER * 4 ENTAMT         ! ENTIRE AMOUNT
      INTEGER * 4 DECAMT         ! DECIMAL AMOUNT
      INTEGER * 4 FACTOR         ! FACTOR OF CONVERSION    
C
C CHECK VALID NUMBER OF DECIMALS ( ONLY 2 OR 4 )
C
      IF(DECIMALS .NE. 2 .AND. DECIMALS .NE. 4) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Gsales Error: Number Of Decimals It Is Wrong'
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C SET FACTOR OF CONVERSION TO PRINT AMOUNTS
C
      FACTOR = P(PRFACTOR)
      IF(DECIMALS .EQ. 4) FACTOR = FACTOR * P(PRFACTOR)
C
C CALCULATE AMOUNT ( ENTIRE PART AND DECIMAL PART )
C
      ENTAMT = AMOUNT / FACTOR
      DECAMT = MOD(AMOUNT, FACTOR)
C
C PRINT AMOUNT WITH 2 DECIMALS
C
      IF(DECIMALS .EQ. 2) THEN
        WRITE(PRNT_AMT, 100) ENTAMT, DECAMT
        RETURN
      ENDIF
C
C PRINT AMOUNT WITH 4 DECIMALS
C
      IF(DECIMALS .EQ. 4) THEN
        WRITE(PRNT_AMT, 200) ENTAMT, DECAMT
        RETURN
      ENDIF
C
C FORMATS DEFINITION TO PRINT GSALES AMOUNT WITH DOT
C
100   FORMAT(I9.9, '.', I2.2)
200   FORMAT(I7.7, '.', I4.4)
C
C THIS IS THE END TO PRINT GSALES AMOUNT WITH DOT
C
      END

