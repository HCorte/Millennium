C MONGOLS.FOR
C
C V10 12-AUG-2011 RXK "Millennium" replaced with "ES Evolution"
C V09 14-JUL-2011 RXK  HANDLE THE SITUATION WHEN TASK IS HUNG
C                      (ELEMENTS ON THE QUEUE, COPIED FROM NIGERIA)
C V08 06-AUG-2000 UXN  TYPE* replaced with OPS(),OPSTXT().
C                      NOTPRO replaced with ELOG
C V07 10-FEB-2000 UXN  CALL CLOSE replaced with CLOSE()
C V06 07-JUL-1999 UXN  FTPPRO MONITORING REMOVED.
C V05 06-OCT-1995 WXM  PROJECT NAME ADDED AS THE FIRST PARAMETER
C V04 13-MAY-1994 WXM  INITIAL RELEASE FOR ESTONIA
C V03 22-FEB-1993 WLM  UPDATED TAPE SERIAL NUMBER BACK FOR 1600 DENSITY TAPE.
C V02 11-FEB-1992 GCAN UPDATED TAPE SERIAL NUMBER FOR 6250 DENSITY TAPE.
C V01 08-MAY-1990 XXX RELEASED FOR VAX
C
C
C GOLS SOFTWARE MONITORING PROC
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM MONGOLSPROC
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
        INCLUDE 'INCLIB:MONGOLS.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:CONCOM.DEF'
C
C
        INTEGER*4   ST, I, J, PROC_ID_REQUEST
	LOGICAL	    ALL_PROCESSES/.FALSE./
	CHARACTER*40  LOG_FILE 
	INTEGER*4   LUN,CFG,XLEN
	INTEGER*4   I4PREF,PRFX_LEN
	CHARACTER*80 PRFX,INPUT_LINE
	EQUIVALENCE (I4PREF,PRFX)
C
	CALL COPYRITE
C
C
	CALL SNIF_AND_WRKSET  !SET WORKING SET
C
	PROC_ID_REQUEST = -1
C
C	Delete log files older than 10 days.
C
	IF(DAYCDC.GT.10) THEN
	   WRITE(LOG_FILE,910) DAYCDC-10
	   CALL LIB$DELETE_FILE(LOG_FILE)
	ENDIF
	WRITE(LOG_FILE,900) DAYCDC
	LUN = 7	
	OPEN(UNIT=LUN, FILE=LOG_FILE, ACCESS='SEQUENTIAL', 
     *       STATUS='NEW')
	WRITE(LUN,*) IAM(),'MONGOLS started to monitor ES Evolution processes...'
C
C Read the configuration file MONGOLS.FIL
C
	CFG = 8
	OPEN(UNIT=CFG,FILE='MONGOLS.FIL',STATUS='OLD',IOSTAT=ST,SHARED)
	IF(ST.NE.0) THEN
	   CALL OPSTXT('Cannot open MONGOLS.FIL - using default values.')
	   WRITE(LUN,*) 'Cannot open MONGOLS.FIL - using default values.'
	ELSE
	   READ(UNIT=CFG,FMT='(A)',IOSTAT=ST) INPUT_LINE
	   DO WHILE(ST.EQ.0)
	     IF(INPUT_LINE(1:30).EQ.'LIM_PERCENT:..................') THEN
		LIM_PERCENT = CTOI(INPUT_LINE(31:40),XLEN)
	     ELSEIF(INPUT_LINE(1:30).EQ.'FREQUENCY:....................') THEN
		FREQUENCY = CTOI(INPUT_LINE(31:40),XLEN)
	     ELSEIF(INPUT_LINE(1:30).EQ.'PROC_ID_REQUEST...............') THEN
	        READ (INPUT_LINE(31:40),55) PROC_ID_REQUEST
55	        FORMAT(Z)
	     ENDIF
	     READ(UNIT=CFG,FMT='(A)',IOSTAT=ST) INPUT_LINE
	   ENDDO
	   CLOSE(UNIT=CFG)
	ENDIF  
C
C Get prefix
C
	CALL GETPRFX(I4PREF,PRFX_LEN)
C
	MON_PROJ_NAME = PRFX(1:PRFX_LEN)
C
	 IF (PROC_ID_REQUEST .EQ. -1) THEN
	   CALL OPSTXT('WILL MONITOR ALL PROCCESSES')
	   WRITE(LUN,*) IAM(),'WILL MONITOR ALL PROCCESSES'
	   ALL_PROCESSES = .TRUE.
	 ENDIF
C
	IF(FREQUENCY.LT.100) FREQUENCY = 100                            !V09   
	IF(LIM_PERCENT.LT.20.OR.LIM_PERCENT.GT.80) LIM_PERCENT = 20
C
	CALL OPSTXT('MONITOR FREQUENCY IS '//ITOC(FREQUENCY,XLEN)//
     *                   ' MILLISECONDS PER PROC')
	WRITE(LUN,*) IAM(),'MONITOR FREQUENCY IS ',FREQUENCY,
     *                   ' MILLISECONDS PER PROC'

	CALL OPSTXT('DEFAULT LIMITS PERCENT IS '//ITOC(LIM_PERCENT,XLEN))
	WRITE(LUN,*) IAM(),'DEFAULT LIMITS    PERCENT IS ',LIM_PERCENT
C
	DO 35 J=1,MON_MAX_PROCS
	    MON_PROCS(J).MON_PROC_STAT = MON_NO_PROC
	    MON_PROCS(J).MON_PROC_BY_NAME = .FALSE.
	    MON_PROCS(J).MON_PROC_ID=-2
35	CONTINUE
C
C	GET INDIVIDUAL PROCESS IDS
C
	IF(.NOT.ALL_PROCESSES) GOTO 70
C
	DO J=1,MON_MAX_PROCS
	    MON_PROCS(J).MON_PROC_ID = -1
	    CALL GET_PROC_NAME(LUN,PROC_ID_REQUEST,
     *			       MON_PROCS(J).MON_PROC_ID,
     *			       MON_PROCS(J).MON_PROC_NAME, J)
C
	    IF(MON_PROCS(J).MON_PROC_NAME(1:3).EQ.'ALL') GOTO 70
C
C	    TO REPORT AN ERROR SET 'YES_PROCESS'
C
	    IF(MON_PROCS(J).MON_PROC_NAME(1:4).NE.MON_PROJ_NAME) THEN
	      MON_PROCS(J).MON_PROC_STAT = MON_NO_PROC
	    ELSE
	      MON_PROCS(J).MON_PROC_STAT = MON_YES_PROC
	    ENDIF
C
	ENDDO
C
70	CONTINUE
C
C	INITIALIZE SOME TOTAL PERCENTAGES
C
	MON_MAX_TOTAL_CPU = 70
	MON_MAX_TMF_SIZE = 70
C
C	ASSUME THAT MONITOR IS RUNNING AS A SUBPROCESS WITH
C	ALL MESSAGES DIRECTED TO DISK FILE AND ALSO
C	CRITICAL MESSAGES DIRECTED TO THE CONSOLE
C
	MON_OPER_MESSAGES = .TRUE.
C
C	INITIALIZE MAG TAPE MONITORING
C
	MON_TAPESW_OLD = P(TAPESW)
	MON_TAPESW_SERIAL = NXTSER
C
C	INITIALIZE INTERNAL TABLES
C
	CALL MON_INIT_PROCS(LUN)      ! INITIALIZE PROCS PARAMETER TABLES
	CALL MON_INIT_DISKS	      ! INITIALIZE DISKS PARAMETER TABLES
C
C	IF TIME INTERVAL IS 0, REPORT PARAMETERS OF EACH PROC
C
	IF (FREQUENCY .LE. 0) THEN
	  DO 100 I=1,MON_MAX_PROCS
C
C	    SKIP NON-EXISTANT AND IN ERROR PROCS
C
	    IF (MON_PROCS(I).MON_PROC_STAT.EQ.MON_NO_PROC) GOTO 100
C
	    CALL NEXT_PROC(LUN,I,MON_REPORT)
C
100	  CONTINUE
C
	  DO 200 I=1,MON_MAX_DISKS
C
C	    SKIP NON-EXISTANT AND IN ERROR DISKS
C
	    IF (MON_DISKS(I).MON_DISK_STAT.EQ.MON_NO_DISK) GOTO 200
C
	    CALL NEXT_DISK(LUN,I,MON_DISKS(I).MON_DISK_NAME,MON_REPORT)
C
200	  CONTINUE
	  GOTO 10000
	ENDIF
C
1000	CONTINUE
C
        IF(DAYSTS.EQ.DSCLOS) THEN
	  WRITE(LUN,*) IAM(),'DAYSTS .EQ. DSCLOS - terminating MONGOLS...'
	  GOTO 10000
	ENDIF
C
	CALL CHECK_GAME(LUN)
C
	MON_PROC_TOTAL_CPU_PRCNT = 0
C
C	MONITOR ONE PROC AT A TIME
C
	DO 2000 I=1,MON_MAX_PROCS
	    CALL XWAIT(FREQUENCY, 1, ST)
C
C	    SKIP NON-EXISTANT AND IN ERROR PROCS
C
	    CALL NEXT_PROC(LUN,I,MON_WATCH)
C
2000	CONTINUE
C
	IF(MON_PROC_TOTAL_CPU_PRCNT.GT.MON_MAX_TOTAL_CPU) THEN
	    CALL OPSTXT('*** TOTAL CPU TIME '//
     *        ITOC(MON_PROC_TOTAL_CPU_PRCNT,XLEN)//' IS OVER '//
     *	      ITOC(MON_MAX_TOTAL_CPU,XLEN)// ' !!! ')
	    WRITE(LUN,10200) IAM(), MON_PROC_TOTAL_CPU_PRCNT,
     *	      MON_MAX_TOTAL_CPU
	    MON_MAX_TOTAL_CPU = MON_PROC_TOTAL_CPU_PRCNT
	ENDIF
C
C	MONITOR ONE DISK AT A TIME
C
	DO 3000 I=1,MON_MAX_DISKS
	    CALL XWAIT(FREQUENCY, 1, ST)
C
C	    SKIP NON-EXISTANT AND IN ERROR DISKS
C
	    CALL NEXT_DISK(LUN,I,MON_DISKS(I).MON_DISK_NAME,MON_WATCH)
C
3000	CONTINUE
C
	GOTO 1000
C
10000	CONTINUE
C
	CLOSE(UNIT=LUN)
C
	CALL GSTOP(GEXIT_SUCCESS)
C
900	FORMAT('MONGOLS-',I4.4,'.LOG')
910	FORMAT('MONGOLS-',I4.4,'.LOG;*')
10050	FORMAT(A4)
10100	FORMAT(I)
10200	FORMAT(1X,A,'****   TOTAL CPU TIME ',I3,' IS OVER ',I3,
     *	  ' PERCENT !!!!!')
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE NEXT_PROC(PROC_INX,FLAG)
C OBTAINS THE STATUS PARAMETERS OF THE SPECIFIED PROC AND FOR EACH 
C PARAMETER CALLS 'CHECK_PROC_PARAM' ROUTINE. PARAMETERS
C ARE KEPT IN THE 'MONGOLS' LOCAL COMMON. THIS COMMON IS INIITIALIZED
C BY MON_INIT_PROCS AND MON_SET_PROC ROUTINES.
C
C INPUT:
C	PROC_INX - PROC INDEX INTO MON_PROC_TABLE
C	FLAG - ONE OF: MON_LEARN,MON_WATCH,MON_REPORT
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE NEXT_PROC(LUN,PROC_INX,FLAG)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
	INCLUDE '(LIB$ROUTINES)'
	INCLUDE '($LIBDTDEF)'
C
	INTEGER*4   PROC_INX
	INTEGER*4   FLAG,LUN
C
        INTEGER*4   I, STAT, PID
	CHARACTER*15	PRC_NAME
C
	PRC_NAME = MON_PROCS(PROC_INX).MON_PROC_NAME
	PID = MON_PROCS(PROC_INX).MON_PROC_ID
C
C	FILL-IN PARAMETER TABLE FOR 'GEJPI''
C
D	TYPE *,IAM(),'NEXT PROC IS ', PRC_NAME
C
	CALL MON_SET_PROC(PROC_INX)
C
	CALL GET_FULL_JPI(LUN,PROC_INX,STAT)
C
	IF (STAT .EQ. 0) THEN
	    GOTO 10000
	ENDIF
C
	IF(FLAG.EQ.MON_REPORT) THEN
	    WRITE (LUN, 10001) IAM(),
     *	      'PARAMETERS FOR THE PROCESS ',PRC_NAME,
     *	      ' PID= ', PID
	ENDIF
C
C
C	GET TIME NOW
C
	STAT = LIB$CVT_FROM_INTERNAL_TIME(LIB$K_SECOND_OF_DAY,
     *	      TIME_NOW,)
	IF(.NOT.STAT) THEN
	    CALL LIB$SIGNAL(%VAL(STAT))
	ENDIF
C
C	TIME INTERVAL IS IN SECONDS
C
	TIME_INTERVAL = (TIME_NOW - MON_PROC_LAST_TIMES(PROC_INX))
	IF(TIME_INTERVAL.LT.1) TIME_INTERVAL = 1    ! JUST IN CASE...
C
	DO 1000 I=1,MON_JPI$_LAST_PARAM
	    IF(FLAG.EQ.MON_REPORT) THEN
	      IF(MON_DVI_TYPES(I) .EQ. MON_PAR_HEX) THEN
		WRITE (6,10002)IAM(),MON_JPI_NAMES(I),
     *		  MON_PROC_TABLE(PROC_INX,I).MON_NEW_VALUE
	      ELSE
		WRITE (6,10003)IAM(),MON_JPI_NAMES(I),
     *		  MON_PROC_TABLE(PROC_INX,I).MON_NEW_VALUE
	      ENDIF
	    ENDIF
	    CALL CHECK_PROC_PARAM(LUN,PROC_INX,I)
1000	CONTINUE

C	ACCUMULATE TOTAL CPU TIME 
	MON_PROC_TOTAL_CPU_PRCNT = MON_PROC_TOTAL_CPU_PRCNT +
     *	  MON_PROC_TABLE(PROC_INX,MON_JPI$_CPUTIM).MON_LAST_RATE
	MON_PROC_TOTAL_CPU_PRCNT=MIN(MON_PROC_TOTAL_CPU_PRCNT,100)
C
9000	CONTINUE
C
	MON_PROC_LAST_TIMES(PROC_INX) = TIME_NOW
C
10000	CONTINUE
C
	RETURN
C
10001	FORMAT(1X,A,A,A,A,Z)
10002	FORMAT(1X,A,A,Z9,' (HEX)')
10003	FORMAT(1X,A,A,I11)
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE MON_INIT_PROCS
C INITIALIZE MON_PROC_ITEMS IN 'MONGOLS' LOCAL COMMON.
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE MON_INIT_PROCS(LUN)
	IMPLICIT NONE
C
        INCLUDE     '($SYSSRVNAM)'
        INCLUDE     '($JPIDEF)'
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:TASKID.DEF'
C
        INTEGER*4   LUN,I,J
C
	INTEGER*4   SET_GAME_PROC
	EXTERNAL    SET_GAME_PROC
C
C	INITIALIZE FIELDS IN THE MON_PROC_TABLE
C
	DO 200 I=1,MON_MAX_PROCS
	    CALL INIT_ANY_PROC(I)
200	CONTINUE
C
C	GET GAME PROC NAMES
C
	J = 0
C
	DO 1200 I=1,NUMTSK
	    IF (CXTSKNAM(I).EQ.'        ') GOTO 1200
C
C	    THE PROCESS IS A GAME PROCESS - DO SOME SPECIFIC STUFF
C
	    IF (SET_GAME_PROC (LUN,CXTSKNAM(I),J) .LT.0) GOTO 2000
C
	    IF (CXTSKNAM(I).EQ.'WAGPRO  ') THEN
		MON_PROC_TABLE(J,MON_JPI$_CPUTIM).MON_MAX_VALUE=40
	    ENDIF
	    IF (CXTSKNAM(I).EQ.'NBRPRO  ') THEN
		MON_PROC_TABLE(J,MON_JPI$_CPUTIM).MON_MAX_VALUE=30
	    ENDIF
CRXK	    IF (CXTSKNAM(I).EQ.'VICPRO  ') THEN
CRXK		MON_PROC_TABLE(J,MON_JPI$_CPUTIM).MON_MAX_VALUE=40
CRXK	    ENDIF
	    IF (CXTSKNAM(I).EQ.'APULOG  ') THEN
		MON_PROC_TABLE(J,MON_JPI$_CPUTIM).MON_MAX_VALUE=20
	    ENDIF
	    IF (CXTSKNAM(I).EQ.'LOGGER  ') THEN
		MON_PROC_TABLE(J,MON_JPI$_CPUTIM).MON_MAX_VALUE=20
	    ENDIF
	    IF (CXTSKNAM(I).EQ.'DISPAT  ') THEN
		MON_PROC_TABLE(J,MON_JPI$_CPUTIM).MON_MAX_VALUE=20
	    ENDIF
C
1200	  CONTINUE
C
C
C	FILL-UP OTHER GAME PROC NAMES
C
	IF (SET_GAME_PROC (LUN,'DCNPRO',J) .LT.0) GOTO 2000
C***	IF (SET_GAME_PROC ('MSCPRO',J) .LT.0) GOTO 2000
	IF (SET_GAME_PROC (LUN,'CTLPRO',J) .LT.0) GOTO 2000
	IF (SET_GAME_PROC (LUN,'X2XRAPP',J) .LT.0) GOTO 2000
	IF (SET_GAME_PROC (LUN,'LODIMG',J) .LT.0) GOTO 2000
	IF (SET_GAME_PROC (LUN,'ELOG',J) .LT.0) GOTO 2000
C***	IF (SET_GAME_PROC (LUN,'MSCMGR',J) .LT.0) GOTO 2000
CRXK
CWPW	IF (SET_GAME_PROC (LUN,'TVTPRO',J) .LT.0) GOTO 2000
CRXK
C
C	SET-UP 'MONGOLS' PROCESS
C
	J = J + 1
	IF (J .GE. MON_MAX_PROCS) THEN
	    WRITE(LUN,*) 'TOO MANY PROCESSES: ', J
	    CALL OPS('TOO MANY PROCESSES', J,0)
	    GOTO 2000
	ENDIF
        MON_PROCS(J).MON_PROC_NAME = MON_PROJ_NAME // 'MONGOLS'     !V05
	CALL GET_PROC_ID(LUN,MON_PROCS(J).MON_PROC_NAME,
     *			     MON_PROCS(J).MON_PROC_ID, J)
C
CCC V04 FOR ESTONIA WE NEED IMPORTANT MESSAGES ON THE CONSOLE, THUS
C	MON_OPER_MESSAGES HAS TO STAY .TRUE.
C
C	IF(MON_PROCS(J).MON_PROC_ID.LT.0) THEN
C
C	    WE RUNNING FOREGROUND - NO NEED TO REPORT ERRORS TWICE
C
C	    MON_OPER_MESSAGES = .FALSE.
C	ENDIF
C
	IF(MON_PROCS(J).MON_PROC_NAME(1:4).EQ.MON_PROJ_NAME) THEN
	   MON_PROCS(J).MON_PROC_STAT = MON_YES_PROC
	ELSE
	   MON_PROCS(J).MON_PROC_STAT = MON_NO_PROC
	ENDIF	
	MON_PROC_TABLE(J,MON_JPI$_PRIB).MON_MIN_VALUE=4
	MON_PROC_TABLE(J,MON_JPI$_PRIB).MON_MAX_VALUE=10
	MON_PROC_TABLE(J,MON_JPI$_PRI).MON_MIN_VALUE=4
	MON_PROC_TABLE(J,MON_JPI$_PRI).MON_MAX_VALUE=10
C
2000	CONTINUE
C
C	PREPARE ITEM LIST  FOR 'GETJPI'
C
	DO 3000 I=1,MON_MAX_PROC_PARAMS
	    MON_PROC_ITEMS(I).BUFLEN = 0
	    MON_PROC_ITEMS(I).ITMCOD = 0
	    MON_PROC_ITEMS(I).BUFADR = 0
	    MON_PROC_ITEMS(I).LENADR = 0
3000	CONTINUE
C
	DO 4000 I=1,MON_JPI$_LAST_PARAM
	    MON_PROC_ITEMS(I).BUFLEN = 4
	    MON_PROC_ITEMS(I).LENADR = %LOC(MON_RETURN_LEN)
	    MON_JPI_TYPES(I) = MON_PAR_REGULAR
4000	CONTINUE
C
C	CPUTIM IS CUMULATIVE PARAMETER
C
	MON_JPI_TYPES(MON_JPI$_CPUTIM) = MON_PAR_ACCUM
	MON_JPI_TYPES(MON_JPI$_BUFIO) = MON_PAR_ACCUM
	MON_JPI_TYPES(MON_JPI$_DIRIO) = MON_PAR_ACCUM
C***	MON_JPI_TYPES(MON_JPI$_TQCNT) = MON_PAR_ACCUM
	MON_JPI_TYPES(MON_JPI$_PAGEFLTS) = MON_PAR_ACCUM
C
C
C	FILL-IN MON_PROC_ITEMS WITH VALUES THAT WE NEED
C
        MON_PROC_ITEMS(MON_JPI$_APTCNT).ITMCOD = JPI$_APTCNT
	MON_JPI_NAMES(MON_JPI$_APTCNT) = 
     *	  'JPI$_APTCNT    - ACTIVE PAGE TABLE COUNT'
C
        MON_PROC_ITEMS(MON_JPI$_ASTCNT).ITMCOD = JPI$_ASTCNT
	MON_JPI_NAMES(MON_JPI$_ASTCNT) = 
     *	  'JPI$_ASTCNT    - REMAINING AST COUNT'
C
        MON_PROC_ITEMS(MON_JPI$_ASTLM).ITMCOD = JPI$_ASTLM
	MON_JPI_NAMES(MON_JPI$_ASTLM) = 
     *	  'JPI$_ASTLM     - AST LIMIT'
C
	MON_PROC_ITEMS(MON_JPI$_BIOCNT).ITMCOD = JPI$_BIOCNT
	MON_JPI_NAMES(MON_JPI$_BIOCNT) = 
     *	  'JPI$_BIOCNT    - REMAINING BUF IO COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_BIOLM).ITMCOD = JPI$_BIOLM
	MON_JPI_NAMES(MON_JPI$_BIOLM) = 
     *	  'JPI$_BIOLM     - BUFFERED IO LIMIT'
C
	MON_PROC_ITEMS(MON_JPI$_BUFIO).ITMCOD = JPI$_BUFIO
	MON_JPI_NAMES(MON_JPI$_BUFIO) = 
     *	  'JPI$_BUFIO     - BUFFERED IO COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_BYTCNT).ITMCOD = JPI$_BYTCNT
	MON_JPI_NAMES(MON_JPI$_BYTCNT) = 
     *	  'JPI$_BYTCNT - REM. BUF IO BYTE COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_BYTLM).ITMCOD = JPI$_BYTLM
	MON_JPI_NAMES(MON_JPI$_BYTLM) = 
     *	  'JPI$_BYTLM     - BUFFERED IO BYTE LIMIT'
C
	MON_PROC_ITEMS(MON_JPI$_CPULIM).ITMCOD = JPI$_CPULIM
	MON_JPI_NAMES(MON_JPI$_CPULIM) = 
     *	  'JPI$_CPULIM    - CPU TIME LIMIT'
C
	MON_PROC_ITEMS(MON_JPI$_CPUTIM).ITMCOD = JPI$_CPUTIM
	MON_JPI_NAMES(MON_JPI$_CPUTIM) = 
     *	  'JPI$_CPUTIM - ACCUM CPU TIME (IN 10MS)'
C
	MON_PROC_ITEMS(MON_JPI$_DFPFC).ITMCOD = JPI$_DFPFC
	MON_JPI_NAMES(MON_JPI$_DFPFC) = 
     *	  'JPI$_DFPFC  - PAGE FAULT CLUSTER SIZE'
C
	MON_PROC_ITEMS(MON_JPI$_DFWSCNT).ITMCOD = JPI$_DFWSCNT
	MON_JPI_NAMES(MON_JPI$_DFWSCNT) = 
     *	  'JPI$_DFWSCNT - DEFAULT WORKING SET SIZE'
C
	MON_PROC_ITEMS(MON_JPI$_DIOCNT).ITMCOD = JPI$_DIOCNT
	MON_JPI_NAMES(MON_JPI$_DIOCNT) = 
     *	  'JPI$_DIOCNT  - REM. DIRECT IO COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_DIOLM).ITMCOD = JPI$_DIOLM
	MON_JPI_NAMES(MON_JPI$_DIOLM) = 
     *    'JPI$_DIOLM   - DIRECT IO LIMIT'
C
	MON_PROC_ITEMS(MON_JPI$_DIRIO).ITMCOD = JPI$_DIRIO
	MON_JPI_NAMES(MON_JPI$_DIRIO) = 
     *	  'JPI$_DIRIO   - DIRECT IO COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_ENQCNT).ITMCOD = JPI$_ENQCNT
	MON_JPI_NAMES(MON_JPI$_ENQCNT) = 
     *	  'JPI$_ENQCNT    - REMAINING LOCK COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_ENQLM).ITMCOD = JPI$_ENQLM
	MON_JPI_NAMES(MON_JPI$_ENQLM) = 
     *	  'JPI$_ENQLM     - LOCK LIMIT'
C
	MON_PROC_ITEMS(MON_JPI$_FILCNT).ITMCOD = JPI$_FILCNT
	MON_JPI_NAMES(MON_JPI$_FILCNT) = 
     *	  'JPI$_FILCNT    - REM. OPEN FILE COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_FILLM).ITMCOD = JPI$_FILLM
	MON_JPI_NAMES(MON_JPI$_FILLM) = 
     *	  'JPI$_FILLM     - OPEN FILE LIMIT'
C
	MON_PROC_ITEMS(MON_JPI$_FREP0VA).ITMCOD = JPI$_FREP0VA
	MON_JPI_NAMES(MON_JPI$_FREP0VA) = 
     *	  'JPI$_FREP0VA   - P0 FREE PAGE ADDRESS'
C
	MON_PROC_ITEMS(MON_JPI$_FREP1VA).ITMCOD = JPI$_FREP1VA
	MON_JPI_NAMES(MON_JPI$_FREP1VA) = 
     *	  'JPI$_FREP1VA   - P1 FREE PAGE ADDRESS'
C
	MON_PROC_ITEMS(MON_JPI$_FREPTECNT).ITMCOD = JPI$_FREPTECNT
	MON_JPI_NAMES(MON_JPI$_FREPTECNT) = 
     *	  'JPI$_FREPTECNT - # OF PAGES FOR EXPANS.'
C
	MON_PROC_ITEMS(MON_JPI$_GPGCNT).ITMCOD = JPI$_GPGCNT
	MON_JPI_NAMES(MON_JPI$_GPGCNT) = 
     *	  'JPI$_GPGCNT    - GLOBAL PAGE COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_JOBPRCCNT).ITMCOD = JPI$_JOBPRCCNT
	MON_JPI_NAMES(MON_JPI$_JOBPRCCNT) = 
     *	  'JPI$_JOBPRCCNT - SUBPROCESSES IN A JOB'
C
	MON_PROC_ITEMS(MON_JPI$_PAGEFLTS).ITMCOD = JPI$_PAGEFLTS
	MON_JPI_NAMES(MON_JPI$_PAGEFLTS) = 
     *	  'JPI$_PAGEFLTS  - PAGE FAULTS COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_PAGFILCNT).ITMCOD = JPI$_PAGFILCNT
	MON_JPI_NAMES(MON_JPI$_PAGFILCNT) = 
     *	  'JPI$_PAGFILCNT - REM. PAGING FILE COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_PGFLQUOTA).ITMCOD = JPI$_PGFLQUOTA
	MON_JPI_NAMES(MON_JPI$_PGFLQUOTA) = 
     *	  'JPI$_PGFLQUOTA - PAGING FILE QUOTA'
C
	MON_PROC_ITEMS(MON_JPI$_PPGCNT).ITMCOD = JPI$_PPGCNT
	MON_JPI_NAMES(MON_JPI$_PPGCNT) = 
     *	  'JPI$_PPGCNT    - PAGES IN THE WORK. SET'
C
	MON_PROC_ITEMS(MON_JPI$_PRI).ITMCOD = JPI$_PRI
	MON_JPI_NAMES(MON_JPI$_PRI) = 
     *	  'JPI$_PRI       - CURRENT PRIORITY'
C
	MON_PROC_ITEMS(MON_JPI$_PRIB).ITMCOD = JPI$_PRIB
	MON_JPI_NAMES(MON_JPI$_PRIB) = 
     *	  'JPI$_PRIB      - BASE PRIORITY'
C
	MON_PROC_ITEMS(MON_JPI$_TQCNT).ITMCOD = JPI$_TQCNT
	MON_JPI_NAMES(MON_JPI$_TQCNT) = 
     *	  'JPI$_TQCNT     - REM. TIMER QUEUE COUNT'
C
	MON_PROC_ITEMS(MON_JPI$_TQLM).ITMCOD = JPI$_TQLM
	MON_JPI_NAMES(MON_JPI$_TQLM) = 
     *	  'JPI$_TQLM      - TIMER QUEUE ENTR. LIMIT'
C
	MON_PROC_ITEMS(MON_JPI$_VIRTPEAK).ITMCOD = JPI$_VIRTPEAK
	MON_JPI_NAMES(MON_JPI$_VIRTPEAK) = 
     *	  'JPI$_VIRTPEAK  - PEAK VIRT. ADDR. SIZE'
C
	MON_PROC_ITEMS(MON_JPI$_VOLUMES).ITMCOD = JPI$_VOLUMES
	MON_JPI_NAMES(MON_JPI$_VOLUMES) = 
     *	  'JPI$_VOLUMES   - # OF MOUNTED VOLUMES'
C
	MON_PROC_ITEMS(MON_JPI$_WSAUTH).ITMCOD = JPI$_WSAUTH
	MON_JPI_NAMES(MON_JPI$_WSAUTH) = 
     *	  'JPI$_WSAUTH    - AUTH. WORKING SET QUOTA'
C
	MON_PROC_ITEMS(MON_JPI$_WSAUTHEXT).ITMCOD = JPI$_WSAUTHEXT
	MON_JPI_NAMES(MON_JPI$_WSAUTHEXT) = 
     *	  'JPI$_WSAUTHEXT - AUTH. WORK. SET EXTENT'
C
	MON_PROC_ITEMS(MON_JPI$_WSEXTENT).ITMCOD = JPI$_WSEXTENT
	MON_JPI_NAMES(MON_JPI$_WSEXTENT) = 
     *	  'JPI$_WSEXTENT  - WORKING SET EXTENT'
C
	MON_PROC_ITEMS(MON_JPI$_WSPEAK).ITMCOD = JPI$_WSPEAK
	MON_JPI_NAMES(MON_JPI$_WSPEAK) = 
     *	  'JPI$_WSPEAK    - WORKING SET PEAK SIZE'
C
	MON_PROC_ITEMS(MON_JPI$_WSQUOTA).ITMCOD = JPI$_WSQUOTA
	MON_JPI_NAMES(MON_JPI$_WSQUOTA) = 
     *	  'JPI$_WSQUOTA   - WORKING SET QUOTA'
C
	MON_PROC_ITEMS(MON_JPI$_WSSIZE).ITMCOD = JPI$_WSSIZE
	MON_JPI_NAMES(MON_JPI$_WSSIZE) = 
     *	  'JPI$_WSSIZE    - WORKING SET SIZE'
C
	RETURN
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SET_GAME_PROC (NAME,J)
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	INTEGER*4 FUNCTION SET_GAME_PROC(LUN,NAME,PROC_INX_CUR)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
C
	CHARACTER   NAME*(*)
	INTEGER*4   PROC_INX_CUR	    ! INDEX INTO PROCESS TABLE
C
	INTEGER*4	J, LUN
	CHARACTER*15	FULL_NAME
C
	SET_GAME_PROC = -1		    ! BAD STATUS
C
1000	CONTINUE
C
	PROC_INX_CUR = PROC_INX_CUR + 1
C
	IF (PROC_INX_CUR .GE. MON_MAX_PROCS) THEN
		WRITE(LUN,*) 'TOO MANY PROCESSES: ', PROC_INX_CUR
		CALL OPS('TOO MANY PROCESSES', PROC_INX_CUR,0)
		GOTO 10000		    ! EXIT
	ENDIF
C
	IF (MON_PROCS(PROC_INX_CUR).MON_PROC_ID.GT.-2) THEN
		GOTO 1000  ! ID FROM INPUT - KEEP LOOKING FOR EMPTY SLOT
	ENDIF
C
C	CHECK IF PPROCESS ALREADY EXISTS
C
	CALL MAKE_FULL_NAME (NAME, FULL_NAME)
C
	DO 1100 J = 1,PROC_INX_CUR-1
	    IF(MON_PROCS(J).MON_PROC_NAME.EQ.FULL_NAME) THEN
		PROC_INX_CUR = PROC_INX_CUR - 1
		GOTO 2000
	    ENDIF
1100	CONTINUE
C
	J = PROC_INX_CUR
C
2000	CONTINUE
C
	MON_PROCS(J).MON_PROC_NAME = FULL_NAME
	CALL GET_PROC_ID(LUN,MON_PROCS(J).MON_PROC_NAME,
     *			 MON_PROCS(J).MON_PROC_ID,J)
C
	IF(MON_PROCS(J).MON_PROC_NAME(1:4).EQ.MON_PROJ_NAME) THEN
	   MON_PROCS(J).MON_PROC_STAT = MON_YES_PROC
	ELSE
	   MON_PROCS(J).MON_PROC_STAT = MON_NO_PROC
	ENDIF
	MON_PROCS(J).MON_PROC_BY_NAME = .TRUE.
C
	MON_PROC_TABLE(J,MON_JPI$_PRI).MON_MIN_VALUE = 6
	MON_PROC_TABLE(J,MON_JPI$_PRI).MON_MAX_VALUE =
     *		MON_PROC_TABLE(J,MON_JPI$_PRI).MON_MIN_VALUE + 6
C
	MON_PROC_TABLE(J,MON_JPI$_PRIB).MON_MIN_VALUE = 6
	MON_PROC_TABLE(J,MON_JPI$_PRIB).MON_MAX_VALUE = 6
C
	MON_PROC_TABLE(J,MON_JPI$_JOBPRCCNT).MON_MIN_VALUE=1
	MON_PROC_TABLE(J,MON_JPI$_JOBPRCCNT).MON_MAX_VALUE=34
C
	SET_GAME_PROC = 0		    ! GOOD STATUS
C
10000	CONTINUE
	RETURN
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE MON_SET_PROC(PROCX)
C FILL-IN PROC-DEPENDENT PART OF PROC_ITEMS IN THE 'MONGOLS' LOCAL COMMON.
C INPUT:
C	PROCX - PROC INDEX INTO MON_PROC_TABLE
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE MON_SET_PROC(PROCX)
	IMPLICIT NONE
C
        INCLUDE     '($SYSSRVNAM)'
        INCLUDE     '($JPIDEF)'
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
C
        INTEGER*4   PROCX, I
C
C
C
	DO 1000 I=1,MON_JPI$_LAST_PARAM
	    MON_PROC_ITEMS(I).BUFADR = 
     *	    %LOC(MON_PROC_TABLE(PROCX,I).MON_NEW_VALUE)
1000	CONTINUE
C
	RETURN
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C GET_FULL_JPI(PROC_INX,STATUS)
C
C GETS ALL PARAMETERS FOR THE PROCESS WITH THE SPECIFIED NAME
C RETURNS STATUS=1 IF OK, 0 OTHERWISE
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_FULL_JPI(LUN,PROC_INX, STATUS)
	IMPLICIT NONE
C
        INCLUDE     '($SYSSRVNAM)'
        INCLUDE     '($JPIDEF)'
        INCLUDE     '($SSDEF)'
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
C
	CHARACTER*1 BELL/Z07/
	CHARACTER   NAME*15
	INTEGER*4   STATUS, PROC_INX, ST, LUN, IOSB(2)
	
C
        CHARACTER*6 UNSPRO/'UNSPRO'/
        CHARACTER*6 FPTPRO/'FPTPRO'/
C
	NAME = MON_PROCS(PROC_INX).MON_PROC_NAME
C
	STATUS = 0		! BAD STATUS
C
C	PROCESS ID -1 (FOR ALL PROCESSES) IS NOT DONE YET...
C
	IF(MON_PROCS(PROC_INX).MON_PROC_ID.EQ.-1) THEN
	  CALL FIND_NEW_PROCESSES (LUN)
	  IF(MON_PROCS(PROC_INX).MON_PROC_STAT.NE.MON_NO_PROC) THEN
	    MON_PROCS(PROC_INX).MON_PROC_STAT = MON_NO_PROC
	    IF(MON_PROCS(PROC_INX).MON_PROC_NAME(1:4).EQ.MON_PROJ_NAME)
     *          WRITE(6, 10010) IAM(), NAME,BELL,BELL,BELL
	    WRITE(LUN, 10010) IAM(), NAME
	  ENDIF
          GOTO 10000
	ENDIF
C
	ST = SYS$GETJPIW( ,MON_PROCS(PROC_INX).MON_PROC_ID,,
     *			   MON_PROC_ITEMS(1),IOSB,,)
C
C
C	IF PROCESS DOES NOT EXIT - REPORT THE ERROR
C
CRXK        IF(IOSB(1).EQ.SS$_NONEXPR)THEN
        IF(IOSB(1).EQ.SS$_NONEXPR .AND.
     *      MON_PROCS(PROC_INX).MON_PROC_ID.NE.-2)THEN
	  IF(MON_PROCS(PROC_INX).MON_PROC_STAT.NE.MON_NO_PROC) THEN
	    MON_PROCS(PROC_INX).MON_PROC_STAT = MON_NO_PROC
	    MON_PROCS(PROC_INX).MON_PROC_ID=-2
	    WRITE(LUN, 10010) IAM(), NAME
	    IF(MON_PROCS(PROC_INX).MON_PROC_NAME(1:4).EQ.MON_PROJ_NAME)
     *        CALL OPSTXT('THE PROCESS '//NAME//' DOES NOT EXIST !'// 
     *                     BELL//BELL//BELL)
	  ENDIF
          GOTO 10000
        ENDIF
C
        IF(IOSB(1).EQ.SS$_SUSPENDED)THEN
	  IF(MON_PROCS(PROC_INX).MON_PROC_STAT.NE.MON_SUSP_PROC) THEN
	    MON_PROCS(PROC_INX).MON_PROC_STAT = MON_SUSP_PROC
	    WRITE(LUN, 10020) IAM(), NAME
	    IF(MON_PROCS(PROC_INX).MON_PROC_NAME(1:4).EQ.MON_PROJ_NAME)
     *	      CALL OPSTXT('THE PROCESS '//NAME//' IS SUSPENDED !!!'//
     *                     BELL//BELL//BELL)
	  ENDIF
          GOTO 10000
        ENDIF
C
         IF(.NOT.ST.AND.
     *       MON_PROCS(PROC_INX).MON_PROC_NAME(5:10).NE.UNSPRO.AND.
     *       MON_PROCS(PROC_INX).MON_PROC_NAME(5:10).NE.FPTPRO)THEN
	  IF(MON_PROCS(PROC_INX).MON_PROC_STAT.NE.MON_NO_PROC) THEN
	    MON_PROCS(PROC_INX).MON_PROC_STAT = MON_NO_PROC 
	    WRITE(LUN, 10010) IAM(), NAME
	    IF(MON_PROCS(PROC_INX).MON_PROC_NAME(1:4).EQ.MON_PROJ_NAME)
     *        CALL OPSTXT('THE PROCESS '//NAME//' DOES NOT EXIST !'//
     *                    BELL//BELL//BELL)
	  ENDIF
	  GOTO 10000
        ENDIF
C
	IF(MON_PROCS(PROC_INX).MON_PROC_NAME(1:4).EQ.MON_PROJ_NAME) THEN
	  MON_PROCS(PROC_INX).MON_PROC_STAT = MON_YES_PROC
	ELSE
	  MON_PROCS(PROC_INX).MON_PROC_STAT = MON_YES_PROC
	ENDIF
	STATUS = 1		! GOOD STATUS
C
10000	CONTINUE
C
	RETURN
10010	FORMAT(1X,A,'****THE PROCESS:::: ',A,
     *              ' ----DOES NOT EXIST****',3A1,/)
10020	FORMAT(1X,A,'****THE PROCESS:::: ',A,
     *              ' ----IS SUSPENDED****',3A1,/)
10030	FORMAT(1X,A,'****NO STATUS FOR THE PROCESS:::: ',A,3A1,/)
C
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE CHECK_PROC_PARAM(PROC_INX,PARAM_INX)
C WILL CHECK THE STATUS OF THE SPECIFIED PARAMETER IN THE 'MONGOLS'
C COMMON
C
C	NON-CUMULATIVE VALUES ARE HALDLED BY COMPARING THE NEW VALUE
C	WITH  MINIMUM AND MAXIMUM.
C	CUMULATIVE VALUES ARE HALDLED BY COMPARING THE DIFFERENCE
C	(NEW_VALUE - LAST_VALUE) WITH MINIMUM AND MAXIMUM
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE CHECK_PROC_PARAM(LUN,PROC_INX,PARAM_INX)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
C
	INTEGER*4	PROC_INX,PARAM_INX
	CHARACTER*15	PRC_NAME
	INTEGER*4	PID,LUN
C
	INTEGER*4   NEW_VALUE, EXAM_VALUE
	CHARACTER*7	CUMULATIVE
C
	PRC_NAME = MON_PROCS(PROC_INX).MON_PROC_NAME
	PID = MON_PROCS(PROC_INX).MON_PROC_ID
C
C	FIRST FEW ENTRIES ARE FOR 'ADJUSTMENT'
C
	MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_PAR_INIT = 
     *	      MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_PAR_INIT + 1
	IF(MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_PAR_INIT.LE.1) GOTO 9100
	IF(MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_PAR_INIT.LE.2) GOTO 9000
C
C	SAVE NEW_VALUE
C
	NEW_VALUE =  MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_NEW_VALUE
	EXAM_VALUE = NEW_VALUE
C
C	IF PARAMETER IS CUMULATIVE - FIND THE RATE OF CHANGE
C
	IF(MON_JPI_TYPES(PARAM_INX).EQ.MON_PAR_ACCUM) THEN
	    EXAM_VALUE = (NEW_VALUE - 
     *	    MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_LAST_VALUE) /
     *	    TIME_INTERVAL
	ENDIF
C
	IF(MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_PAR_INIT.LE.3) THEN
C
	    IF(MON_JPI_TYPES(PARAM_INX) .EQ. MON_PAR_HEX) GOTO 9000
C
	    IF (MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MIN_VALUE
     *		.EQ.'80000000'X) THEN
		MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MIN_VALUE =
     *		INT(EXAM_VALUE -
     *		INT(DBLE(ABS(EXAM_VALUE))*DBLE(LIM_PERCENT)/100.0))
	    ENDIF
C
	    IF (MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MAX_VALUE
     *	        .EQ.'7FFFFFFF'X) THEN
		MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MAX_VALUE =
     *		INT(EXAM_VALUE +
     *		INT(DBLE(ABS(EXAM_VALUE))*DBLE(LIM_PERCENT)/100.0))
	    ENDIF
C
	    GOTO 9000
	ENDIF
C
C	BIT-ORIENTED PARAMETERS SHOULD BE EQUAL
C
	IF(MON_JPI_TYPES(PARAM_INX) .EQ. MON_PAR_HEX) THEN
	  IF(NEW_VALUE .NE.
     *	    MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_LAST_VALUE) THEN
	    WRITE(LUN,10010)
     *	    IAM(),PRC_NAME,PID,
     *	    IAM(),MON_JPI_NAMES(PARAM_INX),
     *	    IAM(),MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_LAST_VALUE,
     *	    IAM(),NEW_VALUE
	  ENDIF
	  GOTO 9000
	ENDIF
C
	CUMULATIVE = ' '
	IF(MON_JPI_TYPES(PARAM_INX) .EQ. MON_PAR_ACCUM) THEN
	    CUMULATIVE = ' (/SEC)'
	ENDIF
C
C	MAKE THE CHECK
C
	IF(EXAM_VALUE.LT. 
     *	        MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MIN_VALUE) THEN
	    WRITE(LUN,10020)
     *	       IAM(),PRC_NAME,PID,
     *	       IAM(),MON_JPI_NAMES(PARAM_INX),CUMULATIVE,
     *	       IAM(),MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MIN_VALUE,
     *	       IAM(),EXAM_VALUE
	    MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MIN_VALUE =
     *	       EXAM_VALUE
	ENDIF
C
	IF(EXAM_VALUE.GT. 
     *	        MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MAX_VALUE) THEN
	    WRITE(LUN,10030)
     *	       IAM(),PRC_NAME,PID,
     *	       IAM(),MON_JPI_NAMES(PARAM_INX), CUMULATIVE,
     *	       IAM(),MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MAX_VALUE,
     *	       IAM(),EXAM_VALUE
	    MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_MAX_VALUE =
     *	       EXAM_VALUE
	ENDIF
C

9000	CONTINUE
	MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_LAST_RATE =
     *	    (MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_NEW_VALUE -
     *	    MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_LAST_VALUE) /
     *	    TIME_INTERVAL
C
9100	CONTINUE
	MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_LAST_VALUE =
     *	    MON_PROC_TABLE(PROC_INX,PARAM_INX).MON_NEW_VALUE
C
10000	CONTINUE
C
	RETURN
C
10010	FORMAT(1X,A,'****PROCESS STATUS CHANGE : ',A,' PID=',Z,/,
     *         1X,A,'****PARAM: ',A,' (HEX)',/,
     *         1X,A,'****PREV STATUS:  ',Z9,/,
     *         1X,A,'****NEW  STATUS:  ',Z9,/)
C
10020	FORMAT(1X,A,'****PROCESS NEW MIN. VALUE: ',A,' PID=',Z,/,
     *         1X,A,'****PARAM: ',A,A,/,
     *         1X,A,'****PREV.MINIMUM: ',I11,/,
     *         1X,A,'****NEW  MINIMUM: ',I11,/)
C
10030	FORMAT(1X,A,'****PROCESS NEW MAX. VALUE: ',A,' PID=',Z,/,
     *         1X,A,'****PARAM: ',A,A,/,
     *         1X,A,'****PREV. MAXIMUM: ',I11,/,
     *         1X,A,'****NEW   MAXIMUM: ',I11,/)
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE CHECK_DISK_PARAM(DISK_INX,PARAM_INX,DISK_NAME)
C WILL CHECK THE STATUS OF THE SPECIFIED PARAMETER IN THE 'MONGOLS'
C COMMON
C
C	NON-CUMULATIVE VALUES ARE HALDLED BY COMPARING THE NEW VALUE
C	WITH  MINIMUM AND MAXIMUM.
C	CUMULATIVE VALUES ARE HALDLED BY COMPARING THE DIFFERENCE
C	(NEW_VALUE - LAST_VALUE) WITH MINIMUM AND MAXIMUM
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE CHECK_DISK_PARAM(LUN,DISK_INX,PARAM_INX,DISK_NAME)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
C
	INTEGER*4   DISK_INX,PARAM_INX,LUN
	CHARACTER   DISK_NAME*(*)
C
	INTEGER*4   NEW_VALUE, EXAM_VALUE
	CHARACTER*7	CUMULATIVE
C
C	FIRST FEW ENTRIES ARE FOR 'ADJUSTMENT'
C
	MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_PAR_INIT = 
     *	      MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_PAR_INIT + 1
	IF(MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_PAR_INIT.LE.1) GOTO 9100
	IF(MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_PAR_INIT.LE.2) GOTO 9000
C
C	SAVE NEW_VALUE
C
	NEW_VALUE =  MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_NEW_VALUE
	EXAM_VALUE = NEW_VALUE
C
C	IF PARAMETER IS CUMULATIVE - FIND THE RATE OF CHANGE
C
	IF(MON_DVI_TYPES(PARAM_INX).EQ.MON_PAR_ACCUM) THEN
	    EXAM_VALUE = (NEW_VALUE - 
     *	    MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_LAST_VALUE) /
     *	    TIME_INTERVAL
	ENDIF
C
	IF(MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_PAR_INIT.LE.3) THEN
C
	    IF(MON_DVI_TYPES(PARAM_INX) .EQ. MON_PAR_HEX) GOTO 9000
C
	    IF (MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MIN_VALUE
     *		.EQ.'80000000'X) THEN
		MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MIN_VALUE =
     *		INT(EXAM_VALUE -
     *		INT(DBLE(ABS(EXAM_VALUE))*DBLE(LIM_PERCENT)/100.0))
	    ENDIF
C
	    IF (MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MAX_VALUE
     *	        .EQ.'7FFFFFFF'X) THEN
		MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MAX_VALUE =
     *		INT(EXAM_VALUE +
     *		INT(DBLE(ABS(EXAM_VALUE))*DBLE(LIM_PERCENT)/100.0))
	    ENDIF
C
	    GOTO 9000
	ENDIF
C
C	BIT-ORIENTED PARAMETERS SHOULD BE EQUAL
C
	IF(MON_DVI_TYPES(PARAM_INX) .EQ. MON_PAR_HEX) THEN
	  IF(NEW_VALUE .NE.
     *	    MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_LAST_VALUE) THEN
	    WRITE(LUN,10010)
     *	    IAM(),DISK_NAME,
     *	    IAM(),MON_DVI_NAMES(PARAM_INX),
     *	    IAM(),MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_LAST_VALUE,
     *	    IAM(),NEW_VALUE
	    IF(PARAM_INX.EQ.MON_DVI$_STS) THEN
	      CALL REPORT_DVI_STS (LUN,IEOR(NEW_VALUE,
     *	        MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_LAST_VALUE))
	    ENDIF
	  ENDIF
	  GOTO 9000
	ENDIF
C
C	PREPARE TO HANDLE CUMULATIVE PARAMETERES
C
	CUMULATIVE = ' '
	IF(MON_DVI_TYPES(PARAM_INX) .EQ. MON_PAR_ACCUM) THEN
	    CUMULATIVE = ' (/SEC)'
	ENDIF
C
C	MAKE THE CHECK
C
	IF(EXAM_VALUE.LT. 
     *	        MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MIN_VALUE) THEN
	    WRITE(LUN,10020)
     *	       IAM(),DISK_NAME,
     *	       IAM(),MON_DVI_NAMES(PARAM_INX),CUMULATIVE,
     *	       IAM(),MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MIN_VALUE,
     *	       IAM(),EXAM_VALUE
	    MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MIN_VALUE =
     *	       EXAM_VALUE
	ENDIF
C
	IF(EXAM_VALUE.GT. 
     *	        MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MAX_VALUE) THEN
	    WRITE(LUN,10030)
     *	       IAM(),DISK_NAME,
     *	       IAM(),MON_DVI_NAMES(PARAM_INX), CUMULATIVE,
     *	       IAM(),MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MAX_VALUE,
     *	       IAM(),EXAM_VALUE
	    MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_MAX_VALUE =
     *	       EXAM_VALUE
	ENDIF
C
9000	CONTINUE
	MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_LAST_RATE =
     *	(MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_NEW_VALUE -
     *	    MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_LAST_VALUE) /
     *	    TIME_INTERVAL
C
9100	CONTINUE
	MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_LAST_VALUE =
     *	    MON_DISK_TABLE(DISK_INX,PARAM_INX).MON_NEW_VALUE
C
10000	CONTINUE
C
	RETURN
C
10010	FORMAT(1X,A,'****DEVICE STATUS CHANGE: ',A,/,
     *         1X,A,'****PARAM: ',A,' (HEX)',/,
     *         1X,A,'****LAST STATUS:   ',Z9,/,
     *         1X,A,'****NEW  STATUS:   ',Z9,/)
C
10020	FORMAT(1X,A,'****DEVICE NEW MIN. VALUE: ',A,/,
     *         1X,A,'****PARAM: ',A,A,/,
     *         1X,A,'****PREV. MINIMUM: ',I11,/,
     *         1X,A,'****NEW   MINIMUM: ',I11,/)
C
10030	FORMAT(1X,A,'****DEVICE NEW MAX. VALUE: ',A,/,
     *         1X,A,'****PARAM: ',A,A,/,
     *         1X,A,'****PREV. MAXIMUM: ',I11,/,
     *         1X,A,'****NEW   MAXIMUM: ',I11,/)
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE MON_INIT_DISKS
C INITIALIZE MON_DISK_ITEMS IN 'MONGOLS' LOCAL COMMON.
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE MON_INIT_DISKS
	IMPLICIT NONE
C
        INCLUDE     '($SYSSRVNAM)'
        INCLUDE     '($DVIDEF)'
        INCLUDE     '($DCDEF)'
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
C***        INCLUDE 'INCLIB:GLOBAL.DEF'
C***        INCLUDE 'INCLIB:CONCOM.DEF'
C
        INTEGER*4   I,J
C
C	INITIALIZE FIELDS IN THE MON_DISK_TABLE
C
	DO 200 I=1,MON_MAX_DISKS
	    MON_DISKS(I).MON_DISK_STAT = MON_NO_DISK
	    DO 100 J=1,MON_MAX_DISK_PARAMS
C		    '80000000'X MEANS NOT INITIALIZED FOR 'MIN' FIELD
		MON_DISK_TABLE(I,J).MON_MIN_VALUE = '80000000'X
C		    '7FFFFFFF'X MEANS NOT INITIALIZED FOR 'MAX' FIELD
		MON_DISK_TABLE(I,J).MON_MAX_VALUE = '7FFFFFFF'X
C		    0 MEANS NOT INITIALIZED FOR ANY FIELD
		MON_DISK_TABLE(I,J).MON_PAR_INIT = 0
100	    CONTINUE
C
	    MON_DISK_TABLE(I,MON_DVI$_OPCNT).MON_MIN_VALUE = 0
	    MON_DISK_TABLE(I,MON_DVI$_OPCNT).MON_MAX_VALUE = 10	! OPS/SEC
C
	    MON_DISK_TABLE(I,MON_DVI$_SERIALNUM).MON_MIN_VALUE =
     *	       'FFFFFFFF'X
	    MON_DISK_TABLE(I,MON_DVI$_SERIALNUM).MON_MAX_VALUE = 
     *	       '7FFFFFFF'X	! OPS/SEC
C
200	CONTINUE
C
C	FILL-UP DISK NAMES
C
        MON_DISKS(1).MON_DISK_NAME = 'BACK'
        MON_DISKS(1).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(2).MON_DISK_NAME = 'CARX'
        MON_DISKS(2).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(3).MON_DISK_NAME = 'DRAW'
        MON_DISKS(3).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(4).MON_DISK_NAME = 'PRIM'
        MON_DISKS(4).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(5).MON_DISK_NAME = 'FILE'
        MON_DISKS(5).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(6).MON_DISK_NAME = 'SYSX'
        MON_DISKS(6).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(7).MON_DISK_NAME = 'VALX'
        MON_DISKS(7).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(8).MON_DISK_NAME = 'WORK'
        MON_DISKS(8).MON_DISK_STAT = MON_YES_DISK
CRXK        MON_DISKS(9).MON_DISK_NAME = 'XRAM'
CRXK        MON_DISKS(9).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(10).MON_DISK_NAME = 'MAG1'
        MON_DISKS(10).MON_DISK_STAT = MON_YES_DISK
        MON_DISKS(11).MON_DISK_NAME = 'MAG2'
        MON_DISKS(11).MON_DISK_STAT = MON_YES_DISK
C
C	PREPARE ITEM LIST  FOR 'GETDVI'
C
	DO 3000 I=1,MON_MAX_DISK_PARAMS
	    MON_DISK_ITEMS(I).BUFLEN = 0
	    MON_DISK_ITEMS(I).ITMCOD = 0
	    MON_DISK_ITEMS(I).BUFADR = 0
	    MON_DISK_ITEMS(I).LENADR = 0
3000	CONTINUE
C
	DO 4000 I=1,MON_DVI$_LAST_PARAM
	    MON_DISK_ITEMS(I).BUFLEN = 4
	    MON_DISK_ITEMS(I).LENADR = %LOC(MON_RETURN_LEN)
	    MON_DVI_TYPES(I) = MON_PAR_REGULAR
4000	CONTINUE
C
C???	MON_DVI_TYPES(MON_DVI$_TRANSCNT) = MON_PAR_ACCUM
	MON_DVI_TYPES(MON_DVI$_OPCNT) = MON_PAR_ACCUM
	MON_DVI_TYPES(MON_DVI$_ERRCNT) = MON_PAR_ACCUM
C
	MON_DVI_TYPES(MON_DVI$_DEVCHAR2) = MON_PAR_HEX
	MON_DVI_TYPES(MON_DVI$_DEVCHAR) = MON_PAR_HEX
	MON_DVI_TYPES(MON_DVI$_DEVCLASS) = MON_PAR_HEX
	MON_DVI_TYPES(MON_DVI$_OWNUIC) = MON_PAR_HEX
	MON_DVI_TYPES(MON_DVI$_STS) = MON_PAR_HEX
C
C	FILL-IN MON_DISK_ITEMS WITH VALUES THAT WE NEED
C
        MON_DISK_ITEMS(MON_DVI$_ALT_HOST_AVAIL).ITMCOD = 
     *	  DVI$_ALT_HOST_AVAIL
	MON_DVI_NAMES(MON_DVI$_ALT_HOST_AVAIL) = 
     *	  'DVI$_ALT_HOST_AVAIL - ALT. HOST AVAIL.'
C
        MON_DISK_ITEMS(MON_DVI$_CYLINDERS).ITMCOD = 
     *	  DVI$_CYLINDERS
	MON_DVI_NAMES(MON_DVI$_CYLINDERS) = 
     *	  'DVI$_CYLINDERS  - NUMBER OF CYLINDERS'
C
        MON_DISK_ITEMS(MON_DVI$_DEVBUFSIZ).ITMCOD = 
     *	  DVI$_DEVBUFSIZ
	MON_DVI_NAMES(MON_DVI$_DEVBUFSIZ) = 
     *	  'DVI$_DEVBUFSI   - DEVICE BUFFER SIZE'
C
        MON_DISK_ITEMS(MON_DVI$_DEVCLASS).ITMCOD = 
     *	  DVI$_DEVCLASS
	MON_DVI_NAMES(MON_DVI$_DEVCLASS) = 
     *	  'DVI$_DEVCLASS        - DEVICE CLASS'
C
        MON_DISK_ITEMS(MON_DVI$_DEVTYPE).ITMCOD = 
     *	  DVI$_DEVTYPE
	MON_DVI_NAMES(MON_DVI$_DEVTYPE) = 
     *	  'DVI$_DEVTYPE         - DEVICE TYPE'
C
        MON_DISK_ITEMS(MON_DVI$_ERRCNT).ITMCOD = 
     *	  DVI$_ERRCNT
	MON_DVI_NAMES(MON_DVI$_ERRCNT) = 
     *	  'DVI$_ERRCNT          - ERROR COUNT'
C
        MON_DISK_ITEMS(MON_DVI$_FREEBLOCKS).ITMCOD = 
     *	  DVI$_FREEBLOCKS
	MON_DVI_NAMES(MON_DVI$_FREEBLOCKS) = 
     *	  'DVI$_FREEBLOCKS - NUMBER OF FREE BLOCKS'
C
        MON_DISK_ITEMS(MON_DVI$_HOST_AVAIL).ITMCOD = 
     *	  DVI$_HOST_AVAIL
	MON_DVI_NAMES(MON_DVI$_HOST_AVAIL) = 
     *	  'DVI$_HOST_AVAIL      - HOST AVAILABLE'
C
        MON_DISK_ITEMS(MON_DVI$_MAXBLOCK).ITMCOD = 
     *	  DVI$_MAXBLOCK
	MON_DVI_NAMES(MON_DVI$_MAXBLOCK) = 
     *	  'DVI$_MAXBLOCK    - MAX NUMBER OF BLOCKS'
C
        MON_DISK_ITEMS(MON_DVI$_MAXFILES).ITMCOD = 
     *	  DVI$_MAXFILES
	MON_DVI_NAMES(MON_DVI$_MAXFILES) = 
     *	  'DVI$_MAXFILES    - MAX NUMBER OF FILES'
C
        MON_DISK_ITEMS(MON_DVI$_MOUNTCNT).ITMCOD = 
     *	  DVI$_MOUNTCNT
	MON_DVI_NAMES(MON_DVI$_MOUNTCNT) = 
     *	  'DVI$_MOUNTCNT    - MOUNT COUNT'
C
        MON_DISK_ITEMS(MON_DVI$_MSCP_UNIT_NUMBER).ITMCOD = 
     *	  DVI$_MSCP_UNIT_NUMBER
	MON_DVI_NAMES(MON_DVI$_MSCP_UNIT_NUMBER) = 
     *	  'DVI$_MSCP_UNIT_NUMBER - MSCP UNIT #'
C
        MON_DISK_ITEMS(MON_DVI$_OPCNT).ITMCOD = 
     *	  DVI$_OPCNT
	MON_DVI_NAMES(MON_DVI$_OPCNT) = 
     *	  'DVI$_OPCNT         - OPERATION COUNT'
C
        MON_DISK_ITEMS(MON_DVI$_OWNUIC).ITMCOD = 
     *	  DVI$_OWNUIC
	MON_DVI_NAMES(MON_DVI$_OWNUIC) = 
     *	  'DVI$_OWNUIC        - UIC OF THE OWNER'
C
        MON_DISK_ITEMS(MON_DVI$_RECSIZ).ITMCOD = 
     *	  DVI$_RECSIZ
	MON_DVI_NAMES(MON_DVI$_RECSIZ) = 
     *	  'DVI$_RECSIZ        - RECORD SIZE'
C
        MON_DISK_ITEMS(MON_DVI$_REFCNT).ITMCOD = 
     *	  DVI$_REFCNT
	MON_DVI_NAMES(MON_DVI$_REFCNT) = 
     *	  'DVI$_REFCNT   - # OF CHANNELS ASSIGNED'
C
        MON_DISK_ITEMS(MON_DVI$_SECTORS).ITMCOD = 
     *	  DVI$_SECTORS
	MON_DVI_NAMES(MON_DVI$_SECTORS) = 
     *	  'DVI$_SECTORS      - SECTORS PER TRACK'
C
        MON_DISK_ITEMS(MON_DVI$_SERIALNUM).ITMCOD = 
     *	  DVI$_SERIALNUM
	MON_DVI_NAMES(MON_DVI$_SERIALNUM) = 
     *	  'DVI$_SERIALNUM    - SERIAL NUMBER'
C
        MON_DISK_ITEMS(MON_DVI$_STS).ITMCOD = 
     *	  DVI$_STS
	MON_DVI_NAMES(MON_DVI$_STS) = 
     *	  'DVI$_STS          - STATUS'
C
        MON_DISK_ITEMS(MON_DVI$_TRACKS).ITMCOD = 
     *	  DVI$_TRACKS
	MON_DVI_NAMES(MON_DVI$_TRACKS) = 
     *	  'DVI$_TRACKS       - HOST TRACKS'
C
        MON_DISK_ITEMS(MON_DVI$_TRANSCNT).ITMCOD = 
     *	  DVI$_TRANSCNT
	MON_DVI_NAMES(MON_DVI$_TRANSCNT) = 
     *	  'DVI$_TRANSCNT     - TRANSACTIONS COUNT'
C
        MON_DISK_ITEMS(MON_DVI$_UNIT).ITMCOD = 
     *	  DVI$_UNIT
	MON_DVI_NAMES(MON_DVI$_UNIT) = 
     *	  'DVI$_UNIT         - UNIT NUMBER'
C
        MON_DISK_ITEMS(MON_DVI$_VOLCOUNT).ITMCOD = 
     *	  DVI$_VOLCOUNT
	MON_DVI_NAMES(MON_DVI$_VOLCOUNT) = 
     *	  'DVI$_VOLCOUNT     - VOLUMES IN THE SET'
C
        MON_DISK_ITEMS(MON_DVI$_VOLNUMBER).ITMCOD = 
     *	  DVI$_VOLNUMBER
	MON_DVI_NAMES(MON_DVI$_VOLNUMBER) = 
     *	  'DVI$_VOLNUMBER    - VOLUME # IN THE SET'
C
        MON_DISK_ITEMS(MON_DVI$_VOLSETMEM).ITMCOD = 
     *	  DVI$_VOLSETMEM
	MON_DVI_NAMES(MON_DVI$_VOLSETMEM) = 
     *	  'DVI$_VOLSETMEM    - VOLUME SET DEVICE'
C
        MON_DISK_ITEMS(MON_DVI$_VPROT).ITMCOD = 
     *	  DVI$_VPROT
	MON_DVI_NAMES(MON_DVI$_VPROT) = 
     *	  'DVI$_VPROT       - PROTECTION MASK'
C
        MON_DISK_ITEMS(MON_DVI$_DEVCHAR).ITMCOD = 
     *	  DVI$_DEVCHAR
	MON_DVI_NAMES(MON_DVI$_DEVCHAR) = 
     *	  'DVI$_DEVCHAR - DEVICE CHARACTERISTICS'
C
        MON_DISK_ITEMS(MON_DVI$_DEVCHAR2).ITMCOD = 
     *	  DVI$_DEVCHAR2
	MON_DVI_NAMES(MON_DVI$_DEVCHAR2) = 
     *	  'DVI$_DEVCHAR2 - DEVICE ADDNL. CHARACT.'
C
	RETURN
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE NEXT_DISK(DISK_INX,DISK_NAME,FLAG)
C OBTAINS THE STATUS PARAMETERS OF THE SPECIFIED DISK AND FOR EACH 
C PARAMETER CALLS 'CHECK_DISK_PARAM' ROUTINE. PARAMETERS
C ARE KEPT IN THE 'MONGOLS' LOCAL COMMON. THIS COMMON IS INIITIALIZED
C BY MON_INIT_DISKS AND MON_SET_DISK ROUTINES.
C
C INPUT:
C	DISK_INX - DISK INDEX INTO MON_DISK_TABLE
C	DISK_NAME - DISK NAME
C	FLAG - ONE OF: MON_LEARN,MON_WATCH,MON_REPORT
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE NEXT_DISK(LUN,DISK_INX,DISK_NAME,FLAG)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
	INCLUDE '(LIB$ROUTINES)'
	INCLUDE '($LIBDTDEF)'
C
	INTEGER*4   DISK_INX,LUN
	CHARACTER   DISK_NAME*(*)
	INTEGER*4   FLAG
C
        INTEGER*4   I, STAT
C
C	GET TIME NOW
C
	STAT = LIB$CVT_FROM_INTERNAL_TIME(LIB$K_SECOND_OF_DAY,
     *	      TIME_NOW,)
	IF(.NOT.STAT) THEN
	    CALL LIB$SIGNAL(%VAL(STAT))
	ENDIF
C
C	FILL-IN PARAMETER TABLE FOR 'GEDVI'
C
D	TYPE *,IAM(),'NEXT DISK IS ',DISK_NAME
C
	CALL MON_SET_DISK(DISK_INX)
C
	CALL GET_FULL_DVI(LUN,DISK_NAME,DISK_INX,STAT)
C
	IF (STAT .EQ. 0) THEN
	    GOTO 10000
	ENDIF
C
	IF(FLAG.EQ.MON_REPORT) THEN
	    WRITE(LUN,*) IAM(),
     *	      'FOLLOWING ARE PARAMETERS FOR THE DEVICE ',DISK_NAME
	ENDIF
C
C
C	GET TIME NOW
C
	STAT = LIB$CVT_FROM_INTERNAL_TIME(LIB$K_SECOND_OF_DAY,
     *	      TIME_NOW,)
	IF(.NOT.STAT) THEN
	    CALL LIB$SIGNAL(%VAL(STAT))
	ENDIF
C
C	TIME INTERVAL IS IN SECONDS
C
	TIME_INTERVAL = (TIME_NOW - MON_DISK_LAST_TIMES(DISK_INX))
	IF(TIME_INTERVAL.LT.1) TIME_INTERVAL = 1    ! JUST IN CASE...
C
	DO 1000 I=1,MON_DVI$_LAST_PARAM
	    IF(FLAG.EQ.MON_REPORT) THEN
	      IF(MON_DVI_TYPES(I) .EQ. MON_PAR_HEX) THEN
		WRITE (LUN,10001)IAM(),MON_DVI_NAMES(I),
     *		  MON_DISK_TABLE(DISK_INX,I).MON_NEW_VALUE
		  IF(I.EQ.MON_DVI$_STS) THEN
		    CALL REPORT_DVI_STS
     *		      (LUN,MON_DISK_TABLE(DISK_INX,I).MON_NEW_VALUE)
		  ENDIF
	      ELSE
		WRITE (LUN,10002)IAM(),MON_DVI_NAMES(I),
     *		  MON_DISK_TABLE(DISK_INX,I).MON_NEW_VALUE
	      ENDIF
	    ENDIF
	    CALL CHECK_DISK_PARAM(LUN,DISK_INX,I,DISK_NAME)
1000	CONTINUE
C
9000	CONTINUE
C
	MON_DISK_LAST_TIMES(DISK_INX) = TIME_NOW
C
10000	CONTINUE
C
	RETURN
C
10001	FORMAT(1X,A,A,Z9,' (HEX)')
10002	FORMAT(1X,A,A,I11)
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C GET_FULL_DVI(NAME,DISK_INX,STATUS)
C
C GETS ALL PARAMETERS FOR THE DEVICE WITH THE SPECIFIED NAME
C RETURNS STATUS=1 IF OK, 0 OTHERWISE
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_FULL_DVI(LUN,NAME, DISK_INX, STATUS)
	IMPLICIT NONE
C
        INCLUDE     '($SYSSRVNAM)'
        INCLUDE     '($DVIDEF)'
        INCLUDE     '($SSDEF)'
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
C
	CHARACTER*1 BELL/Z07/
	CHARACTER   NAME*(*)
	INTEGER*4   STATUS, DISK_INX, ST, IOSB(2), NAME_LEN,LUN
C
D	INTEGER*4   I
C
	STATUS = 0		! BAD STATUS
C
	NAME_LEN = INDEX(NAME,' ') - 1
	IF (NAME_LEN.LE.0) THEN
	    NAME_LEN = LEN(NAME)
	ENDIF
C
	ST = SYS$GETDVIW( ,,NAME(1:NAME_LEN),MON_DISK_ITEMS(1),IOSB,,,)
C
C	IF DEVICE DOES NOT EXIT (SWITCHABLE) - REPORT THE ERROR
C
        IF(.NOT.ST)THEN
	  IF(MON_DISKS(DISK_INX).MON_DISK_STAT.EQ.MON_YES_DISK) THEN
	    MON_DISKS(DISK_INX).MON_DISK_STAT = MON_UNKN_DISK
	    WRITE (LUN, 10010) IAM(), NAME
	    IF(MON_OPER_MESSAGES) THEN
		CALL OPSTXT(' THE DEVICE '//NAME//' IS UNKNOWN !!'//
     *                       BELL//BELL//BELL)
	    ENDIF
	  ENDIF
          GOTO 2000
        ENDIF
C
	MON_DISKS(DISK_INX).MON_DISK_STAT = MON_YES_DISK
	STATUS = 1		! GOOD STATUS
C
2000	CONTINUE
C
	RETURN
10010	FORMAT(1X,A,'****THE DEVICE:::: ',A,
     *              ' ---- IS UNKNOWN ****',3A1/)
C
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE MON_SET_DISK(DISKX)
C FILL-IN DISK-DEPENDENT PART OF DISK_ITEMS IN THE 'MONGOLS' LOCAL COMMON.
C INPUT:
C	DISKX - DISK INDEX INTO MON_DISK_TABLE
C
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE MON_SET_DISK(DISKX)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
C
        INTEGER*4   DISKX,I
C
C
	DO 1000 I=1,MON_DVI$_LAST_PARAM
	    MON_DISK_ITEMS(I).BUFADR = 
     *	    %LOC(MON_DISK_TABLE(DISKX,I).MON_NEW_VALUE)
1000	CONTINUE
C
	RETURN
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE CHECK_GAME
C
C CHECKS GAME-SPECIFIC INFORMATION
C---------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE CHECK_GAME(LUN)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:CONCOM.DEF'
        INCLUDE 'INCLIB:LOGCOM.DEF'
        INCLUDE 'INCLIB:AGTCOM.DEF'
        INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
        INCLUDE 'INCLIB:ENCCOM.DEF'
        INCLUDE 'INCLIB:X2XQUE.DEF'
C**	INCLUDE 'INCLIB:PRMLOG.DEF'
        INCLUDE 'INCLIB:QUECOM.DEF'
C
	INTEGER*4   LUN
C
	INTEGER*4   Q_IMG_SIZE
	PARAMETER   (Q_IMG_SIZE=3)
C
	CHARACTER*1 BELL/Z07/
	INTEGER*4   Q_INFO(Q_IMG_SIZE,NUMAPPQUE)
	INTEGER*4   FRELST(Q_IMG_SIZE)
	INTEGER*4   INPLST(Q_IMG_SIZE)
	INTEGER*4   OUTLST(Q_IMG_SIZE)
	INTEGER*4   DECLST(Q_IMG_SIZE)
	INTEGER*4   Q_TEMP(Q_IMG_SIZE)
	LOGICAL	    Q_INITIALIZED/.FALSE./
	VOLATILE    Q_INITIALIZED
C
        INTEGER*4   I
C
C	TAPE SWITCH SHOULD OCCUR EVERY 'SER_PER_TAPE' SERIAL  NUMBERS
C	ASSUMING 1600 BPI, 8KB BLOCKS WITH 125 SER NRS PER BLOCK,
C	1'' INTERBLOCK GAPS
C
C	V02  UPDATED FOR 6250 BPI.
C
C	V03  AND UPDATED BACK TO 1600 BPI FOR CZECH AND SLOVAKIA
C
C       V04  AND UPDATED FORTH TO XXXXX BPI FOR 6 GB CARTRIDGE IN ESTONIA
C	     (6 GB_PER_TAPE / 8 KB_PER_BLOCK * 125 SER_PER_BLOCK = 94,750,000
C	      SERIAL NUMBERS). TO BE ON THE SAFE SIDE SIGNAL AFTER 50,000,000
C	      SERIAL NUMBERS). 
C
	INTEGER*4   SER_PER_TAPE
C *V02* PARAMETER   (SER_PER_TAPE=500000)	    ! ORIGINAL VALUE
C *V03*	PARAMETER   (SER_PER_TAPE=2310000)	    ! INTRODUCED IN V02
C *V04* PARAMETER   (SER_PER_TAPE=500000)	    ! INTRODUCED IN V03
	PARAMETER   (SER_PER_TAPE=50000000)	    ! INTRODUCED IN V04
C
C	CHECK FULLNESS OF THE TMF 
C
10000	  CONTINUE
C
C	CHECK GAME QUEUES TO BE SERVICED -
C	IF QUE SIZE IS NOT 0 AND HAS THE SAME 'QUE_IMAGE' SOMETHING
C	IS WRONG 
C
	IF(.NOT.Q_INITIALIZED) GOTO 9000

C
C	CHECK QUEUES
C
	DO 2100 I=1,NUMAPPQUE
	    CALL QUE_IMAGE(QUETAB(1,I),Q_TEMP,Q_IMG_SIZE)
	    CALL QUE_COMP(LUN,Q_IMG_SIZE,Q_INFO(1,I),Q_TEMP,CXTSKNAM(I))
2100	CONTINUE
C
	CALL QUE_IMAGE(FREEQ,Q_TEMP,Q_IMG_SIZE)
C***	CALL QUE_COMP(LUN,Q_IMG_SIZE,FRELST,Q_TEMP,'.ANY.')
C
	CALL QUE_IMAGE(INQUE,Q_TEMP,Q_IMG_SIZE)
	CALL QUE_COMP(LUN,Q_IMG_SIZE,INPLST,Q_TEMP,'ENCPRO')
C
	CALL QUE_IMAGE(X2X_OUTPUT,Q_TEMP,Q_IMG_SIZE)
	CALL QUE_COMP(LUN,Q_IMG_SIZE,OUTLST,Q_TEMP,'X2XMGR')
C
	CALL QUE_IMAGE(GAME_OUTQUE,Q_TEMP,Q_IMG_SIZE)
	CALL QUE_COMP(LUN,Q_IMG_SIZE,DECLST,Q_TEMP,'ENCPRO')
C
3000	CONTINUE
C
C	IF TAPE SWITCH OCCURED, NO NEED TO TELL THE OPERATOR -
C	JUST REMEMBER THE SERIAL NUMBER
C
	IF(P(TAPESW).EQ.0) GOTO 4000	    ! NO TAPE 
C
	IF(MON_TAPESW_OLD.NE.P(TAPESW)) THEN
	    MON_TAPESW_SERIAL = NXTSER
	    MON_TAPESW_OLD = P(TAPESW)
	    GOTO 4000
	ENDIF
C
C	TAPE SWITCH DID NOT OCCUR - CHECK IF SERIAL NUMBER 
C	IN HIGHER THAN 'SER_PER_TAPE' TO REQUEST THE TAPE SWITCH
C
D	TYPE *,IAM(),'NXTSER,TAPESW_SERIAL= ',NXTSER,MON_TAPESW_SERIAL
	IF((NXTSER-MON_TAPESW_SERIAL).GE.SER_PER_TAPE) THEN
	    WRITE(LUN,13100),IAM()
	    CALL OPSTXT('ITS TIME TO SWITCH TAPES !!!'//BELL//BELL//BELL)
	ENDIF
C
4000	CONTINUE
C
9000	CONTINUE
C
	Q_INITIALIZED = .TRUE.
C
C BUILD QUEUE IMAGES
C
	DO 9100 I=1,NUMAPPQUE
	    CALL QUE_IMAGE(QUETAB(1,I),Q_INFO(1,I),Q_IMG_SIZE)
9100	CONTINUE
	CALL QUE_IMAGE(FREEQ,FRELST,Q_IMG_SIZE)
	CALL QUE_IMAGE(INQUE,INPLST,Q_IMG_SIZE)
	CALL QUE_IMAGE(X2X_OUTPUT,OUTLST,Q_IMG_SIZE)
	CALL QUE_IMAGE(GAME_OUTQUE,DECLST,Q_IMG_SIZE)
C
	RETURN
C
13100	  FORMAT(1X,A,'**** IT IS TIME TO SWITCH TAPES !!!!!',3A1,/)
C
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE TO BUILD SYSTEM QUEUE IMAGES 
C
C CALLING SEQUENCE:
C     CALL  QUE_IMAGE(LIST,IMAGE,LENGTH)
C INPUT
C     LIST   - WS LIST DATA STRUCTURE.
C     LENGTH - LENGTH OF QUEUE IMAGE
C OUTPUT
C     IMAGE  - QUEUE IMAGE
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE   QUE_IMAGE(LIST,IMAGE,LENGTH)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLIST.DEF'
C
	INTEGER*4   LIST(*)
	INTEGER*4   LENGTH
	INTEGER*4   IMAGE(LENGTH)
 
	INTEGER*4 I, LIMIT, TOP, USED
	INTEGER*4 J, IND
C
C CLEAR QUEUE IMAGE
C
	DO 10 I=1,LENGTH
	  IMAGE(I)=0
10	CONTINUE
C
C GET PARAMETERS FROM TOP OF LIST
C
	LIMIT = LIST(GLIST_MAX_OFFSET) - GLIST_START
	IF (LIMIT .LE. 0) THEN
	    IMAGE(1) = -1
	    RETURN
	ENDIF
	TOP = LIST(GLIST_TOP)
	CALL LISTSIZE( LIST, USED )
D	TYPE *,IAM(),'NUMBER OF ELEMENTS ON THE QUE = ', USED
C
C
C BUILD NEW QUEUE IMAGE
C
	IMAGE(1)=USED
	IF (USED.EQ.0)     GOTO 9000
	IF (LENGTH .EQ. 1) GOTO 9000
C
	J=2
	IND = TOP
	DO 20 I = 1, USED
	  IND = IND + 1
	  IF(IND.GT.LIST( GLIST_MAX_OFFSET))THEN
	    IND = GLIST_START
	  ENDIF
	  IMAGE(J) = LIST(IND)
	  J = J + 1
	  IF( J.GT.LENGTH ) GOTO 9000
20	CONTINUE
C
9000	CONTINUE
	RETURN
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C SUBROUTINE TO COMPARE TWO SYSTEM QUEUE IMAGES 
C
C CALLING SEQUENCE:
C	 CALL QUE_COMP(Q_IMG_SIZE,Q_IMG_1,Q_IMG_2,TSK_NAME)
C INPUT
C	INTEGER*4 Q_IMG_SIZE
C	INTEGER*4 Q_IMG_1(Q_IMG_SIZE) - 1ST QUE IMGAE
C	INTEGER*4 Q_IMG_2(Q_IMG_SIZE) - 2ND QUE IMAGE
C	CHARACTER TSK_NAME*(*)	    - TASK NAME THAT SERVICES THE QUE
C OUTPUT
C	NONE
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE QUE_COMP(LUN,Q_IMG_SIZE,Q_IMG_1,Q_IMG_2,TSK_NAME)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MONGOLS.DEF'
        INCLUDE 'INCLIB:GLOBAL.DEF'                               !V09
        INCLUDE 'INCLIB:PROCOM.DEF'                               !V09
        INCLUDE 'INCLIB:TASKID.DEF'                               !V09
        INCLUDE 'INCLIB:QUECOM.DEF'                               !V09
C
	CHARACTER*1 BELL/Z07/
	INTEGER*4 Q_IMG_SIZE,LUN
	INTEGER*4 Q_IMG_1(Q_IMG_SIZE)	    ! 1ST QUE IMGAE
	INTEGER*4 Q_IMG_2(Q_IMG_SIZE)	    ! 2ND QUE IMAGE
	CHARACTER TSK_NAME*(*)		    ! TASK NAME THAT SERVICES THE QUE
        CHARACTER*8 TASK                                          !V09
        CHARACTER*60 OPSSTR                                       !V09
        INTEGER*4 TASK_NO, BUF, ST, TSKSTS                        !V09
        INTEGER*4 FNSH, XEND, K                                   !V09
C
	INTEGER*4    I
C
C	IF EITHER QUE IS EMPTY - RETURN
C
	IF(Q_IMG_1(1).LE.0) GOTO 10000
	IF(Q_IMG_2(1).LE.0) GOTO 10000
C
C	IF IMAGES ARE THE SAME - REPORT AN ERROR
C
	DO 1000 I=1,Q_IMG_SIZE
	    IF(Q_IMG_1(I).NE.Q_IMG_2(I)) GOTO 10000
1000	CONTINUE
C
C	REPORT AN ERROR
C
	WRITE(LUN,10100),IAM(),TSK_NAME,Q_IMG_1(1)
C	CRITICAL MESSAGES ARE SENT TO THE OPERATOR CONSOLE
C	WHEN RUNNING AS A SUBPROCESS
	IF(MON_OPER_MESSAGES) THEN
	    CALL OPSTXT('*** TASK '//TSK_NAME//' HUNG !!'//BELL//BELL//BELL)
	    CALL OPS('ELEMENTS ON THE QUEUE',Q_IMG_1(1), 0)
C V09...
            TASK = TSK_NAME
            TASK_NO = 0
            DO I=1,NUMAPPQUE
              IF(CXTSKNAM(I).EQ.TASK)THEN
                TASK_NO=I
                GOTO 9000
              ENDIF
            ENDDO
9000        CONTINUE
            IF(TASK_NO.EQ.0)GOTO 10000
            CALL TOPQUE(TASK_NO,BUF)
            CALL OPSTXT(' ')
            WRITE(OPSSTR,'(A,I10)') 'BUFFER WHICH CAUSED THE ISSUE: ',BUF
            CALL OPSTXT(OPSSTR)
C
C IF TASK IS DEAD, THEN EMPTY BUF AND RESTART THE TASK
            CALL STTSK(TSKNAM(TASK_NO),TSKSTS,ST)
            IF (ST.EQ.4) THEN
C
               WRITE(OPSSTR,9010) BUF,HPRO(TERNUM,BUF),PRO(SERIAL,BUF)
9010           FORMAT('Buffer ',I4,' terminal ',I5,' serial',I9)
               CALL OPSTXT(OPSSTR)

               WRITE(OPSSTR,9020) HPRO(INPLEN,BUF),HPRO(TRCODE,BUF),
     *                            DISTIM(PRO(TSTAMP,BUF))
9020           FORMAT('length ',I3,' trcode ',I3,' time ',A8)
               CALL OPSTXT(OPSSTR)

               WRITE(OPSSTR,9030) HPRO(NUMLRC,BUF)
9030           FORMAT('log records ',I2)
               CALL OPSTXT(OPSSTR)

               FNSH = (INPTAB*2) - 2
               DO I = 1,FNSH,12
                  XEND = MIN(I+11,FNSH)
                  WRITE(OPSSTR,2040) (HPRO(K,BUF),K=I,XEND)
2040              FORMAT(6(X,Z4,'/',Z4.4))
                  CALL OPSTXT(OPSSTR)
               ENDDO
               CALL OPSTXT(' ')

               FNSH = BINPTAB + 240    ! PRINT 240 BYTES OF TRANSACTION BODY
               CALL OPSTXT('Transaction body')
               DO I = BINPTAB,FNSH,24
                  XEND = MIN(I+23,FNSH)
                  WRITE(OPSSTR,2050) (BPRO(K,BUF),K=I,XEND)
2050              FORMAT(6(2X,4Z2.2))
                  CALL OPSTXT(OPSSTR)
               ENDDO
               CALL OPSTXT(' ')

               IF(.NOT.(TASK_NO.EQ.EUI.OR.TASK_NO.EQ.EUO.OR.TASK_NO.EQ.EUC))THEN
                  CALL DQUTRA(TASK_NO,BUF)
                  CALL OPSTXT('TASK '//TSK_NAME//
     *                     ' IS DEAD - RESTARTING AUTOMATICALLY...')
                  CALL OPSTXT(' ')
                  CALL RUNTSK_DET(TSKNAM(TASK_NO))
               ELSE
                  CALL OPSTXT('TASK '//TSK_NAME//' IS DEAD')
                  CALL OPSTXT(' ')
               ENDIF 
            ENDIF
C...V09
	ENDIF
C
10000	  CONTINUE
C
	RETURN
C
10100	FORMAT(1X,A,'**** TASK ',A,' HUNG !! - ELEMENTS ON THE QUE: ',I4,
     *	  3A1,/)
C
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C GET_PROC_NAME(PID_REQUEST,PID,PRC_NAME, INX)
C Calling sequence:
C	CALL GET_PROC_NAME(PID__REQUEST,PID, PRC_NAME, INX)
C INPUT:
C	INTEGER*4  PID_REQUEST	This is a requested PID of the process.
C				(Could be -1 for all)
C	INTGERE*4  INX	PROCESS INDEX FOR REPORTING
C OUTPUT:
C	INTEGER*4   PID		This is an ACTUAL PID of the process.
C	CHARACTER*15 PRC_NAME	This is the name of the process.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_PROC_NAME(LUN,PID_REQUEST,PID, PRC_NAME, INX)
	IMPLICIT NONE
C
	INCLUDE	    'INCLIB:SYSPARAM.DEF'
	INCLUDE	    'INCLIB:SYSEXTRN.DEF'
	INCLUDE	    'INCLIB:MONGOLS.DEF'
	INCLUDE	    '($SYSSRVNAM)'
	INCLUDE	    '($JPIDEF)'
	INCLUDE	    '($SSDEF)'
C
	INTEGER*4      PID_REQUEST,PID, INX,LUN
	CHARACTER*15   PRC_NAME
	INTEGER*4      NAME_LENGTH, STATUS, I, PID_RET, PID_LEN
C
	RECORD	    /JPISTRUC/ ITEMLIST(3)
C
	INTEGER*4   ST
C
	ITEMLIST(1).BUFLEN = 15
	ITEMLIST(1).ITMCOD = JPI$_PRCNAM
	ITEMLIST(1).BUFADR = %LOC(PRC_NAME)
	ITEMLIST(1).LENADR = %LOC(NAME_LENGTH)
C
	ITEMLIST(2).BUFLEN = 4
	ITEMLIST(2).ITMCOD = JPI$_PID
	ITEMLIST(2).BUFADR = %LOC(PID_RET)
	ITEMLIST(2).LENADR = %LOC(PID_LEN)
C
	ITEMLIST(3).BUFLEN = 0			!TO TERMINATE LIST
	ITEMLIST(3).ITMCOD = 0			!TO TERMINATE LIST V04
C
D	TYPE *,IAM(),'GET_PROC_NAME: REQUESTED PID IS ',PID_REQUEST
	ST = SYS$GETJPIW( ,PID_REQUEST,,ITEMLIST(1),,,)
	IF(ST.EQ.SS$_NOMOREPROC.AND.PID_REQUEST.LE.-1) THEN
	    STATUS = 4
	    PRC_NAME = 'ALL'
	    NAME_LENGTH = 3
	    GOTO 10000
	ENDIF
C
	IF(.NOT.ST) THEN
	    STATUS = 4
	    PRC_NAME = 'none'
	    NAME_LENGTH = 4
	    GOTO 10000
	ENDIF
C
D	TYPE *,IAM(),'GET_PROC_NAME: PID RETURNED=',PID_RET
	STATUS = 0
	PID = PID_RET
C
1000	CONTINUE
C
	DO 2000 I=NAME_LENGTH+1,15
	    PRC_NAME(I:I) = ' '
2000	CONTINUE
C
	WRITE(LUN, 10100)IAM(), INX, ': Will monitor PID: ', PID,
     *	      ' name: ', PRC_NAME
C
10000	CONTINUE
C
10100	    FORMAT(1X,A,I3,A,Z9,A,A15)
	RETURN
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C GET_PROC_ID(PRC_NAME,PID,INX)
C Calling sequence:
C	CALL GET_PROC_ID(PRC_NAME, PID,INX)
C INPUT:
C	CHARACTER*(*) PRC_NAME	This is the name of the process.
C	INTEGER*4 INX		PROCESS INDEX FOR REPORTING
C OUTPUT:
C	INTEGER*4 PID		This is a PID of the process.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_PROC_ID(LUN,PRC_NAME, PID, INX)
	IMPLICIT NONE
C
	INCLUDE	    'INCLIB:SYSPARAM.DEF'
	INCLUDE	    'INCLIB:SYSEXTRN.DEF'
	INCLUDE	    'INCLIB:MONGOLS.DEF'
	INCLUDE	    '($SYSSRVNAM)'
	INCLUDE	    '($JPIDEF)'
C
	INTEGER*4   PID, INX
	INTEGER*4   LUN
	CHARACTER   PRC_NAME*(*)
	INTEGER*4   PID_LENGTH, STATUS
C
	RECORD	    /JPISTRUC/ ITEMLIST(2)
C
	INTEGER*4   ST, I
C
	ITEMLIST(1).BUFLEN = 4
	ITEMLIST(1).ITMCOD = JPI$_PID
	ITEMLIST(1).BUFADR = %LOC(PID)
	ITEMLIST(1).LENADR = %LOC(PID_LENGTH)
C
	ITEMLIST(2).BUFLEN = 0			!TO TERMINATE LIST
	ITEMLIST(2).ITMCOD = 0			!TO TERMINATE LIST V04
C
	I = INDEX(PRC_NAME, ' ')
        IF(I.EQ.0)I=LEN(PRC_NAME)+1
C
	ST = SYS$GETJPIW( ,,PRC_NAME(1:I-1),ITEMLIST(1),,,)
	IF(.NOT.ST) THEN
	    STATUS = 4
	    PID = -2
	ELSE
	    STATUS = 0
	ENDIF
C
10000	CONTINUE
C
	WRITE(LUN, 10100)IAM(),INX,': Game process: ',
     *	      PRC_NAME, ' pid= ',PID
10100	    FORMAT(1X,A,I3,A,A15,A,Z9)
	RETURN
	END
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C MAKE_FULL_NAM (SHORT_NAME, FULL_NAME)
C
C INPUT:
C	CHARACTER*8 SHORT_NAME
C OUTPUT:
C	CHARACTER*15 LONG_NAME
C----------------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE MAKE_FULL_NAME (SHORT_NAME, LONG_NAME)
	IMPLICIT NONE
C
	CHARACTER   SHORT_NAME*(*), LONG_NAME*(*)
C
        INTEGER*4   I4PREFIXLEN, NAMLEN
        INTEGER*4   I4PREFIX
        CHARACTER   CXPREFIX*4
        EQUIVALENCE (I4PREFIX,CXPREFIX)
C
        CALL GETPRFX( I4PREFIX, I4PREFIXLEN )
        NAMLEN=INDEX(SHORT_NAME,' ')
        IF(NAMLEN.EQ.0)NAMLEN=LEN(SHORT_NAME)+1
C
	LONG_NAME = CXPREFIX(1:I4PREFIXLEN)//SHORT_NAME(1:NAMLEN-1)
C
	RETURN
C
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C FIND_NEW_PROCESSES()
C	- FIND ALL NEW PROCESSES IN THE SYSTEM
C INPUT:
C	NONE
C OUTPUT:
C	NONE
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE FIND_NEW_PROCESSES(LUN)
	IMPLICIT NONE
C
	INCLUDE	    'INCLIB:SYSPARAM.DEF'
	INCLUDE	    'INCLIB:SYSEXTRN.DEF'
	INCLUDE	    'INCLIB:MONGOLS.DEF'
	INCLUDE	    '($SYSSRVNAM)'
	INCLUDE	    '($JPIDEF)'
	INCLUDE	    '($SSDEF)'
C
	INTEGER*4      PID_REQUEST, I,LUN
	CHARACTER*15   PRC_NAME, PRC_NAME_WITH_SPACES
	INTEGER*4      NAME_LENGTH, FREE_INX, PID_RET, PID_LEN
C
	RECORD	    /JPISTRUC/ ITEMLIST(3)
C
	INTEGER*4   ST
C
	ITEMLIST(1).BUFLEN = 15
	ITEMLIST(1).ITMCOD = JPI$_PRCNAM
	ITEMLIST(1).BUFADR = %LOC(PRC_NAME)
	ITEMLIST(1).LENADR = %LOC(NAME_LENGTH)
C
	ITEMLIST(2).BUFLEN = 4
	ITEMLIST(2).ITMCOD = JPI$_PID
	ITEMLIST(2).BUFADR = %LOC(PID_RET)
	ITEMLIST(2).LENADR = %LOC(PID_LEN)
C
	ITEMLIST(3).BUFLEN = 0			!TO TERMINATE LIST
	ITEMLIST(3).ITMCOD = 0			!TO TERMINATE LIST V04
C
C	START WITH -1 AND SCAN ALL PROCESSES IN THE SYSTEM
C
	PID_REQUEST = -1
C
1000	CONTINUE
	ST = SYS$GETJPIW( ,PID_REQUEST,,ITEMLIST(1),,,)
	IF(ST.EQ.SS$_NOMOREPROC) THEN
C
C	    NO PROCESSES FOUND - RETURN 
C
	    GOTO 10000
	ENDIF
C
	IF(.NOT.ST) THEN
	    CALL LIB$SIGNAL(%VAL(ST))
	    GOTO 10000
	ENDIF
D	TYPE *,IAM(),'FIND_NEW_PROCESSES: ',PID_RET,PRC_NAME
C
C	SCAN PROCESS TABLE AND CHECK FOR EXISTANCE OF THE PID.
C	IF EXISTS, WE ALREADY MONITORING IT, ASK SYSTEM FOR ANOTHER PROC.
C	FOR EFFICIENCY IT IS BETTER TO HAVE DIFFERENT LOOPS
C
	DO 1200 I=1,MON_MAX_PROCS
	    IF (MON_PROCS(I).MON_PROC_ID.EQ.PID_RET) THEN
		GOTO 1000		! GET ANOTHER PROCESS
	    ENDIF
1200	CONTINUE
C
C	CHECK FOR THE NAME - IF EXISTS, CHANGE THE STATUS AND
C	SAVE THE PID, REPORT REAPPEARANCE.
C	ALSO FIND 'FREE SLOT' IN THE TABLE FOR TOTALLY NEW PROCESS
C
	PRC_NAME_WITH_SPACES = PRC_NAME(1:NAME_LENGTH)//
     *	  '               '
	FREE_INX = -1
C
	DO 1400 I=1,MON_MAX_PROCS
	    IF(MON_PROCS(I).MON_PROC_ID.GE.-1) GOTO 1400
C
	    IF (MON_PROCS(I).MON_PROC_NAME.EQ.
     *		PRC_NAME_WITH_SPACES) THEN
		WRITE(LUN, 10100)IAM(),I,': Restarted process: ',
     *		  PRC_NAME_WITH_SPACES, ' pid= ',PID_RET
  		MON_PROCS(I).MON_PROC_ID = PID_RET
		IF(MON_PROCS(I).MON_PROC_NAME(1:4).EQ.MON_PROJ_NAME) THEN
		  MON_PROCS(I).MON_PROC_STAT = MON_YES_PROC
		ELSE
		  MON_PROCS(I).MON_PROC_STAT = MON_YES_PROC
		ENDIF
		CALL PROC_INIT_PAR(I)
		GOTO 1000		! GET ANOTHER PROCESS
	    ENDIF
	    IF(MON_PROCS(I).MON_PROC_ID.LE.-2
     *	    .AND..NOT.MON_PROCS(I).MON_PROC_BY_NAME) THEN
C		MAY REUSE THE SLOT
		IF(FREE_INX.LT.0) THEN
		    FREE_INX=I
		ENDIF
	    ENDIF
1400	CONTINUE
C
C	NO MATCHED PROCESS - REPORT A NEW PROCESS
C
	WRITE(LUN, 10100)IAM(),FREE_INX,': New process: ',
     *	      PRC_NAME_WITH_SPACES, ' pid= ',PID_RET
C
C	CHECK IF THERE IS A SLOT
C
	IF(FREE_INX.LT.0) THEN
C	    NO SLOT - REPORT AN ERROR
	    WRITE(LUN,10200) IAM(), 'No more slots to monitor the process: ',
     *	      PRC_NAME
	      CALL OPSTXT('No more slots to monitor the process: '//PRC_NAME)
	    GOTO 10000
	ENDIF
C
C	THERE IS A SLOT - FILL IT
C
	I = FREE_INX
	MON_PROCS(I).MON_PROC_STAT = MON_YES_PROC
	MON_PROCS(I).MON_PROC_BY_NAME = .FALSE.
	MON_PROCS(I).MON_PROC_ID = PID_RET
	MON_PROCS(I).MON_PROC_NAME = PRC_NAME_WITH_SPACES
	CALL INIT_ANY_PROC (I)
C
C	CONTINUE SCAN OF ALL SYSTEM PROCESSES
C
	GOTO 1000
C
10000	CONTINUE
C
	RETURN
10100	FORMAT(1X,A,I3,A,A20,A,Z9,3A1,/)
10101	FORMAT(1X,A,3A1,/)
10102	FORMAT(1X,A,I3,A,A20,A,Z9,3A1,/)
10200	FORMAT(1X,A,A,A,3A1)
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C INIT_ANY_PROC(I)
C
C---------------------------------------------------------------------------
C	
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE INIT_ANY_PROC(I)
	IMPLICIT NONE
C
	INCLUDE	    'INCLIB:SYSPARAM.DEF'
	INCLUDE	    'INCLIB:SYSEXTRN.DEF'
	INCLUDE	    'INCLIB:MONGOLS.DEF'
	INCLUDE	    '($SYSSRVNAM)'
	INCLUDE	    '($JPIDEF)'
C
	INTEGER*4   I, J
C
	DO 1000 J=1,MON_MAX_PROC_PARAMS
C	    '80000000'X MEANS NOT INITIALIZED FOR 'MIN' FIELD
	    MON_PROC_TABLE(I,J).MON_MIN_VALUE = '80000000'X
C	    '7FFFFFFF'X MEANS NOT INITIALIZED FOR 'MAX' FIELD
	    MON_PROC_TABLE(I,J).MON_MAX_VALUE = '7FFFFFFF'X
C	    0 MEANS NOT INITIALIZED FOR ANY FIELD
	    MON_PROC_TABLE(I,J).MON_PAR_INIT = 0
1000	CONTINUE
C
	MON_PROC_TABLE(I,MON_JPI$_FREP0VA).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_FREP0VA).MON_MAX_VALUE=39999999
C
	MON_PROC_TABLE(I,MON_JPI$_FREP1VA).MON_MIN_VALUE = '80000001'X
	MON_PROC_TABLE(I,MON_JPI$_FREP1VA).MON_MAX_VALUE = '7FFFFFF6'X
C
	MON_PROC_TABLE(I,MON_JPI$_PRI).MON_MIN_VALUE = 4
	MON_PROC_TABLE(I,MON_JPI$_PRI).MON_MAX_VALUE =
     *		MON_PROC_TABLE(I,MON_JPI$_PRI).MON_MIN_VALUE + 6
C
	MON_PROC_TABLE(I,MON_JPI$_PRIB).MON_MIN_VALUE = 4
	MON_PROC_TABLE(I,MON_JPI$_PRIB).MON_MAX_VALUE = 15
C
	MON_PROC_TABLE(I,MON_JPI$_JOBPRCCNT).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_JOBPRCCNT).MON_MAX_VALUE=1
C
	MON_PROC_TABLE(I,MON_JPI$_CPUTIM).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_CPUTIM).MON_MAX_VALUE=10	! 100 MSECS/SEC
C
	MON_PROC_TABLE(I,MON_JPI$_PAGEFLTS).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_PAGEFLTS).MON_MAX_VALUE=50  ! 50PAGE/SEC
C
	MON_PROC_TABLE(I,MON_JPI$_GPGCNT).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_GPGCNT).MON_MAX_VALUE=60000
C
	MON_PROC_TABLE(I,MON_JPI$_BUFIO).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_BUFIO).MON_MAX_VALUE=100  ! /SEC
C
	MON_PROC_TABLE(I,MON_JPI$_DIRIO).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_DIRIO).MON_MAX_VALUE=10  ! /SEC
C
	MON_PROC_TABLE(I,MON_JPI$_PPGCNT).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_PPGCNT).MON_MAX_VALUE=60000
C
	MON_PROC_TABLE(I,MON_JPI$_WSSIZE).MON_MIN_VALUE=0
	MON_PROC_TABLE(I,MON_JPI$_WSSIZE).MON_MAX_VALUE=60000
C
	MON_PROC_TABLE(I,MON_JPI$_FILCNT).MON_MIN_VALUE=10
C
	RETURN
C
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C PROC_INIT_PAR(I)
C
C---------------------------------------------------------------------------
C	
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE PROC_INIT_PAR(I)
	IMPLICIT NONE
C
	INCLUDE	    'INCLIB:SYSPARAM.DEF'
	INCLUDE	    'INCLIB:SYSEXTRN.DEF'
	INCLUDE	    'INCLIB:MONGOLS.DEF'
C
	INTEGER*4   I, J
C
	DO 1000 J=1,MON_MAX_PROC_PARAMS
C	    0 MEANS NOT INITIALIZED FOR ANY FIELD
	    MON_PROC_TABLE(I,J).MON_PAR_INIT = 0
1000	CONTINUE
C
	RETURN
C
	END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C REPORT_DVI_STS(MASK)
C
C---------------------------------------------------------------------------
C	
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE REPORT_DVI_STS(LUN,MASK)
	IMPLICIT NONE
C
	INCLUDE	    'INCLIB:SYSPARAM.DEF'
	INCLUDE	    'INCLIB:SYSEXTRN.DEF'
	INCLUDE	    'INCLIB:MONGOLS.DEF'
C
	INTEGER*4   MASK,LUN
	INTEGER*4   I
C
	STRUCTURE /DVI_STS/
	    INTEGER*4	    STS_CODE
	    CHARACTER*30    STS_NAME
	    BYTE            ALIGN(2)
	END STRUCTURE
C
	INTEGER*4	NR_STATS
	PARAMETER	(NR_STATS=26)
C
	RECORD /DVI_STS/ DVI_STATS(NR_STATS)
C
C	CANNOT USE RECORD NAMES IN DATA STATEMENT...
C
	DVI_STATS(1).STS_CODE =       UCB$M_TIM
	DVI_STATS(1).STS_NAME =      'Time out is enabled'

	DVI_STATS(2).STS_CODE =       UCB$M_INT
	DVI_STATS(2).STS_NAME =      'Interrupt is expected'

	DVI_STATS(3).STS_CODE =       UCB$M_ERLOGIP
	DVI_STATS(3).STS_NAME =   'Error log is in progress'

	DVI_STATS(4).STS_CODE =       UCB$M_CANCEL
	DVI_STATS(4).STS_NAME =    'I/O on unit is cancelled'

	DVI_STATS(5).STS_CODE =       UCB$M_ONLINE
	DVI_STATS(5).STS_NAME =    'Unit is on line'

	DVI_STATS(6).STS_CODE =       UCB$M_POWER
	DVI_STATS(6).STS_NAME =     'Power failed while unit busy'

	DVI_STATS(7).STS_CODE =       UCB$M_TIMOUT
	DVI_STATS(7).STS_NAME =    'Unit timed out'

	DVI_STATS(8).STS_CODE =       UCB$M_INTTYPE
	DVI_STATS(8).STS_NAME =   'Receiver interrupt'

	DVI_STATS(9).STS_CODE =       UCB$M_BSY
	DVI_STATS(9).STS_NAME =      'Unit is busy'

	DVI_STATS(10).STS_CODE =       UCB$M_MOUNTING
	DVI_STATS(10).STS_NAME =  'Device is being mounted'

	DVI_STATS(11).STS_CODE =       UCB$M_DEADMO
	DVI_STATS(11).STS_NAME =    'Deallocate at dismount'

	DVI_STATS(12).STS_CODE =       UCB$M_VALID
	DVI_STATS(12).STS_NAME =     'Volume is software valid'

	DVI_STATS(13).STS_CODE =       UCB$M_UNLOAD
	DVI_STATS(13).STS_NAME =    'Unload volume at dismount'

	DVI_STATS(14).STS_CODE =       UCB$M_TEMPLATE
	DVI_STATS(14).STS_NAME =  'Source template UCB'

	DVI_STATS(15).STS_CODE =       UCB$M_MNTVERIP
	DVI_STATS(15).STS_NAME =  'Mount verify in progress'

	DVI_STATS(16).STS_CODE =       UCB$M_WRONGVOL
	DVI_STATS(16).STS_NAME =  'Wrong volume detected'

	DVI_STATS(17).STS_CODE =	     UCB$M_DELETEUCB
	DVI_STATS(17).STS_NAME = 'Delete UCB when ref count 0'

        DVI_STATS(18).STS_CODE =      UCB$M_LCL_VALID
        DVI_STATS(18).STS_NAME =      'UCB$M_LCL_VALID'

        DVI_STATS(19).STS_CODE =      UCB$M_SUPMVMSG
        DVI_STATS(19).STS_NAME =      'UCB$M_SUPMVMSG'

        DVI_STATS(20).STS_CODE =      UCB$M_MNTVERPND
        DVI_STATS(20).STS_NAME =      'UCB$M_MNTVERPND'

        DVI_STATS(21).STS_CODE =      UCB$M_DISMOUNT
        DVI_STATS(21).STS_NAME =      'UCB$M_DISMOUNT'

        DVI_STATS(22).STS_CODE =      UCB$M_CLUTRAN
        DVI_STATS(22).STS_NAME =      'UCB$M_CLUTRAN'

        DVI_STATS(23).STS_CODE =      UCB$M_WRTLOCKMV
        DVI_STATS(23).STS_NAME =      'UCB$M_WRTLOCKMV'

        DVI_STATS(24).STS_CODE =      UCB$M_SVPN_END
        DVI_STATS(24).STS_NAME =      'UCB$M_SVPN_END'

        DVI_STATS(25).STS_CODE =      UCB$M_ALTBSY
        DVI_STATS(25).STS_NAME =      'UCB$M_ALTBSY'

        DVI_STATS(26).STS_CODE =      UCB$M_SNAPSHOT
        DVI_STATS(26).STS_NAME =      'UCB$M_SNAPSHOT'

C
	DO 1000 I=1,NR_STATS
	    IF(IAND(MASK,DVI_STATS(I).STS_CODE).NE.0) THEN
		WRITE(LUN,10001)IAM(),
     *		  DVI_STATS(I).STS_CODE,
     *		  DVI_STATS(I).STS_NAME
	    ENDIF
1000	CONTINUE
C
	RETURN
C
10001	FORMAT(1X,A,'BIT ',Z8,':  ',A)
	END
