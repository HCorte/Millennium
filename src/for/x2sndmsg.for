C
C SUBROUTINE X2SNDMSG
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]X2SNDMSG.FOV                                 $
C  $Date::   17 Apr 1996 16:34:50                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - x2sndbuf.for;2 **
C
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C     GET MESSAGE FROM THE BUFFER
C
C X2SNDMSG(BUFFER,MESSAGE,MESSAGE_LEN,TERMINAL_NO,STATION_NO,
C          CURRENT_POINTER,BUF_SSAP,BUF_DSAP,MES_NUM,DEST_LAYER,
C          CONNCTL_OVR,DELIVER_OVR,STATUS)
C
C  IN:
C     BUFFER         -     BUFFER WITH DATA, POINTED TO DATA AREA
C     BUF_DSAP       -     DESTINATION_SAP
C     BUF_SSAP       -     SOURCE SAP
C     MESSAGE        -     MESSAGE DATA, FOR TRANSPORT LAYER
C                          MESSAGES MESSAGE TYPE PROVIDED ONLY
C                          FOR FRONT END MESSAGE MESSAGE HAS TO
C                          BE BUILT BY CALLER
C                          FOR STATION MESSAGES, STATION PART OF
C                          THE MESSAGE BUILT BY CALLER
C     MESSAGE_LEN    -     LENGTH OF MESSAGE, FOR HIGHEST LAYER
C     TERMINAL_NUMBER-     TERMINAL ORIGINATED, -1 IF NO TERM MESS
C     STATION_NO     -     STATION NUMBER IT CAME FROM
C     CURRENT_POINTER-     UPDATED FOR NEXT MESSAGE IN THE BUFFER
C                          IN BYTES, SET TO -1 IF NO MORE MESSAGES
C                          IN THE BUFFER
C     DEST_LAYER     -     DESTINATION LAYER MASK
C     MES_NUM        -     MESSAGE NUMBER
C     CONNCTL_OVR    -     CONNECTION CONTROL OVERRIDE
C     DELIVER_OVR    -     DELIVERY CONTROL OVERRIDE
C
C  OUT:
C     STATUS         -     .NON.0 IF NO MESSAGE
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE X2SNDMSG(BUFFER,MESSAGE,MESSAGE_LEN
     *	          ,TERMINAL_NO,STATION_NO,CURRENT_POINTER,
     *	           BUF_SSAP,BUF_DSAP,MES_NUM,DEST_LAYER,CONNCTL_OVR,
     *	           DELIVER_OVR,HOST_ID,STATUS)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:X2PTLMES.DEF'
	INCLUDE 'INCLIB:X2STMES.DEF'
	INCLUDE 'INCLIB:X2TDBH.DEF'
	INCLUDE 'INCLIB:X2FEMES.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
C
	INTEGER*2 MESSAGE(*)      !MESSAGE
CCC	INTEGER*2 BUFFER(*)
	BYTE      BUFFER(0:*)     !ELIMINATE ILBYTE AND ISBYTE
	INTEGER*4 TERMINAL_NO,CURRENT_POINTER,STATUS
	INTEGER*4 MESSAGE_LEN
	INTEGER*4 BUF_SSAP,BUF_DSAP,DEST_LAYER,CONNCTL_OVR
	INTEGER*4 OFFSET, TO_ADD, LEN, DATA_LEN, BLOCK_TYPE
	INTEGER*4 DATA_OFFSET, FE_ID, MSGCNT, FLAGS
	INTEGER*4 HOST_ID, DELIVER_OVR, MES_NUM, STATION_NO
 
C
C     IS TRANSPORT COMMAND SEND CURRENT BUFFER FIRST
C
	IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	    TYPE *,'X2SNDMSG ',TERMINAL_NO,STATION_NO,CURRENT_POINTER,
     *	   BUF_SSAP,BUF_DSAP,MES_NUM,DEST_LAYER,CONNCTL_OVR,DELIVER_OVR
     *	   ,MESSAGE_LEN
	IF(DEST_LAYER.EQ.X2DEST_TRANSPORT.AND.CURRENT_POINTER.GT.0)THEN
	   STATUS=X2ERR_NOMORE
	   IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	      TYPE *,'RET X2SNDMSG ',X2X_PTLMES(STATUS),CURRENT_POINTER
	   RETURN
	ENDIF
C
	IF (CURRENT_POINTER.LE.0) THEN       !INITIALIZATION
	   CALL NI4TOBUF4(X2TDBH_TDBH,BUFFER,X2TDBH_BLKCHK-1) !'TDBH'
C
	   CALL I4TOBUF2(X2XE_SEQ_XMIT(BUF_DSAP),BUFFER,X2TDBH_BLKSEQ-1)
	   X2XE_SEQ_XMIT(BUF_DSAP)=MOD(X2XE_SEQ_XMIT(BUF_DSAP)+1,256)
C
	   BUFFER(X2TDBH_DSAP-1) = BUF_DSAP                 !DEST SAP
	   BUFFER(X2TDBH_SSAP-1) = X2X_GAME_SAP             !SOURCE SAP
C
	   CALL X2SETFLG(BUF_DSAP,FLAGS)                    !SET FLAGS
	   BUFFER(X2TDBH_FLAGS-1) = FLAGS                   !FLAGS
	   BUFFER(X2TDBH_BLKTYP-1) = X2TDBHT_DATA           !TYPE
	   MSGCNT=0
	   FE_ID=X2XE_FE_ID(BUF_DSAP)
	   BUFFER(X2TDBH_FE_ID-1) = FE_ID                   !FRONT END ID
	   BUFFER(X2TDBH_CNFSUM-1) = 0                      !IGNORE
	   CALL I4TOBUF4(0,BUFFER,X2TDBH_FEAV-1)
	   DATA_OFFSET=X2TDBH_DATA_LOCATION
	   BUFFER(X2TDBH_DATAOFF-1) = DATA_OFFSET
	   CURRENT_POINTER=DATA_OFFSET
C
	   IF (DEST_LAYER.EQ.X2DEST_TRANSPORT) THEN !SEND FOR TRANSPORT
	      CALL ILBYTE(BLOCK_TYPE,MESSAGE,0)
	      BUFFER(X2TDBH_BLKTYP-1) = BLOCK_TYPE          !TYPE
	      BUFFER(X2TDBH_MSGCNT-1) = 0
	      DATA_LEN=MESSAGE_LEN-1
	      IF (DATA_LEN.LT.0) DATA_LEN=0
C
C        IF ANY MESSAGE PUT IT AT THE END
C
	      IF (DATA_LEN.GT.0) THEN
	         CALL MOVBYT(MESSAGE,2,BUFFER,X2TDBH_DATA_LOCATION,
     *	                     DATA_LEN)
	         DATA_OFFSET=DATA_OFFSET+DATA_LEN
	      ELSE
	         BUFFER(X2TDBH_DATAOFF-1) = 0
	      ENDIF
	      CURRENT_POINTER=CURRENT_POINTER+DATA_LEN
	      CALL I4TOBUF2(DATA_OFFSET-1,BUFFER,X2TDBH_BLKSIZ-1)
	      STATUS=X2ERR_SEND_NOW
	      IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	       TYPE*,'RET X2SNDMSG ',X2X_PTLMES(STATUS),CURRENT_POINTER
	      RETURN
	   ENDIF
	ELSE
	   MSGCNT = BUFFER(X2TDBH_MSGCNT-1)
	ENDIF
C
	IF (IAND(DEST_LAYER,X2DEST_APP).NE.0) THEN !FOR TERMINAL MSG
	   LEN=MESSAGE_LEN
	   IF (MES_NUM.NE.0) LEN=X2X_MAXLEN_MSGCOM
	   TO_ADD=LEN+X2FEMES_ADR+X2X_ADRESS_MAXLEN*2+X2STMES_DATA
	ELSEIF (IAND(DEST_LAYER,X2DEST_STATION).NE.0) THEN !TO STATION
	   LEN=MESSAGE_LEN
	   IF (MES_NUM.NE.0) LEN=X2X_MAXLEN_MSGCOM+
     *	                             X2STMES_RELAY_HEADER_LEN
	   TO_ADD=LEN+X2FEMES_ADR+X2X_ADRESS_MAXLEN*2
	ELSEIF (IAND(DEST_LAYER,X2DEST_FE).NE.0) THEN !FE MESSAGE
	   LEN=MESSAGE_LEN
	   IF (MES_NUM.NE.0) LEN=X2X_MAXLEN_MSGCOM
	   TO_ADD=LEN
	ELSE
	   STATUS=X2ERR_FATAL+X2ERR_INV
	   IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	      TYPE *,'RET X2SNDMSG ',X2X_PTLMES(STATUS),CURRENT_POINTER
	   RETURN
	ENDIF
	IF (X2X_MAXMES_LEN.LT.CURRENT_POINTER+TO_ADD) THEN
	   STATUS=X2ERR_NOMORE              !NO MORE DATA
	IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	      TYPE *,'RET X2SNDMSG ',X2X_PTLMES(STATUS),CURRENT_POINTER
     *	            ,TO_ADD,DEST_LAYER,MESSAGE_LEN
	   RETURN
	ENDIF
C
C     PROCESS MESSAGE NOW
C
	OFFSET=(((CURRENT_POINTER+1)/2)*2)-2               !BYTE INDEX
	CALL X2SNDFE(BUFFER(OFFSET),MESSAGE,MESSAGE_LEN,STATION_NO,
     *	             TERMINAL_NO,CURRENT_POINTER,HOST_ID,MES_NUM,
     *	             DEST_LAYER,CONNCTL_OVR,DELIVER_OVR,STATUS)
C
	IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0.AND.STATUS.NE.0)
     *	     TYPE *,'RET X2SNDMSG ',X2X_PTLMES(STATUS)
	IF (STATUS.NE.0) RETURN
C
C     STORE MESSAGE COUNT AND TRANSPORT LENGTH IN THE HEADER
C
	CALL I4TOBUF2(CURRENT_POINTER-1,BUFFER,X2TDBH_BLKSIZ-1)
	MSGCNT=MSGCNT+1
	BUFFER(X2TDBH_MSGCNT-1) = MSGCNT
	IF (X2X_MAXMES_CNT.LE.MSGCNT) THEN
	   STATUS=X2ERR_SEND_NOW            !NO MORE DATA
	   IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	      TYPE *,'RET X2SNDMSG ',X2X_PTLMES(STATUS),CURRENT_POINTER
	   RETURN
	ENDIF
	IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	    TYPE *,'RET X2SNDMSG ',X2X_PTLMES(STATUS),CURRENT_POINTER
	RETURN
	END
