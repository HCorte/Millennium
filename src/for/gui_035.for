C GUI_035.FOR
C
C V07 24-JAN-2011 FJG Out of Bounds issue
C V06 22-SEP-2010 FRP Winning serie for Popular added.
C V05 09-APR-2010 RXK Sales begin date and purge date added.
C V04 05-SEP-2005 FRP Modify for Natal 2005: Correct totals.
C V03 19-MAY-2001 ANG USE SCML DRAW NUMBER INSTEAD FIGWEK
C V02 21-MAR-2001 UXN CLEANUP. 
C V01 27-FEB-2001 HJK INITIAL RELEASE FOR PORTUGAL
C
C PASSIVE GAMES DATA
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 2001 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C This subroutine returns GUI FUNCTION.
C
C Input parameters:
C	NONE               
C
C Output parameters:
C
C	BYTE		OUTBUF(*)    OUTPUT MESSAGE
C	INTEGER*4	MES_LEN	     MESSAGE LENGTH
C	INTEGER*4	RET_CODE:
C		0		-  no error, message accepted;
C		value >= 11	-  error number to be sent to Client.
C
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GUI_035(OUTBUF,MES_LEN,RET_CODE)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:GUIMPRM.DEF'
	INCLUDE 'INCLIB:GUISTR.DEF'
	INCLUDE 'INCLIB:PASCOM.DEF'
	INCLUDE 'INCLIB:DPAREC.DEF'
        INCLUDE 'INCLIB:DPPREC.DEF'
	INCLUDE 'INCLIB:PASNAM.DEF'
	INCLUDE 'INCLIB:GUIARGS.DEF'
	INCLUDE 'INCLIB:GUIFIL.DEF'
C
C
	BYTE		OUTBUF(*)
	INTEGER*4	MES_LEN,RET_CODE
C
	INTEGER*4 NUM_COLS, NUM_ROWS
	INTEGER*4 GIND
C	INTEGER*4 CDC   !V03

C
        INTEGER*4  FRAMT
	EXTERNAL   FRAMT
C
        INTEGER*4  GNUM
        INTEGER*4  ST, STS
	INTEGER*4  DRAW,K,YEAR,WEEK

        INTEGER*4    DIVS  !,POS
        INTEGER*4    CNTPRIZES,CNTPAID
        INTEGER*4    EMIOFF,INDEMI
        INTEGER*4    PRZAMT
        INTEGER*8    AMTPRIZES,AMTPAID

	LOGICAL      ON_MEMORY, FPOP, FEXT
	INTEGER*4    EXTRA,TOTSHR,TOTPAD
	INTEGER*4    WIN
	LOGICAL*4    DATA_TO_SEND
	INTEGER*4    DIG
	INTEGER*4    FDB(7)
        INTEGER*4    CDC
	
	!function
	INTEGER*4    GETDRW
	INTEGER*4    PAS_ROUND_VALUE
	
	CHARACTER*20 CDPPNAM
	EQUIVALENCE(SFNAMES(1,PPF),CDPPNAM)

C
C  GET PARAMS
C
	CALL GUI_GETPARAMS(OUTBUF, ST)
	IF(ST.NE.0) THEN
	   RET_CODE = 11
	   RETURN
	ENDIF

	GIND = GUI_ARGVAL(1)
	WEEK = GUI_ARGVAL(2)
	YEAR = GUI_ARGVAL(3)

C
C CHECK GAME INDEX
C
	IF(GIND.LT.1.OR.GIND.GT.NUMPAS) THEN
	  RET_CODE = 11
	  RETURN
	ENDIF
C
C CHECK GAME NUMBER
C
        GNUM = GTNTAB(TPAS,GIND)
        IF (GNUM.LT.1) THEN
            RET_CODE = 11
            RETURN
        ENDIF
C 
C CHECK WEEK AND YEAR
C
	IF(WEEK.EQ.0 .AND. YEAR.EQ.0) THEN
	  IF(PASCURDRW(GIND).GT.0.AND.PASCURDRW(GIND).LE.PAGEMI) THEN
	    DRAW = PASEMIS(PASCURDRW(GIND),GIND)
            CALL GETPASDRW(PASDRAW(PASCURDRW(GIND),GIND),WEEK,YEAR) 
C	   CDC  = DAYCDC                !V03
C	   CALL FIGWEK(CDC,WEEK,YEAR)   !V03
          ELSE
	    RET_CODE = 11
	    RETURN
          ENDIF
	ELSEIF(WEEK.LT.1 .OR. WEEK.GT.53 .OR.
     *     YEAR.LT.2001 .OR. YEAR.GT.2099) THEN
	   RET_CODE = 11
	   RETURN
	ELSE
           !get draw corresponding to week/year
           DRAW = GETDRW(YEAR,WEEK,GNUM)
           IF(DRAW.LE.0) THEN
	      RET_CODE = 11
              RETURN
           ENDIF
	ENDIF
C
C VERFIFY EMISSION NUMBER
C
	IF(DRAW.LE.PAS_DRW_OFFSET) DRAW = 1
C
C GET DATA FROM COMMON OR DISK
C
	ON_MEMORY = .FALSE.
	DO INDEMI = 1,PAGEMI
	   IF(DRAW.EQ.PASEMIS(INDEMI,GIND)) THEN
	      ON_MEMORY = .TRUE.
	      EMIOFF    = INDEMI
	   ENDIF
	ENDDO


	IF(ON_MEMORY) THEN
	   CALL GAMLOGPAS(EMIOFF,GIND,DPAREC,PASSTS)
	ELSE
	   CALL READW(GAMFDB(1,GNUM),(DRAW - PAS_DRW_OFFSET),DPAREC,ST)
	   IF(ST.NE.0) THEN
	      CALL OPS('Failed to read '//CGFNAMES(GNUM),ST,DRAW)
	      RET_CODE = 11
	      RETURN
	   ENDIF
	ENDIF
C
C READ PLAN
C	
	CALL OPENW(3,SFNAMES(1,PPF),4,0,0,ST)
	CALL IOINIT(FDB,3,DPPSEC*256)	
	IF(ST.NE.0) THEN    		 
          CALL OPS('Failed to open '//CDPPNAM,ST,DPAPLAN)
          RET_CODE = 11
	  RETURN	
	ENDIF  
	CALL READW(FDB,DPAPLAN,DPPREC,ST)
	IF(ST.NE.0) THEN
          CALL OPS('Failed to read '//CDPPNAM,ST,DPAPLAN)
          RET_CODE = 11
	  RETURN	
	ENDIF  	
	CALL CLOSEFIL(FDB)
C
C
C
	!IF (WEEK.EQ.0 .AND. YEAR.EQ.0) CALL GETPASDRW(DPADRAW,WEEK,YEAR)

	FPOP = (GIND   .EQ. PSBPOP)
	FEXT = (DPAEMT .EQ. EM_EXT)

	IF(FPOP.OR.FEXT) THEN
	   EXTRA = 1
	ELSE
	   EXTRA = 0
	ENDIF
C
        CALL GUI_CHKSTS_RESCOM(GIND,TPAS,DRAW,STS)
        STS = MAX(STS,DPASTS)
C
C BUILD GUI MESSAGE
C
	CALL GUIARG_INIT()
C
C RESULT SET 1
C
	NUM_COLS = 16
	NUM_ROWS = 1
	CALL GUIARG_NEXT_SET(OUTBUF,NUM_COLS)
C
	CALL GUIARG_INT4(OUTBUF,WEEK)
	CALL GUIARG_INT4(OUTBUF,YEAR)
	CALL GUIARG_CHAR(OUTBUF,GLNAMES(1,GNUM),16)

	CALL GUIARG_DATE(OUTBUF,DPAESD)

	CALL GUIARG_MONY(OUTBUF,DPAPRC)
	CALL GUIARG_CHAR(OUTBUF,%REF(NAMPLANTYP(DPAEMT)),14)

	CALL GUIARG_INT4(OUTBUF,DPAPLAN)
	CALL GUIARG_INT4(OUTBUF,DPANUMSER)
	CALL GUIARG_INT2(OUTBUF,DPANOFFRA)
	CALL GUIARG_INT4(OUTBUF,DPANUMTCK)

	CALL GUIARG_BYTE(OUTBUF,STS)
	CALL GUIARG_BYTE(OUTBUF,EXTRA)
	CALL GUIARG_INT4(OUTBUF,DPARETCNT)
	
	CALL GUIARG_DATE(OUTBUF,DPABSD)
	CALL GUIARG_DATE(OUTBUF,DPAPRGCDC)
        CDC = DPAESD + DPAMAXDAYPAY
        CALL GUIARG_DATE(OUTBUF,CDC) 
C
C RESULT SET 2
C
	NUM_COLS = 10
	CALL GUIARG_NEXT_SET(OUTBUF,NUM_COLS)
			
	DATA_TO_SEND = .FALSE.
	DO DIVS = 1,DPADIV
	   DATA_TO_SEND = .TRUE.
	   PRZAMT = PAS_ROUND_VALUE(DPASHV(DIVS))
	   TOTSHR = DPASHR(DIVS)
	   IF(PRZAMT.LT.0) PRZAMT = 0
	   IF(TOTSHR.LT.0) TOTSHR = 0
	   TOTPAD = PRZAMT/DPANOFFRA
C
	   CALL GUIARG_INT2(OUTBUF,DIVS)
	   CALL GUIARG_MONY(OUTBUF,PRZAMT)
	   CALL GUIARG_INT4(OUTBUF,TOTSHR*DPANUMSER)

	   CALL GUIARG_MONY(OUTBUF,PRZAMT*TOTSHR*DPANUMSER)
	   CALL GUIARG_INT4(OUTBUF,DPAPAD(DIVS))
	   CALL GUIARG_MONY(OUTBUF,DPAPAD(DIVS)*TOTPAD)
	   	   
           DIG = 1
           DO WHILE(FATOR(DIG).NE.DPPDIG(DIVS).AND.DIG.LE.5)
             DIG = DIG + 1
           ENDDO
           IF (DIG.GT.5) DIG = 0	              
	   CALL GUIARG_INT4(OUTBUF,DPPTYP(DIVS))
           CALL GUIARG_INT4(OUTBUF,DIG)	   	   
	   CALL GUIARG_INT4(OUTBUF,DPPIDNUM(DIVS))
           CALL GUIARG_INT2(OUTBUF,DPPWNUM(DIVS))
	ENDDO	
	
	IF(.NOT.DATA_TO_SEND) THEN
	   CALL GUIARG_NO_DATA(OUTBUF,NUM_COLS)
	ENDIF
C
C RESULT SET 3
C
	NUM_COLS = 4
	NUM_ROWS = 1
	CALL GUIARG_NEXT_SET(OUTBUF,NUM_COLS)

	CNTPRIZES = 0
	AMTPRIZES = 0
	CNTPAID   = 0
	AMTPAID   = 0

        DO DIVS = 1,DPADIV
            PRZAMT = PAS_ROUND_VALUE(DPASHV(DIVS))
            TOTSHR = DPASHR(DIVS)
            IF (PRZAMT.NE.0) THEN
	       TOTPAD = PRZAMT/DPANOFFRA
               CNTPRIZES = CNTPRIZES + TOTSHR  * DPANUMSER
               AMTPRIZES = AMTPRIZES + (PRZAMT * TOTSHR * DPANUMSER)
               CNTPAID   = CNTPAID   + DPAPAD(DIVS)
               AMTPAID   = AMTPAID   + (DPAPAD(DIVS) * TOTPAD)
            ENDIF
        ENDDO

	CALL GUIARG_INT4(OUTBUF,CNTPRIZES)
	CALL GUIARG_MONYI8(OUTBUF,AMTPRIZES)
	CALL GUIARG_INT4(OUTBUF,CNTPAID)
	CALL GUIARG_MONYI8(OUTBUF,AMTPAID)
C
C Result set 4
C

	NUM_COLS = 10
	CALL GUIARG_NEXT_SET(OUTBUF,NUM_COLS)

	
	DATA_TO_SEND = (EXTRA.EQ.1 .AND. (FPOP .OR. FEXT)) 
	IF(.NOT.DATA_TO_SEND) THEN
	   CALL GUIARG_NO_DATA(OUTBUF,NUM_COLS)
	   GOTO 50
	ENDIF
C
	DATA_TO_SEND = .FALSE.
	DO DIVS = 1,PAGEDV
	   DATA_TO_SEND = .TRUE.
	   PRZAMT = PAS_ROUND_VALUE(DPAEXSHV(DIVS))
	   TOTSHR = DPAEXSHR(DIVS)
	   IF(PRZAMT.LT.0) PRZAMT = 0
	   IF(TOTSHR.LT.0) TOTSHR = 0
	   TOTPAD = PRZAMT/DPANOFFRA

	   CALL GUIARG_INT2(OUTBUF,DIVS)
	   CALL GUIARG_MONY(OUTBUF,PRZAMT)
	   CALL GUIARG_INT4(OUTBUF,TOTSHR*DPANUMSER)
	   CALL GUIARG_MONY(OUTBUF,PRZAMT*TOTSHR*DPANUMSER)
	   IF(PRZAMT.NE.0) THEN
	     CALL GUIARG_INT4(OUTBUF,DPAPAD(DIVS))
	     CALL GUIARG_MONY(OUTBUF,DPAPAD(DIVS)*TOTPAD)
	   ELSE
	     CALL GUIARG_INT4(OUTBUF,DPAEXPAD(DIVS))
	     CALL GUIARG_MONY(OUTBUF,DPAEXPAD(DIVS)*TOTPAD)
	   ENDIF
           DIG = 1
           DO WHILE(FATOR(DIG).NE.DPPDIG(DIVS).AND.DIG.LE.5)
             DIG = DIG + 1
           ENDDO
           IF (DIG.GT.5) DIG = 0	              
	   CALL GUIARG_INT4(OUTBUF,DPPTYP(DIVS))
           CALL GUIARG_INT4(OUTBUF,DIG)	   	   
	   CALL GUIARG_INT4(OUTBUF,DPPIDNUM(DIVS))
           CALL GUIARG_INT2(OUTBUF,DPPWNUM(DIVS))
	ENDDO	
	IF(.NOT.DATA_TO_SEND) THEN
	   CALL GUIARG_NO_DATA(OUTBUF,NUM_COLS)
	ENDIF
C
C RESULT SET 5
C
50	CONTINUE
C
   	NUM_COLS = 4
	NUM_ROWS = 1
	CALL GUIARG_NEXT_SET(OUTBUF,NUM_COLS)

	DATA_TO_SEND = (EXTRA.EQ.1 .AND. (FPOP .OR. FEXT)) 
	IF(.NOT.DATA_TO_SEND) THEN
	   CALL GUIARG_NO_DATA(OUTBUF,NUM_COLS)
	   GOTO 60
	ENDIF
C
	CNTPRIZES = 0
	AMTPRIZES = 0
	CNTPAID   = 0
	AMTPAID   = 0

        DO DIVS = 1,PAGEDV
           PRZAMT = PAS_ROUND_VALUE(DPAEXSHV(DIVS))
           TOTSHR = DPAEXSHR(DIVS)
	   TOTPAD = PRZAMT/DPANOFFRA
           CNTPRIZES = CNTPRIZES + TOTSHR  * DPANUMSER
           AMTPRIZES = AMTPRIZES + (PRZAMT * TOTSHR * DPANUMSER)
	   IF(PRZAMT.NE.0) THEN
             CNTPAID   = CNTPAID   + DPAPAD(DIVS)
             AMTPAID   = AMTPAID   + (DPAPAD(DIVS)*TOTPAD)
	   ELSE
             CNTPAID   = CNTPAID   + DPAEXPAD(DIVS)
             AMTPAID   = AMTPAID   + (DPAEXPAD(DIVS)*TOTPAD)
	   ENDIF
        ENDDO

	CALL GUIARG_INT4(OUTBUF,CNTPRIZES)
	CALL GUIARG_MONYI8(OUTBUF,AMTPRIZES)
	CALL GUIARG_INT4(OUTBUF,CNTPAID)
	CALL GUIARG_MONYI8(OUTBUF,AMTPAID)
C
C RESULT SET 6
C
60	CONTINUE
C
	NUM_COLS = PAGNBR+1
	CALL GUIARG_NEXT_SET(OUTBUF,NUM_COLS)

	DATA_TO_SEND = .FALSE.
        DO 100 DIVS=1,DPADIV
           IF(DPAWNUM(DIVS).LE.0) GOTO 100
	   DATA_TO_SEND = .TRUE.
	   CALL GUIARG_INT4(OUTBUF,DIVS)
	   DO K=1,PAGNBR
              IF(K.LE.DPAWNUM(DIVS)) THEN
		 WIN = -2 ! unset win#
                 IF(DPASTS.GE.GAMENV) THEN
  		    WIN = DPAWIN(K,DIVS)
		 ENDIF
              ELSE 
                 WIN = -1 ! irrelevant 
              ENDIF
	      CALL GUIARG_INT4(OUTBUF,WIN)
           ENDDO
100	CONTINUE
C
C Send one extra row with winning serie (identified as divs=-3)
	IF(FPOP .AND. DATA_TO_SEND .AND. DPASTS.GE.GAMENV) THEN
          DIVS=-3
	  CALL GUIARG_INT4(OUTBUF,DIVS)
          WIN=DPAWSER
	  CALL GUIARG_INT4(OUTBUF,WIN)
          DO K=2,PAGNBR
            WIN = -1 ! irrelevant
            CALL GUIARG_INT4(OUTBUF,WIN)
          ENDDO
        ENDIF
	IF(.NOT.DATA_TO_SEND) THEN
	   CALL GUIARG_NO_DATA(OUTBUF,NUM_COLS)
	ENDIF
C
	CALL GUIARG_SET_MESLEN(MES_LEN)
	RETURN
C
	END
