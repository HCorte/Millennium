C
C SUBROUTINE CHKLIA
C $Log:   GXAFXT:[GOLS]CHKLIA.FOV  $
C  
C     Rev 1.0   17 Apr 1996 12:32:26   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.11   02 Sep 1994 18:01:20   HXK
C  Merge of May,June RFSS batch 
C  
C     Rev 1.11   27 Apr 1994  9:20:18   JXP
C  Included odds exceeded and combination closed messages to terminal
C  
C     Rev 1.10   09 Mar 1994 18:09:00   HXK
C  FIXED BUG IN TSMXLI, TSMXOD HANDLING.
C  
C     Rev 1.9   06 Mar 1994 10:25:18   HXK
C  REARRANGED FOR SYSTEM BETS, MINOR CORRECTIONS.
C  
C     Rev 1.8   04 Mar 1994 22:44:16   JXP
C  Intoruction of TSMXLI parameter
C  
C     Rev 1.7   03 Mar 1994 11:24:48   HXK
C  FIXED BUG SETTING TAB_1X2.
C  
C     Rev 1.6   28 Feb 1994 16:28:28   JXP
C  No changes
C  
C     Rev 1.5   28 Feb 1994 15:56:00   JXP
C  Return immediately if rejected wager
C  
C     Rev 1.4   28 Feb 1994 12:14:10   JXP
C  Syntax correction
C  
C     Rev 1.3   28 Feb 1994 11:34:56   JXP
C  Set tsat to reject wager if combination is suppressed
C  
C     Rev 1.2   25 Feb 1994 18:50:12   HXK
C  No change.
C  
C     Rev 1.1   25 Feb 1994 18:32:48   HXK
C  PITKA LIABILITY LIMITATIONS CHANGE.
C  
C     Rev 1.3   23 Feb 1994 16:34:22   JXP
C  
C     Rev 1.2   22 Feb 1994 14:45:04   JXP
C  Changed last check
C  
C     Rev 1.1   18 Feb 1994 10:57:02   JXP
C  Include initial checking on Pitka liability restriction
C  
C     Rev 1.0   21 Jan 1993 15:49:48   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - dtsel.for **
C
C
C
C
C SUBROUTINE TO CHECK LIABILITY LIMITS ON TOTO SELECT ROWS.
C SIMPLE WAGERS AND SYSTEM BETS.
C
C
C=======OPTIONS /CHECK=NOOVERFLOW/EXT
	SUBROUTINE CHKLIA(TRABUF,NBET)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:TSLCOM.DEF'
	INCLUDE 'INCLIB:CHKSUMCM.DEF'
	INCLUDE 'INCLIB:HASHMEM.DEF'
C
C
	REAL*8 ODDLIAB               !TOTAL ODDS FOR BET
C
	INTEGER*4 BETTAB(6,40,11)     !TABLE TO HOLD ALL ROW COMBINATIOS
C                                    !SIMP. SELECTED(1-#) #=3-6 ,
C                                    !COMBINATIONS , SYSTEM NUMBER
	INTEGER*4 TOTCMB(11)          !TOTAL # COMBINATIONS FOR EACH SYS
	INTEGER*4 SYSTAB(4,4)        !SYS # DEPENDING ON
C                                    !ACTUAL SELECTIONS MADE ,
C                                    !SELECTIONS BROKEN DOWN TO.
C
	INTEGER*4 AMTLIAB            !TOTAL POSSIBLE WIN AMOUNT FOR BET
	INTEGER*4 BETLEN, NBET, AMTOFF, SELOFF, ROWOFF, POLOFF
	INTEGER*4 SELECT, SYSNUM, SIMNUM, SELNUM, CMB, SEL, R, ROW(6)
	INTEGER*4 POL(6), GIND, TSLOFF, X, Y, PSTAT, TAB_1X2(6)
	INTEGER*4 NEXT_REC, NEXT_BLOCK
C
	LOGICAL FIRST/.TRUE./
C
	DATA SYSTAB/6,1,2,3,
     *	            6,7,4,5,
     *	            6,6,8,6,
     *	            6,6,6,9/
C
C CHECK IF TOTO SELECT LIABILITY CHECKING IS ACTIVE
C

C	IF(P(SUPTSP).NE.0) RETURN
C
C
	IF(FIRST) THEN
	   FIRST  = .FALSE.
	   BETLEN = TWTSEL2-TWTSEL1
	   CALL TSLSYS(BETTAB(1,1,1),4,3,TOTCMB(1))
	   CALL TSLSYS(BETTAB(1,1,2),5,3,TOTCMB(2))
	   CALL TSLSYS(BETTAB(1,1,3),6,3,TOTCMB(3))
	   CALL TSLSYS(BETTAB(1,1,4),5,4,TOTCMB(4))
	   CALL TSLSYS(BETTAB(1,1,5),6,4,TOTCMB(5))
	   CALL TSLSYS(BETTAB(1,1,6),1,1,TOTCMB(6))
	   CALL TSLSYS(BETTAB(1,1,7),2,2,TOTCMB(7))
	   CALL TSLSYS(BETTAB(1,1,8),3,3,TOTCMB(8))
	   CALL TSLSYS(BETTAB(1,1,9),4,4,TOTCMB(9))
	   CALL TSLSYS(BETTAB(1,1,10),5,5,TOTCMB(10))
	   CALL TSLSYS(BETTAB(1,1,11),6,6,TOTCMB(11))
	ENDIF
C
C
	GIND   = TRABUF(TGAMIND)
	AMTOFF = TWTAMT1 + (NBET*BETLEN)
	SELOFF = TWTSEL1 + (NBET*BETLEN)
	ROWOFF = TWTROW1 + (NBET*BETLEN)
	POLOFF = TWTPOL1 + (NBET*BETLEN)
C
C GET SYSTEM # AND # SELECTIONS IN BET
C
	SELECT = TRABUF(SELOFF)
	SYSNUM = 5 + SELECT                   !FOR NON SYSTEM WAGERS
	IF(TRABUF(TWSYST).EQ.FULSYS) THEN
	   SELECT = TRABUF(TWSYSN)
	   SIMNUM = SELECT-3+1
	   SELNUM = TRABUF(SELOFF)-3+1
	   SYSNUM = SYSTAB(SELNUM,SIMNUM)
	ENDIF
C
C LOOP FOR ALL POSSIBLE COMBINATIONS
C LOOP FOR ALL SELECTIONS
C
	IF(P(SUPTSP).EQ.0) THEN
	DO 100 CMB = 1,TOTCMB(SYSNUM)
	   ODDLIAB = 1.0D0
	   AMTLIAB = 0
	   DO 50 SEL = 1,SELECT
	      R   = BETTAB(SEL,CMB,SYSNUM)-1
	      ROW(SEL) = TRABUF(ROWOFF+R*TWTBLEN)
	      POL(SEL) = TRABUF(POLOFF+R*TWTBLEN)
	      ODDLIAB = ODDLIAB * TSLODS(POL(SEL),ROW(SEL),GIND)
50	   CONTINUE
C
	   IF(SELECT.GT.2) ODDLIAB = DNINT(ODDLIAB/DFLOAT(100**(SELECT-2)))
	   IF(SELECT.GT.1) ODDLIAB = DNINT(ODDLIAB/100.0D0)
	   ODDLIAB = ODDLIAB/100.0D0
	   AMTLIAB = IDNINT(ODDLIAB*DFLOAT(TRABUF(AMTOFF))+.00000001)
C
	   IF(AMTLIAB.GT.P(TSLIAB)) THEN
	      TRABUF(TERR) = LIAB
              TRABUF(TSTAT)= REJT
 	      RETURN
	   ENDIF
           IF(ODDLIAB.GT.P(TSMXODD)) THEN
              TRABUF(TERR)=ODDSEX
              TRABUF(TSTAT)=REJT
              RETURN
           ENDIF

C
C Check for any restrictions
C
	   DO SEL = 1,SELECT
		IF(POL(SEL).EQ.3) THEN
                   TAB_1X2(SEL)=4
                ELSE
                   TAB_1X2(SEL)=POL(SEL)
                ENDIF
	   END DO
	   CALL ODDSOFF(ROW,TAB_1X2,SELECT,TSLOFF)
           IF(SELECT.LE.3) THEN
              IF(HASH_DIR_SUP(1,TSLOFF).EQ.HASH_CLOSE) THEN
                TRABUF(TERR)=CMBCLOS
                TRABUF(TSTAT)=REJT
                RETURN
              ENDIF
	      IF(HASH_DIR_SUP(1,TSLOFF).GT.P(TSMXLI)) THEN
		TRABUF(TERR)=LIAB
		TRABUF(TSTAT)=REJT
                RETURN
	      ENDIF
	   ELSE
	      CALL HASHGET(TSLOFF,SELECT,X,NEXT_REC,NEXT_BLOCK,PSTAT)
	      IF(PSTAT.EQ.HASH_RETURN_OK) THEN
                 IF(HASH_TAB_SUP(1,NEXT_REC,NEXT_BLOCK).EQ.HASH_CLOSE) THEN
                    TRABUF(TERR)=CMBCLOS
                    TRABUF(TSTAT)=REJT
                    RETURN
                 ENDIF
		 IF(HASH_TAB_SUP(1,NEXT_REC,NEXT_BLOCK).GT.P(TSMXLI)) THEN
     		    TRABUF(TERR)=LIAB
	    	    TRABUF(TSTAT)=REJT
                    RETURN
		 ENDIF
	      ENDIF
	   ENDIF
C
C Check for (1) Mark / row restrictions  (2)  Row and Row restrictions 
C
	   X=1
	   DO WHILE (X.LT.SELECT+1)
	      IF(HASH_ROW_SUP(ROW(X),POL(X)).EQ.HASH_CLOSE)  THEN
		 TRABUF(TERR)=CMBCLOS
		 TRABUF(TSTAT)=REJT
                 RETURN
	      ENDIF
	      Y=X+1
	      DO WHILE (Y.LT.SELECT+1)
		 IF(HASH_COMB_SUP(ROW(X),ROW(Y)).EQ.HASH_CLOSE)  THEN
		    TRABUF(TERR)=CMBCLOS
		    TRABUF(TSTAT)=REJT
                    RETURN
		 ENDIF
		 Y=Y+1
	      END DO
	      X=X+1
	   END DO
100	CONTINUE
	ENDIF
	RETURN
	END
