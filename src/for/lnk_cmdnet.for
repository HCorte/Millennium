C
C SUBROUTINE LNK_CMDNET
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]LNK_CMDNET.FOV                               $
C  $Date::   17 Apr 1996 13:51:20                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - net_netsub.for;1 **
c 
C
C NETSUB.FOR
C
C V03 29-DEC-92 TBD RENAMED LNK_CMDNET TO DIFFERENTIATE BETWEEN CMDNET USED
C		    FOR NETMGR AND CMDNET USED BY LNKCH.  CHANGES ALSO MADE TO
C		    LNKCH CALLING STRUCTURE.
C V02 22-OCT-91 TKO Change CALL ABORT to CALL TSKABORT
C V01 01-AUG-90 XXX RELEASED FOR VAX
C
C
C
C     NETSUB.FTN
C
C
C     NETWORK SUBSYSTEM VARIOUS SUBROUTINES
C
C     LNK_CMDNET(BUF)           ;EXECUTE NETWORK COMMAND
C     IN - BUF              ; BUFFER # WITH DATA
C                           ;IN DATA AREA (HDRSIZ+1) SET
C          COMMAND - REQUEST FOR THE CONNECTION
C          PATH    - ORIGINATING NODE
C          VALUE   - NEW VALUE
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE LNK_CMDNET(BUF)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:DESNET.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
C
	INTEGER*4 HOWMANY, SRN, INRECMD, TONODE, FROMMAS, NODE
	INTEGER*4 LUN1, SKIP, TEMP, UNIT, BUFNR, TIMES, SYSTEM
	INTEGER*4 SYS2, SYS1, STAT, ENASYNC, OFF, RLGSER/0/, SER
	INTEGER*4 VAL, TRCADR, BTYPE, CWAY, VALUE, PATH
	INTEGER*4 COMMAND, II, ST, BUF1, COUNT, BWAY, SERMSK, BUF
C
	CHARACTER*28 MESSAGE(4)
	DATA MESSAGE/'checkpoint file error       ',
     *	             'cannot find valid checkpoint',
     *	             'TMF access error            ',
     *	             'invalid date in checkpoint  '/
	INTEGER*4 ARR(2)
	REAL*8 TSKLIS
	DATA TSKLIS/8HLISTEN  /
	DATA SERMSK/Z3FFFFFFF/
	INTEGER*4 UNFREEZ(NETSYS,NUMWAY)
	COMMON /UNFRZ/ UNFREEZ
	LOGICAL SAMELUN      !TRUE IF OPERATION REMOVE ADD LINK TO
C                           SYSTEMS ON SAME LUN
	LOGICAL SSA
	INTEGER*4 REMOVED(NUMWAY)  !REMOVES MASTER NODE FLAG
C
C
C
	BWAY=NETBUF(WAYNR,BUF)              !CURRENT WAY
C
	CALL TSTCHG2(BUF,0,COUNT)
	IF(COUNT.GT.1) THEN
10	   CONTINUE
	   CALL EXTRABUF(BUF1,BWAY,ST)
	   IF(ST.EQ.2) THEN
	      CALL XWAIT(20,1,ST)
	      GOTO 10
	   ENDIF
C
	   DO 20 , II=NCNLEN+1,NETLEN-1
	   NETBUF(II,BUF1)=NETBUF(II,BUF)
20	   CONTINUE
	   NETFROM(BUF1)=NETFROM(BUF)
	   CALL FREEBUF(BUF)
	   BUF=BUF1
	ENDIF
C
	COMMAND=NETBUF(HDRSIZ+1,BUF)
	PATH=NETBUF(HDRSIZ+2,BUF)
	VALUE=NETBUF(HDRSIZ+3,BUF)
	CWAY=NETBUF(HDRSIZ+4,BUF)
	BTYPE=NETBUF(BUFTYP,BUF)
C**   TYPE*,'COMMAND ',COMMAND,PATH,VALUE,CWAY,BTYPE,BWAY
C
	IF(BWAY.NE.CWAY.AND.COMMAND.NE.BROADCAST)THEN
	   CALL NOTIFY(TRCADR,NOTCROSS,BWAY,CWAY)
	ENDIF
C
C
	NETBUF(PDEST,BUF)=0      !FOR ALL SEN DATA
	NETBUF(FDEST,BUF)=0      !FOR ALL SEN DATA
C
	VAL=VALUE
	SER=NXTSER
	IF(NETATR(BWAY).EQ.RLG)SER=RLGSER
	IF(COMMAND.EQ.REMLINK)VAL=SER
	IF (COMMAND.NE.BROADCAST) THEN
	   CALL NOTIFY(TRCADR,NOTCMD,COMMAND,CWAY)
	   CALL NOTIFY(TRCADR,NOTPATH,PATH,CWAY)
	   CALL NOTIFY(TRCADR,NOTVAL,VAL,CWAY)
	ENDIF
C
C**   TYPE*,'COMMAND ',COMMAND,PATH,VALUE,CWAY,BTYPE,BWAY,VAL
	IF (PATH.GT.NETSYS.OR.PATH.LE.0) THEN !INVALID NODE
	   CALL FREEBUF(BUF)
	   CALL NOTIFY(TRCADR,NOTCMD,COMMAND,CWAY)
	   RETURN
	ENDIF
C
	GOTO (100,200,300,400,500,600) COMMAND  !DISPATCH REQUEST
	CALL FREEBUF(BUF)              !FREE BUFFER
	CALL NOTIFY(TRCADR,NOTCMD,COMMAND,CWAY)!NOTIFY ABOUT INVAL CMD
	RETURN
C
C     SET SVC MODE ON THE LINK
C
100	CONTINUE
D	TYPE *,'NETCMD: SET SVC MODE'
C
C     NO CONNECTION OR ALREADY DROPPED
C
	IF (NETROUT(PATH,CWAY).EQ.ROUNO.OR.
     *	    NETSTAT(PATH,CWAY).LT.0) THEN
	   CALL FREEBUF(BUF)            !RELEASE BUFFER
	   RETURN
	ENDIF
C
C     CHECK IF PHYSICAL CONNECTION DEFINED
C
	DO 110, OFF=1,NETLUN
	  IF (OPNNET(OFF,CWAY).EQ.PATH) GOTO 120
110	CONTINUE
C
	CALL FREEBUF(BUF)
	RETURN
C
120	CONTINUE
C
C  IF CONNECTION IS DEAD AND REQUEST ORIGINATED ON OTHER PROCESSOR
C
	IF(NETSTAT(PATH,CWAY).LT.0.AND.
     *	   NETBUF(PPORG,BUF).NE.NODEID) THEN
	  CALL FREEBUF(BUF)
	  RETURN
	ENDIF
C
C     EXECUTE COMMAND
C
	NETROUT(PATH,CWAY)=ROUACT
	NETSTAT(PATH,CWAY)=VALUE
	NETBUF(MODE,BUF)=DRVMD                !DIRVER COMMAND
	CALL TSNDNET(BUF,CWAY)                      !SEND NOW TO DRIVER
D	TYPE*,'LNK_CMDNET  ADD PATH VAL', PATH,VALUE,CWAY
	RETURN
C
C     REMOVE LINK
C
200	CONTINUE
C
C     REMOVE OWN NODE - KILL THIS SYSTEM
C
D	TYPE *,'REMOVE LINK COMMAND'
	IF (PATH.EQ.NODEID.AND.VALUE.EQ.NODEID) THEN !THIS SYSTEM DOWN
C**   TYPE*,'PATH VALUE NODEID', PATH,VALUE,NODEID
C
C     ENABLE FOR ANYBODY TO GRAB HARDWARE
C
	   DO 210, OFF=1,NETSYS
C**	    IF (NETROUT(OFF,CWAY).EQ.ROUACT) CALL FREESWITCH(OFF,CWAY)
210	   CONTINUE
	   IF (NODEID.EQ.NETMASTER(CWAY).AND.CWAY.EQ.WAYINP)THEN
C**      TYPE*,'N(CWAY) ',NETMASTER(CWAY),CWAY,NETBACKUP(CWAY)
C**	      CALL FREECOM   !RELEASE COMMUNICATION (WILL ALSO KILL IT)
	      IF (NETBACKUP(CWAY).NE.0) THEN
	         CALL OPS('CHAR(7)//NETSUB: SET MASTER COMMAND'
	1	    //CHAR(7),1,0)
	         NETBUF(MODE,BUF)=CMDMD
	         NETBUF(HDRSIZ+1,BUF)=SETMASTER
	         NETBUF(HDRSIZ+2,BUF)=NETBACKUP(CWAY)
	         NETBUF(HDRSIZ+3,BUF)=0  !NEW MASTER WILL NOT SEND BACK
	         CALL SNDNET(BUF,CWAY)           !SEND SET MASTER SYSTEM
	      ELSE
	         CALL FREEBUF(BUF)       !FREE BUFFER (WHO CARES NOW?)
	      ENDIF
	   ELSE
C
C     NOTIFY MASTER NODE
C
	         NETBUF(PDEST,BUF)=NODEMASTER(CWAY)
	         NETBUF(FDEST,BUF)=NODEMASTER(CWAY)
	         NETBUF(MODE,BUF)=CMDMD
	         NETBUF(HDRSIZ+1,BUF)=REMLINK
	         NETBUF(HDRSIZ+2,BUF)=NODEID
	         CALL SNDNET(BUF,CWAY)    !SEND TO PRIMARY CONNECTION
	   ENDIF
C                                    ;IF NOT THIS IS MASTER SYSTEM
C**      TYPE*,'KILLING  '
	   IF (NODEID.EQ.NODEMASTER(CWAY)) THEN
	      CALL NOTIFY(TRCADR,NOTABRT,PATH,CWAY)  !ABORT THIS SYSTEM
	      CALL XWAIT(500,1,ST)          !WAIT .5 SEC
	      CALL TSKABORT(8HCMDPRO  ,ST)   !ABORT COMMAND PRO
	      CALL TSKABORT(8HTIMER   ,ST)   !TIMER
	      CALL TSKABORT(8HNETLOG  ,ST)  !NETWORK LOGGER
	      CALL TSKABORT(8HDCNPRO  ,ST)
	      CALL TSKABORT(8HDISPAT  ,ST)  !NETWORK LOGGER
	      CALL GSTOP(GEXIT_FATAL)
	   ELSE
C
C           SET SYSTEM TO SPARE IF NOT MASTER SYSTEM
C
C
	     IF(NETBACKUP(WAYINP).GT.0) THEN
C
	       TYPE*,IAM(),CHAR(7),
	1	    '*******************************************'
	       TYPE*,IAM(),CHAR(7),
	1	    '*       DUE TO NETWORK DIFFICULTIES       *'
	       TYPE*,IAM(),CHAR(7),
	1	    '*   TAKEOVER FEATURE HAS BEEN DISABLED    *'
	       TYPE*,IAM(),CHAR(7),
	1	    '*  THIS SYSTEM IS NO LONGER A HOT BACKUP  *'
	       TYPE*,IAM(),CHAR(7),
	1	    '*******************************************'
C
	       IF (NODEID.EQ.NETBACKUP(CWAY)) NETBACKUP(CWAY)=0
	     ENDIF
	   ENDIF
	   RETURN
	ENDIF
C
C     GENARATE COMMAND ON MASTER SYSTEM
C
      IF(NODEID.EQ.NETMASTER(CWAY).AND.NODEID.EQ.NETMASTER(WAYINP))THEN
	   CALL GAMECMD(REMLINK,PATH,0,CWAY)
	ENDIF
C
	IF (NETROUT(PATH,CWAY).NE.ROUACT) THEN
	   CALL FREEBUF(BUF)
	ELSE
C**	   CALL FREESWITCH(PATH,CWAY)!RLSE ALL COMMUNICATION SWITCH GEAR
	   NETBUF(MODE,BUF)=DRVMD                !DIRVER COMMAND
	   NETBUF(HDRSIZ+1,BUF)=REMLINK            !CLOSE LINK
	   NETBUF(HDRSIZ+2,BUF)=PATH
	   NETROUT(PATH,CWAY)=ROUIDLE            !MAKE CONNECTION IDLE
	   NETSTAT(PATH,CWAY)=-NETSTAT(PATH,CWAY)
	   NETMODE(PATH,CWAY)=0
	   CALL TSNDNET(BUF,CWAY)                   !SEND NOW TO DRIVER
D	   TYPE*,'LNK_CMDNET REM PATH WAY ',PATH,CWAY
	ENDIF
C
	RETURN
C
C     RESYNCHRONIZATION
C
300	CONTINUE
C
D	TYPE *,'LNK_CMDNET: RESYNC COMMAND '
	VALUE=IAND(VALUE,SERMSK)
C
C     RESYNCRONISED SYSTEM LOGIC
C
	IF (PATH.EQ.NODEID) THEN   !THAT IS MY OWN REQUEST ROUTED BACK
	   SER=MOD(VALUE,SYSOFF)
	   IF(CWAY.EQ.WAYINP)THEN
	     NETMODE(NODEID,CWAY)=FILMD       !SET RECOV MODE NOW
D 	     TYPE *,'calling restore ',SER
C
C	     LNKCH UTILIZED A DUMMY ROUTINE FOR CALL TO RESTORE, NOW
C	     THAT LNK_CMDNET IS USED CALL TO RESTORE IS NO LLONGER REQUIRED
C
C	     CALL RESTORE(SER,ST)!RESTORE FR LAST VALID CHECKPOINT
	     ST = 0	!CALL TO RESTORE WAS DUMMY WHEN LINKED WITH LNKCH
	     IF (ST.NE.0) THEN
330	        CONTINUE
                TYPE *,IAM(),CHAR(7),
	1	  'Cannot restore commons from last good checkpoint '
	        TYPE *,IAM(),CHAR(7),'ERROR: ',ST,MESSAGE(ST)
		CALL TSKABORT(8HDCNPRO  ,ST)
		CALL TSKABORT(8HNETLOG  ,ST)
		CALL GSTOP(GEXIT_FATAL)
	      ENDIF
D	      TYPE *,'restored from checkpoint'
	   ELSE
D	      TYPE *,'NOT CALLING RESTORE.'
340	      CONTINUE
	      CALL EXTRABUF(BUF1,CWAY,ST)
	      IF(ST.EQ.2)THEN
	        CALL XWAIT(20,1,ST)
	        GOTO 340
	      ENDIF
C
	      NETBUF(MODE,BUF1)=REMMD
	      NETBUF(WAYNR,BUF1)=CWAY
	      NETBUF(BUFTYP,BUF1)=RLG
	      NETBUF(HDRSIZ+1,BUF1)=SER
C
	      CALL ABL(BUF1,REMFINISH,ST)
	   ENDIF
C
	   CALL FREEBUF(BUF)
	   RETURN
	ENDIF
C
C     MASTER OR INTERMEDIATE NODE LOGIC
C
	IF (NETBUF(PPORG,BUF).NE.NETMASTER(CWAY))THEN!CAME FROM SEC
C
C     NOT ON MASTER ROUTE IT AHEAD
C
D	   TYPE *,'RESYNC COMMAND FROM SECONDARY '
	   IF (NODEMASTER(CWAY).NE.0) THEN
	      IF (NETSTAT(NODEMASTER(CWAY),CWAY).EQ.NSTASEC
     *	          .AND.NETROUT(NODEMASTER(CWAY),CWAY).EQ.ROUACT) THEN
C
D	         TYPE *,'BUILDING COMMAND BACK 1'
	         NETBUF(MODE,BUF)=CMDMD
	         NETBUF(HDRSIZ+1,BUF)=COMMAND
	         NETBUF(HDRSIZ+2,BUF)=PATH
	         NETBUF(HDRSIZ+3,BUF)=VALUE
	         NETBUF(PDEST,BUF)=NODEMASTER(CWAY)
	         NETBUF(FDEST,BUF)=NODEMASTER(CWAY)
C
	         CALL SNDNET(BUF,CWAY)
	         RETURN
	      ENDIF
	   ENDIF
C
C        THIS IS MASTER SYSTEM
C
C
C     RESYNC ADDRESS CANNOT BE HIGHER THAN MASTER LAST COMMAND
C
	   IF (P(LSTCMD).LT.VALUE) VALUE=P(LSTCMD)
D	   IF (P(LSTCMD).LT.VALUE) TYPE*,'VAL P(LST) ',VALUE,P(LSTCMD)
	   CALL GAMECMD(RESYNC,PATH,VALUE,CWAY)
	   CALL NOTIFY(TRCADR,NOTRES,PATH,CWAY)
C
C       IF SYNCHRONISATION ENABLED, TRY TO RESYNCHRONIZE
C
	   ENASYNC=NETENA(PATH,CWAY)
	   IF (ENASYNC.EQ.0.OR.ENASYNC.EQ.1) THEN   ! IF SYNCHRONISATION ENABLED
D	     TYPE *,'RESYNC ENABLED - SEND BACK TO ORIGINATOR'
	     NETBUF(PDEST,BUF)=NETBUF(PPORG,BUF)  !SEND IT TO ORIGINATOR
	     NETBUF(FDEST,BUF)=NETBUF(PPORG,BUF)  !SEND IT TO ORIGINATOR
	     NETBUF(PPORG,BUF)=NODEID
	     NETBUF(HDRSIZ+3,BUF)=VALUE
	     CALL SNDNET(BUF,CWAY)                   !SEND IT BACK
	     IF (NETROUT(PATH,CWAY).EQ.ROUACT) THEN !IF THAT IS ACTIVE
C                                                    CONNECTION
D	        TYPE *,'SETTING MEMORY TO RECOVERY MODE'
	        NETMODE(PATH,CWAY)=FILMD
	        NETRECOV(PATH,CWAY)=RECIN   !RECOVERY IN PROGRESS
	        NETSER(PATH,CWAY)=VALUE
	        UNFREEZ(PATH,CWAY)=NETTIMER+60000   !WAIT A WHILE BEFORE
C                                                 ;SENDING
	     ENDIF
	   ELSE
D	     TYPE *,'RESYNC DISABLED'
	     CALL FREEBUF(BUF)
	   ENDIF
	   RETURN
	ENDIF
	IF (NETROUT(PATH,CWAY).NE.ROUACT) THEN !IF NO ACTIVE CONNECTION
D	   TYPE *,'NO ACTIVE CONNECTION'
	   CALL FREEBUF(BUF)
	   RETURN
	ENDIF
C                                           WITH NODE TO BE RESYNC
C
C     THIS SYSTEM HAS TO RESYNCHRONIZE SYSTEM "PATH"
C
D	TYPE *,'SYSTEM HAS TO RESYNC SYSTEM PATH'
	NETBUF(PDEST,BUF)=PATH
	NETBUF(FDEST,BUF)=PATH
	NETSER(PATH,CWAY)=VALUE
	NETMODE(PATH,CWAY)=FILMD
	NETRECOV(PATH,CWAY)=RECIN
	NETTIM(PATH,CWAY)=NETTIMER
	UNFREEZ(PATH,CWAY)=NETTIMER+60000
	CALL SNDNET(BUF,CWAY)
	RETURN
C
C     SET SYSTEM TO MASTER
C
400	CONTINUE
D	TYPE *,'SETMASTER ',NETMASTER(CWAY),CWAY,PATH,NODEID
C
	IF (NETMASTER(CWAY).EQ.PATH) THEN
	   CALL FREEBUF(BUF)
	   RETURN
	ENDIF
C
	IF(NETATR(CWAY).EQ.INP)THEN
	   CALL STTSK(TSKLIS,ARR,STAT)
	   IF(STAT.NE.4) THEN !IN MEM NOT DORMANT
	      CALL RELSE(TSKLIS,ST)
	      CALL XWAIT(2,2,ST)
	      PANICSYS=0
	      CALL TSKABORT(TSKLIS,ST)
	   ENDIF
	ENDIF
C
C
	IF (NODEID.NE.PATH) THEN !THIS IS NOT YOUR SYSTEM
C
C     SHOULD SWITH ANY NODES THAT ARE IDLE ON THAT SYSTEM AND PREVIOUS
C     MASTER WAS CONNECTED TO YOUR SYSTEM
C
	   CALL FREEBUF(BUF)
C
C        ON OLD MASTER DISCONNECT ALL CONECTIONS
C
	   IF (NODEID.EQ.NETMASTER(CWAY)) NETMASTER(CWAY)=PATH
C
C
	   SYS1=NETMASTER(CWAY)
	   SYS2=NETMASTER(CWAY)
	   IF (NETMASTER(CWAY).EQ.PATH) THEN !ON OLD MASTER
	     SYS1=1
	     SYS2=NETSYS
	   ENDIF
C
	   DO 402, BWAY=1,NUMWAY
	   REMOVED(BWAY)=0
	   DO 402, SYSTEM=SYS1,SYS2
	   IF (NETROUT(SYSTEM,BWAY).GE.ROUIDLE)THEN !IF CONN ACT
C***!       IF (SYSTEM.EQ.NETMASTER(CWAY))
C***!*       REMOVED(BWAY)=NETOPN(SYSTEM,BWAY) ;YOU REMOVED THIS
	     IF (SYSTEM.EQ.NETMASTER(CWAY)) THEN    !8/07/86
	         REMOVED(BWAY)=NETOPN(SYSTEM,BWAY)
	         IF (NODEID.EQ.NETMASTER(BWAY).AND.SYSTEM.EQ.PATH)
     *	             NETMASTER(BWAY)=PATH
C
C                                                       ;ALL PATHS
C         IF CAME ON LOG WAY, DO NOT MARK AS REMOVED IF YOU ARE NOT
C         MASTER LOG WAY
C
	    IF(NETATR(CWAY).EQ.RLG.AND.WAYLOG.GT.0) THEN
	       IF(NODEID.NE.NETMASTER(WAYLOG)) REMOVED(BWAY)=0
	    ENDIF
C                               ;IF CAME ON LOG WAY AND U ARE NOT
C                            NOT MASTER OF LOG WAY DO NOT CONN. BACK
C
	    ENDIF
	     NETSTAT(SYSTEM,BWAY)=IABS(NETSTAT(SYSTEM,BWAY))
	     IF (NETROUT(SYSTEM,BWAY).EQ.ROUACT) THEN
401	     CONTINUE
	     CALL EXTRABUF(BUF,BWAY,ST)
	     IF (ST.EQ.2) THEN
	       CALL XWAIT(10,1,ST)
	       GOTO 401
	     ENDIF
C
C     REMEMBER CONNECTIONS THAT HAVE TO BE REOPENED TO NEW MASTER
C
	     NETREM(SYSTEM,BWAY)=-1
	     NETBUF(MODE,BUF)=DRVMD
	     NETBUF(HDRSIZ+1,BUF)=REMLINK
	     NETBUF(HDRSIZ+2,BUF)=SYSTEM
	     NETBUF(HDRSIZ+4,BUF)=BWAY
C
	     CALL SNDNET(BUF,BWAY)       !SEND VIA ALL PRIMARY LINKS
D	     TYPE*,'TO REMOVE ',SYSTEM
	     NETROUT(SYSTEM,BWAY)=ROUIDLE !MAKE CONNECTION IDLE
	    ENDIF
C
	   ENDIF
402	   CONTINUE
C
C     IF ANYTHING REMOVED
C     ADD LINK TO THE SYSTEM IT WAS REMOVED FROM
C
C
C
	   TIMES=0    !TIMOUT COUNT FOR REMOVE LIK
D	TYPE *,' REMOVED ',REMOVED
	   DO 420, BWAY=1,NUMWAY
	   IF (REMOVED(BWAY).NE.0) THEN !IF THIS CONNECTION WAS DROPPED
410	     CONTINUE
	     CALL EXTRABUF(BUFNR,BWAY,ST)
	     IF (ST.EQ.2) THEN
	        CALL XWAIT(50,1,ST)
	        GOTO 410
	     ENDIF
C
C          WAIT BEFORE ADDLINK (AFTER REMLINK)
C
C
D	     TYPE *,'netadd ',NETREM(NETMASTER(CWAY),BWAY),BWAY
415	     CONTINUE
	     IF(NETREM(NETMASTER(CWAY),BWAY).NE.0.AND.TIMES.LE.50)
     *	        THEN
	       CALL XWAIT(100,1,ST)
	       TIMES=TIMES+1
	       GOTO 415
	     ENDIF
C
C
	     NETBUF(MODE,BUFNR)=DRVMD
	     NETBUF(HDRSIZ+1,BUFNR)=ADDLINK
	     NETBUF(HDRSIZ+2,BUFNR)=PATH
	     NETBUF(HDRSIZ+4,BUFNR)=BWAY
	     IF (NETATR(CWAY).EQ.INP) THEN   !IF CAME ON INPUT WAY
	        NETSTAT(PATH,BWAY)=NSTASEC
	     ELSE       !PRESERVE SAME STATUS AS PREVIOUS MASTER
	        NETSTAT(PATH,BWAY)=NETSTAT(NETMASTER(CWAY),BWAY)
	     ENDIF
	     UNIT=REMOVED(BWAY)
	     TEMP=IAND(NETDEV(1,UNIT),'FFFFFF00'X)
	     SSA=TEMP.EQ.'53534100'X   !.EQ.'SSA'
	     IF (SSA) THEN
C
C       IF REQUEST CAME ON LOG WAY, SET LAST MASTER TO IDLE
C
	        IF (OPNNET(UNIT,BWAY).EQ.NETMASTER(CWAY).AND.
     *	            NETATR(CWAY).EQ.RLG) THEN
	            NETROUT(NETMASTER(CWAY),BWAY)=ROUIDLE
	            NETSTAT(NETMASTER(CWAY),BWAY)=NSTAIDLE
	        ENDIF
C
C***!          OPNNET(UNIT,BWAY)=PATH         ;SSA'S ON LOCAL HAVE
C***!          OPNNET(UNIT+1,BWAY)=PATH       ;HAVE DIFF LUNS NOW
C                                            ;NOT SHARED 5/26 MK
	     ENDIF
	     NETBUF(HDRSIZ+3,BUFNR)=NETSTAT(PATH,BWAY)
	     NETROUT(PATH,BWAY)=ROUACT
D	  TYPE *,'ADDED WAY, PATH, STAT ',BWAY,PATH,NETSTAT(PATH,BWAY)
	     CALL SNDNET(BUFNR,BWAY)     !SWITCH MODE
	  ELSE
C     ON SSA ALL CONNECTIONS TO MASTER SYSTEM ARE SHARED
C     BECAUSE OF THAT REASSIGNMENT OF UNIT SHOULD BE DONE EVEN
C     IF SYSTEM IS NOT ACTIVELY CONNECTED TO MASTER SYSTEM
C     E.G. SYSTEM D WORKING AS BACKUP OF SYSTEM C CHANGES
C     ITS LOGICAL ASSIGNMENTS TO B IF B TAKESOVER A
C
	      IF(CWAY.NE.WAYINP) THEN      !DONT DO IT IF IT CAME
C                                        ;ON LOCAL (3 SYSTEMS)
	        SKIP=0
	        DO 419, LUN1=1,NETLUN
	         TEMP=IAND(NETDEV(1,LUN1),'FFFFFF00'X)
	         SSA=TEMP.EQ.'53534100'X   !.EQ.'SSA'
	         IF (SSA.AND.OPNNET(LUN1,BWAY).EQ.NETMASTER(CWAY)) THEN
C***!             OPNNET(LUN1,BWAY)=PATH      ;SSA NOT SHARED ON LOCAL
C                                            ;5/26 MK
	           IF (SKIP.EQ.0) THEN   !DO IT ONCE
	             NETROUT(PATH,BWAY)=ROUIDLE
	             NETSTAT(PATH,BWAY)=NETSTAT(NETMASTER(CWAY),BWAY)
	             NETROUT(NETMASTER(CWAY),BWAY)=ROUNO
	             NETSTAT(NETMASTER(CWAY),BWAY)=NSTAIDLE
	             SKIP=-1
	           ENDIF
	         ENDIF
419	        CONTINUE
	      ENDIF
	   ENDIF
420	   CONTINUE
C
C
	   IF(NETBACKUP(CWAY).EQ.PATH)NETBACKUP(CWAY)=0
C
	   NETMASTER(CWAY)=PATH   !TO LET 'NOT MASTER' WHO'S NOT
C                               EITHER BECOMINING THE MASTER WHICH
C                               NODE IS NOW NEW MASTER
C
C**	   IF(NETATR(CWAY).EQ.INP)THEN
C**	     CALL XWAIT(500,1,ST)      !ABORTING OLD LISTEN IN PROGRESS
C
C**	     CALL NRUNTASK(TSKLIS)
C**	   ENDIF
C
C
C
	   RETURN
	ENDIF
C
C     SWITCH YOUR SYSTEM TO PRIMARY ON THE INPUT PATH
C
	CALL FREEBUF(BUF)
C
C	GRABNET NOT USED BY LNKCH TASK, PREVIOUSLY GRABNET WAS A DUMMY ROUTINE
C	WHEN LINKED WITH LNKCH
C
C	IF(NETATR(CWAY).EQ.INP)CALL GRABNET(0,VALUE,CWAY) !TAKEOVER ON INP WA
C                     AND IF VALUE =1 SEND SETMASTER TO OLD MAST
	RETURN
C
C     BROADCAST
C
500	CONTINUE
	CWAY=BWAY           !FOR BROADCAST HDRSIZ+4 OFFSET IS USED
C                         ;FOR SOMETHING ELSE,BWAY IS OK
	NODE=NETBUF(HDRSIZ+2,BUF)
C
	FROMMAS=1
	IF(NETBUF(HDRSIZ+4,BUF).NE.-999)FROMMAS=0
D     TYPE*,'FRM',FROMMAS,' PDST ',NETBUF(PDEST,BUF),NETBUF(FDEST,BUF)
D	TYPE*,'NETFROM(BUF) ',NETFROM(BUF),BUF
C
	IF(NODEID.NE.NETMASTER(CWAY))THEN          !ANY SECONDARY
	   IF(NETSTAT(NETFROM(BUF),CWAY).EQ.NSTASEC)THEN
	      TONODE=NETFROM(BUF)
	   ELSEIF(NETSTAT(NETFROM(BUF),CWAY).EQ.NSTAPRIM)THEN
	      TONODE=0
	      DO 510 OFF=1,NETSYS
	      IF(NETSTAT(OFF,CWAY).NE.NSTASEC.OR.
     *	         NETROUT(OFF,CWAY).NE.ROUACT) GOTO 510
	      IF (TONODE.EQ.0) TONODE=OFF
	      IF (NETTIM(TONODE,CWAY).LT.NETTIM(OFF,CWAY))TONODE=OFF
D	      TYPE *,'TONODE ',TONODE
510	      CONTINUE
C
	   ENDIF
C
	   IF(TONODE.EQ.0) THEN
	      CALL FREEBUF(BUF)
	      RETURN
	   ENDIF
C
	   INRECMD=0
C
	   IF (NETMODE(NODEID,CWAY).EQ.FILMD) INRECMD=1
C
	   IF(FROMMAS.EQ.1) THEN    !CAME FROM MASTER
C
C        CHECK IF YOU MISSED A TAKEOVER ON THE OTHER SIDE
C
	   IF(NODE.NE.NETMASTER(CWAY))THEN
C
C           GENERATE A COMMAND NOW, IGNORE BROADCAST
C
	      TYPE *,'NETSUB2: SETMASTER 2 !!!!!!!'
	      NETBUF(HDRSIZ+1,BUF)=SETMASTER
	      NETBUF(HDRSIZ+2,BUF)=NODE
	      NETBUF(HDRSIZ+3,BUF)=0
	      NETBUF(HDRSIZ+4,BUF)=CWAY
	      NETBUF(MODE,BUF)=CMDMD
	      NETBUF(WAYNR,BUF)=CWAY
C
	      CALL ABL(BUF,NETFINISH,ST)
D	      TYPE*,'MISSED TAKEOVER ',NODE,CWAY
	      RETURN
C
	   ENDIF
C
C
C           THE LAST SYSTEM ON THE PATH
C
	      NETBUF(HDRSIZ+2,BUF)=NODEID
	      NETBUF(HDRSIZ+4,BUF)=0      !I'M NOT THE MASTER
	      IF(INRECMD.EQ.1) THEN
	         SRN=NXTSER
	         IF (NETATR(CWAY).NE.INP) SRN=RLGSER
	         NETBUF(HDRSIZ+6,BUF)=SRN
	         NETBUF(HDRSIZ+5,BUF)=FILMD
	      ELSE
	         NETBUF(HDRSIZ+5,BUF)=TRNMD
	      ENDIF
	   ELSE                       !CAME FROM NOT MASTER
C
C           THE INTERMEDIATE SYSTEM
C
	      NETBUF(HDRSIZ+4,BUF)=NETBUF(HDRSIZ+4,BUF)+1
	      NETBUF(NETBUF(HDRSIZ+7,BUF),BUF)=NODEID
	      NETBUF(HDRSIZ+7,BUF)=NETBUF(HDRSIZ+7,BUF)+1
	   ENDIF
C
C
C        SEND IT UPWARDS
C
	   NETBUF(NEXT,BUF)=HDRSIZ+14
	   NETBUF(PDEST,BUF)=TONODE
	   NETBUF(FDEST,BUF)=TONODE
	   CALL SNDNETC(BUF,CWAY)
D	     TYPE*,'BROADCAST SENT BACK ',(NETBUF(II,BUF),II=4,30)
C
	   RETURN
C
	ELSE
C
C        SERVICE THE COMMAND ON THE PATH MASTER SYSTEM
C
	   NETBRO(NODE,CWAY)=NETTIMER-VALUE
	   LSTBRO(NODE,CWAY)=NETTIMER
	   NETRECV(1,NODE,CWAY)=NETBUF(HDRSIZ+5,BUF)
	   IF(NETRECV(1,NODE,CWAY).EQ.FILMD)THEN
                             NETRECV(2,NODE,CWAY)=NETBUF(HDRSIZ+6,BUF)
	   ELSE
	                         NETRECV(2,NODE,CWAY)=0
	   ENDIF
	   NETFLOW(1,NODE,CWAY)=2
	   NETFLOW(2,NODE,CWAY)=NETMASTER(CWAY)
	   NETFLOW(NETBUF(HDRSIZ+4,BUF)+3,NODE,CWAY)=NODE
C
C
	  IF(NETBUF(HDRSIZ+4,BUF).GT.0) THEN  !IF ANYBODY SIGNED ON
C                                           ;ON THE WAY
C
	  HOWMANY=NETBUF(HDRSIZ+4,BUF)
	  NETFLOW(1,NODE,CWAY)=NETFLOW(1,NODE,CWAY)+HOWMANY
	  DO 512 OFF=1,HOWMANY
	  NETFLOW(2+OFF,NODE,CWAY)=
     *	      NETBUF(HDRSIZ+8+HOWMANY-OFF,BUF)
512	  CONTINUE
C
	  ENDIF
C
D	     TYPE*,'NETFLOW ',NETFLOW
D	     TYPE*,'NETBRO  ',NETBRO
D	     TYPE*,'NETRECV ',NETRECV
D	     TYPE*,'HOWMANY ',HOWMANY
C
	ENDIF
	CALL FREEBUF(BUF)
	RETURN
C
600	CONTINUE        !REMOTE CLOSED COMMAND
C
	REMCLOSED(NETFROM(BUF))=-1
D	TYPE*,'REMCLOSED NODE ',NETFROM(BUF)
C
	CALL FREEBUF(BUF)
C
	RETURN
C
C
	END
