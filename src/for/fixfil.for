C
C PROGRAM FIXFIL
C $Log:   GXAFXT:[GOLS]FIXFIL.FOV  $
C  
C     Rev 1.0   17 Apr 1996 13:10:38   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 16:18:24   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - fixfil.for **
C
C FIXFIL.FOR
C
C V01 01-AUG-90 XXX RELEASED FOR VAX
C
C B05 27-DEC-1989 TKO  READ INDEXED RECORD IN BINARY MODE
C B04 01-AUG-1989 TKO  HANDLE UP TO 128 SECTORS PER BUCKET
C                      DISPLAY FULLWORD,HALFWORD, BYTE OFFSETS
C B03 21-SEP-1988 TKO  OPEN EXTENDABLE CONTIGUOUS FILES
C B02 30-JUN-1987 TKO  SET BIAS (BI=XXX OR BI=.) AND
C                      INCREMENT (+X OR -X)
C                      NEW STUFF FOR CHANGING LOCATIONS
C B01 09-FEB-1985 TKO  INITIAL RELEASE
C
C ROUTINE TO ALLOW A FIX TO A FILE
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM FIXFIL
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INTEGER*4  MAXSEC
	PARAMETER (MAXSEC=128)
C
	CHARACTER*30 FILNAM
	CHARACTER*10 FILTYP
C
	INTEGER*4 FDB(7)
C
	INTEGER*4 ST, FTYP, RLEN, FSIZ, NUMSEC, RECNUM, K, BIAS
	INTEGER*4 CUROFF, HIOFF, FULL, FULLX, HALF, HALFX, BYTE
	INTEGER*4 ZLEN, INPLEN, CHNGS, YNFLG, INC, NEWBI, VAL
	INTEGER*4 X, NEGFLG
C
	INTEGER*4 I4BUF(SECSIZE/4*MAXSEC)
	INTEGER*2 I2BUF(SECSIZE/2*MAXSEC)
	CHARACTER I1BUF(SECSIZE  *MAXSEC)
	CHARACTER CXBUF*32768
	EQUIVALENCE (I4BUF,I2BUF,I1BUF,CXBUF)
C
	INTEGER*4 HLDBUF(SECSIZE/4*MAXSEC)
C
	INTEGER*4 I4TEMP
	INTEGER*2 I2TEMP(2)
	CHARACTER I1TEMP(4)
	EQUIVALENCE (I4TEMP,I2TEMP,I1TEMP)
C
	CHARACTER*2 NEWFMT,CURFMT
C
	INTEGER*4    I4INP(10)
	CHARACTER*40 C40INP
	CHARACTER*1  C1INP(40)
	EQUIVALENCE (I4INP,C40INP,C1INP)
C
	INTEGER*4    I4OUT(20)
	CHARACTER*80 CXOUT
	CHARACTER*1  C1OUT(80)
	EQUIVALENCE (I4OUT,CXOUT,C1OUT)
C
	LOGICAL CONTIG
	LOGICAL DSPFULL
C
C
	CHARACTER BELL/Z07/
C
	CHARACTER*80 CXHDR
	DATA CXHDR(1:31)/
     *	 ' record fullwrd halfwrd    byte'/
	DATA CXHDR(32:80)/
     *	 '  bias    off  fm          value'/
C
C
C
	CALL COPYRITE
C
	TYPE *,IAM()
	TYPE *,IAM(),'<<<<<< FIXFIL B05 >>>>>>'
	TYPE *,IAM()
C
	CURFMT='I4'
	DSPFULL=.FALSE.
C
200	CONTINUE
	CALL INPTEXT('ENTER NAME OF FILE:', FILNAM, ST)
	IF(FILNAM.EQ.'E ') CALL GSTOP(GEXIT_SUCCESS)
C
	OPEN(1,FILE=FILNAM,IOSTAT=ST,STATUS='OLD',SHARED)
	IF(ST.NE.0)THEN
	  CALL LIB$SIGNAL(%VAL(ST))
	  TYPE *,IAM(),'CANNOT OPEN THAT FILE...TRY AGAIN, ST= ',ST
	  GO TO 200
	ENDIF
C
	CALL GETFTYP(1,FTYP)
	IF(FTYP.EQ.2)THEN
	  CONTIG=.FALSE.
	  CALL GETFLEN(1,RLEN)
	  CALL USRCLOS1(1)
	  OPEN(1,FILE=FILNAM,IOSTAT=ST,STATUS='OLD',SHARED     ,
     *	       ACCESS='DIRECT',RECL=RLEN)
	  IF(ST.NE.0)THEN
	    TYPE *,IAM(),'CANNOT REOPEN INDEXED FILE'
	    CALL GSTOP(GEXIT_FATAL)
	  ENDIF
	  CALL GETFSIZ(1,FSIZ)
	  TYPE *,IAM(),'FILE IS INDEXED WITH ',FSIZ,RLEN,'-CHARACTER RECORDS'
	ELSE
	  CONTIG=.TRUE.
	  CALL VAXGETFSIZ(1,FSIZ)
	  TYPE *,IAM(),'FILE IS CONTIGUOUS WITH ',FSIZ,' SECTORS'
	  CALL INPNUM('# OF SECTORS PER RECORD:',NUMSEC,1,MAXSEC,ST)
	  IF(ST.NE.0)GO TO 200
	  CALL USRCLOS1(1)
	  CALL OPENX(1,FILNAM,4,0,0,ST)
	  IF(ST.NE.0)CALL LIB$STOP(%VAL(ST))
	  CALL IOINIT(FDB,1,NUMSEC*SECSIZE)
	  RLEN=NUMSEC*SECSIZE
	ENDIF
C
C
300	CONTINUE
	CALL INPNUM('ENTER RECORD NUMBER:    ',RECNUM,1,FSIZ,ST)
	IF(ST.NE.0)THEN
	  CALL USRCLOS1(     1)
	  GO TO 200
	ENDIF
C
C
	IF(CONTIG)THEN
	  CALL READW(FDB,RECNUM,I4BUF,ST)
	ELSE
	  READ(1,REC=RECNUM,IOSTAT=ST)CXBUF(1:RLEN)
	ENDIF
	IF(ST.NE.0)THEN
	  CALL LIB$SIGNAL(%VAL(ST))
	  TYPE *,IAM(),'CANNOT READ RECORD ',RECNUM,' STATUS = ',ST
	  GO TO 300
	ENDIF
C
	DO 350 K=1,(RLEN+3)/4
	  HLDBUF(K)=I4BUF(K)
350	CONTINUE
C
C
	TYPE *,IAM(),' '
	TYPE *,IAM(),'Valid formats are: I1,C1,Z2  I2,Z4  I4,Z8'
	TYPE *,IAM(),'Current format is: ',CURFMT
	TYPE *,IAM(),' '
	TYPE *,IAM(),'Enter W to write out, E to exit without write'
	TYPE *,IAM(),' '
	TYPE *,IAM(),'Enter HELP to get some help'
	TYPE *,IAM(),' '
C
	BIAS=0
	CUROFF=1
C
	IF(DSPFULL)THEN
	  TYPE '(X,A)',CXHDR
	ELSE
	  TYPE '(X,A)',CXHDR(32:80)
	ENDIF
C
C
C COME HERE TO DISPLAY CURRENT VALUE
C
C
1000	CONTINUE
	HIOFF=0
	IF(CURFMT.EQ.'C1' .OR. CURFMT.EQ.'Z2' .OR.
     *	   CURFMT.EQ.'I1')THEN
	  HIOFF=RLEN
	  FULL =(CUROFF+3)/4
	  FULLX=MOD(CUROFF-1,4)
	  HALF =(CUROFF+1)/2
	  HALFX=MOD(CUROFF-1,2)
	  BYTE =CUROFF
C
	ELSE IF(CURFMT.EQ.'Z4' .OR. CURFMT.EQ.'I2')THEN
	  HIOFF=(RLEN+1)/2
	  FULL =(CUROFF+1)/2
	  FULLX=MOD(CUROFF-1,2)
	  HALF =CUROFF
	  HALFX=0
	  BYTE =(CUROFF-1)*2 + 1
C
	ELSE
	  HIOFF=(RLEN+3)/4
	  FULL =CUROFF
	  FULLX=0
	  HALF =(CUROFF-1)*2 + 1
	  HALFX=0
	  BYTE =(CUROFF-1)*4 + 1
	ENDIF
C
	CXOUT=' '
	WRITE (CXOUT,10001)RECNUM,CURFMT
10001	FORMAT(I7,3(8X),7X,6X,' (',A2,')=',12X)
	IF(CUROFF.EQ.0)THEN
	  GO TO 1500
	ENDIF
C
	WRITE (CXOUT,10002)FULL,FULLX,HALF,HALFX,BYTE,0,
     *	                   BIAS,CUROFF-BIAS
10002	FORMAT(7X,3(I6,'/',I1),I6,'+',I6)
C
	ZLEN=1
	IF(CURFMT.EQ.'C1')THEN
	  WRITE (CXOUT(58:),10012)ICHAR(I1BUF(CUROFF))
10012	  FORMAT('<',Z2,'>')
	  IF(C1OUT(59).EQ.' ')C1OUT(59)='0'
C
	  IF(ICHAR(I1BUF(CUROFF)).GE.32 .AND.
     *	     ICHAR(I1BUF(CUROFF)).LE.127)THEN
	    CXOUT(63:63)=I1BUF(CUROFF)
	  ENDIF
C
	ELSE IF(CURFMT.EQ.'Z2')THEN
	  WRITE (CXOUT(53:),1001)I1BUF(CUROFF)
1001	  FORMAT(9X,Z2)
	  ZLEN=2
C
	ELSE IF(CURFMT.EQ.'I1')THEN
	  WRITE (CXOUT(53:),10011)ICHAR(I1BUF(CUROFF))
10011	  FORMAT(I11)
C
	ELSE IF(CURFMT.EQ.'I2')THEN
	  WRITE (CXOUT(53:),1002)I2BUF(CUROFF)
1002	  FORMAT(I11)
C
	ELSE IF(CURFMT.EQ.'Z4')THEN
	  WRITE (CXOUT(53:),1003)I2BUF(CUROFF)
1003	  FORMAT(7X,Z4)
	  ZLEN=4
C
	ELSE IF(CURFMT.EQ.'I4')THEN
	  WRITE (CXOUT(53:),1004)I4BUF(CUROFF)
1004	  FORMAT(I11)
C
	ELSE IF(CURFMT.EQ.'Z8')THEN
	  WRITE (CXOUT(53:),1005)I4BUF(CUROFF)
1005	  FORMAT(3X,Z8)
	  ZLEN=8
	ENDIF
C
	IF(CURFMT(1:1).EQ.'Z')THEN
	  DO 1100 K=63-ZLEN+1,63
	    IF(C1OUT(K).EQ.' ')C1OUT(K)='0'
1100	  CONTINUE
	ENDIF
C
C
1500	CONTINUE
	IF(DSPFULL)THEN
	  WRITE(6,1501) CXOUT(1:64)
1501	  FORMAT(X,A,'> ',$)
	ELSE
	  WRITE(6,1501) CXOUT(32:64)
	ENDIF
C
C COME HERE TO GET INPUT
C
	CALL READX(5,C40INP,INPLEN)
C
	IF(INPLEN.EQ.0)THEN
	  IF(CUROFF+1.GT.HIOFF)THEN
	    TYPE *,IAM(),'    END OF BUFFER',BELL
	  ELSE
	    CUROFF=CUROFF+1
	  ENDIF
	  GO TO 1000
	ENDIF
C
C Check for 'W'
C
	IF(INPLEN.EQ.1 .AND. C1INP(1).EQ.'W')THEN
	  IF(CONTIG)THEN
	    CALL WRITEW(FDB,RECNUM,I4BUF,ST)
	  ELSE
	    WRITE(1,REC=RECNUM,IOSTAT=ST)CXBUF(1:RLEN)
	  ENDIF
	  IF(ST.EQ.0)THEN
	    TYPE *,IAM(),'RECORD UPDATED SUCCESSFULLY'
	    DO 2050 K=1,(RLEN+3)/4
	      HLDBUF(K)=I4BUF(K)
2050	    CONTINUE
	  ELSE
	    TYPE *,IAM(),'   UNABLE TO WRITE, STATUS = ',ST,BELL
	  ENDIF
	  GO TO 300
	ENDIF
C
C Check for 'E'
C
	IF(INPLEN.EQ.1 .AND. C1INP(1).EQ.'E')THEN
	  CHNGS=0
	  DO 2080 K=1,(RLEN+3)/4
	    IF(HLDBUF(K).NE.I4BUF(K))THEN
	      TYPE 2081,K,HLDBUF(K),I4BUF(K)
2081	      FORMAT(X,'I4 LOC',I5,' CHANGED FROM ',I12,' TO ',I12)
	      CHNGS=CHNGS+1
	    ENDIF
2080	  CONTINUE
	  IF(CHNGS.NE.0)THEN
	    CALL WIMG(5,'Do you still wish to exit without update?')
	    CALL YESNO(YNFLG)
	    IF(YNFLG.NE.1)GO TO 1000
	  ENDIF
	  TYPE *,IAM(),'RECORD NOT UPDATED'
	  GO TO 300
	ENDIF
C
C Check for +nnn or -nnn or + or -
C
	IF(C1INP(1).EQ.'+' .OR. C1INP(1).EQ.'-')THEN
	  IF(INPLEN.EQ.1)THEN
	    INC=1
	  ELSE
	    CALL ASCBIN(I4INP,2,INPLEN-1,INC,ST)
	    IF(ST.NE.0)GO TO 7000
	  ENDIF
	  IF(C1INP(1).EQ.'-')INC=-INC
	  IF(CUROFF+INC.LT.1 .OR. CUROFF+INC.GT.HIOFF)THEN
	    TYPE *,IAM(),BELL,'OUTSIDE BUFFER RANGE'
	  ELSE
	    CUROFF=CUROFF+INC
	  ENDIF
	  GO TO 1000
	ENDIF
C
C Check for BIAS=nnn
C
	IF(C40INP(1:3).EQ.'BI=')THEN
	  IF(INPLEN.LT.4)THEN
	    TYPE *,IAM(),BELL,'INVALID BIAS.  USE BI=XXX'
	    GO TO 1000
	  ENDIF
	  IF(INPLEN.EQ.4 .AND. C1INP(4).EQ.'.')THEN
	    NEWBI=CUROFF
	  ELSE
	    CALL ASCBIN(I4INP,4,INPLEN-3,NEWBI,ST)
	    IF(ST.NE.0)GO TO 7000
	  ENDIF
	  IF(NEWBI.LT.0 .OR. NEWBI.GT.HIOFF)THEN
	    TYPE *,IAM(),BELL,'BIAS OUTSIDE RANGE'
	    GO TO 1000
	  ENDIF
	  BIAS=NEWBI
	  GO TO 1000
	ENDIF
C
C Check for FMT=xx
C
	IF(C40INP(1:4).EQ.'FMT=')THEN
	  NEWFMT=C40INP(5:6)
	  IF(NEWFMT.EQ.'C1' .OR. NEWFMT.EQ.'Z2' .OR.
     *	     NEWFMT.EQ.'I1')THEN
	    IF(CUROFF.NE.0)THEN
	      IF(CURFMT.EQ.'I2' .OR. CURFMT.EQ.'Z4')THEN
	        CUROFF=CUROFF*2-1
	        IF(BIAS.NE.0)BIAS=BIAS*2-1
	      ENDIF
	      IF(CURFMT.EQ.'I4' .OR. CURFMT.EQ.'Z8')THEN
	        CUROFF=CUROFF*4-3
	        IF(BIAS.NE.0)BIAS=BIAS*4-3
	      ENDIF
	    ENDIF
	    CURFMT=NEWFMT
	    GO TO 1000
C
	  ELSE IF(NEWFMT.EQ.'I2' .OR. NEWFMT.EQ.'Z4')THEN
	    IF(CUROFF.NE.0)THEN
	      IF(CURFMT.EQ.'C1' .OR. CURFMT.EQ.'Z2' .OR.
     *	         CURFMT.EQ.'I1')THEN
	        CUROFF=(CUROFF+1)/2
	        IF(BIAS.NE.0)BIAS=(BIAS+1)/2
	      ENDIF
	      IF(CURFMT.EQ.'I4' .OR. CURFMT.EQ.'Z8')THEN
	        CUROFF=CUROFF*2-1
	        IF(BIAS.NE.0)BIAS=BIAS*2-1
	      ENDIF
	    ENDIF
	    CURFMT=NEWFMT
	    GO TO 1000
C
	  ELSE IF(NEWFMT.EQ.'I4' .OR. NEWFMT.EQ.'Z8')THEN
	    IF(CUROFF.NE.0)THEN
	      IF(CURFMT.EQ.'C1' .OR. CURFMT.EQ.'Z2' .OR.
     *	         CURFMT.EQ.'I1')THEN
	        CUROFF=(CUROFF+3)/4
	        IF(BIAS.NE.0)BIAS=(BIAS+3)/4
	      ENDIF
	      IF(CURFMT.EQ.'I2' .OR. CURFMT.EQ.'Z4')THEN
	        CUROFF=(CUROFF+1)/2
	        IF(BIAS.NE.0)BIAS=(BIAS+1)/2
	      ENDIF
	    ENDIF
	    CURFMT=NEWFMT
	    GO TO 1000
C
	  ELSE
	    TYPE *,IAM(),'    BAD FORMAT SPECIFIED',BELL
	    GO TO 1000
	  ENDIF
	ENDIF
C
C Check for DSP=FULL or DSP=SHORT
C
	IF(C40INP(1:4).EQ.'DSP=')THEN
	  IF(C40INP(5:6).EQ.'FU')THEN
	    DSPFULL=.TRUE.
	    TYPE '(X,A)',CXHDR
	  ELSE IF(C40INP(5:6).EQ.'SH')THEN
	    DSPFULL=.FALSE.
	    TYPE '(X,A)',CXHDR(32:80)
	  ELSE
	    TYPE *,IAM(),'    Display can be either FULL or SHORT',BELL
	  ENDIF
	  GOTO 1000
	ENDIF
C
C Check for 'HELP'
C
	IF(C40INP(1:5).EQ.'HELP ')THEN
	  CALL PRTHLP
	  IF(DSPFULL)THEN
	    TYPE '(X,A)',CXHDR
	  ELSE
	    TYPE '(X,A)',CXHDR(32:80)
	  ENDIF
	  GO TO 1000
	ENDIF
C
C Be sure first character is filled in
C
	IF(C1INP(1).EQ.' ')THEN
	  TYPE *,IAM(),'INPUT MUST BE LEFT JUSTIFIED    ',BELL
	  GO TO 1000
	ENDIF
C
C Check for '=xxx'
C
	IF(C1INP(1).EQ.'=' .AND. INPLEN.EQ.2 .AND.
     *	   CURFMT.EQ.'C1')THEN
	  I1BUF(CUROFF)=C1INP(2)
	  GO TO 4000
	ENDIF
C
C
	IF(C1INP(1).EQ.'=' .AND. CURFMT(1:1).EQ.'Z')THEN
	  IF(CURFMT.EQ.'Z2' .AND. INPLEN.NE.1+2)GO TO 7000
	  IF(CURFMT.EQ.'Z4' .AND. INPLEN.NE.1+4)GO TO 7000
	  IF(CURFMT.EQ.'Z8' .AND. INPLEN.NE.1+8)GO TO 7000
C
	  VAL=0
	  DO 2600 K=2,INPLEN
	    X=ICHAR(C1INP(K))
	    IF(X.LT.48 .OR. X.GT.70 .OR.
     *	      (X.GT.57 .AND.X.LT.65))GO TO 7000
	    IF(X.GT.57)X=X-7
	    X=X-48
	    VAL=ISHFT(VAL,4) + X
2600	  CONTINUE
C
	  IF(CURFMT.EQ.'Z2')I1BUF(CUROFF)=CHAR(VAL)
	  IF(CURFMT.EQ.'Z4')I2BUF(CUROFF)=VAL
	  IF(CURFMT.EQ.'Z8')I4BUF(CUROFF)=VAL
	  GO TO 4000
	ENDIF
C
	IF(C1INP(1).EQ.'=' .AND.
     *	  (CURFMT.EQ.'I2' .OR. CURFMT.EQ.'I4' .OR.
     *	   CURFMT.EQ.'I1'))THEN
	  NEGFLG=0
	  IF(C1INP(2).EQ.'-' .AND. INPLEN.GT.2)NEGFLG=1
	  CALL ASCBIN(I4INP,NEGFLG+2,INPLEN-NEGFLG-1,VAL,ST)
	  IF(ST.NE.0)GO TO 7000
	  IF(CURFMT.EQ.'I1')THEN
	    IF(NEGFLG.EQ.0 .AND. VAL.GT.127)GO TO 7000
	    IF(NEGFLG.NE.0 .AND. VAL.GT.128)GO TO 7000
	  ENDIF
	  IF(CURFMT.EQ.'I2')THEN
	    IF(NEGFLG.EQ.0 .AND. VAL.GT.32767)GO TO 7000
	    IF(NEGFLG.NE.0 .AND. VAL.GT.32768)GO TO 7000
	  ENDIF
	  IF(NEGFLG.EQ.1)VAL=-VAL
	  IF(CURFMT.EQ.'I2')THEN
	    I2BUF(CUROFF)=VAL
	  ELSE IF(CURFMT.EQ.'I1')THEN
	    I1BUF(CUROFF)=CHAR(VAL)
	  ELSE
	    I4BUF(CUROFF)=VAL
	  ENDIF
	  GO TO 4000
	ENDIF
C
C All others come here. Either nnnn should be present (to use
C biased offset) or Annnn to indicate an absolute value of nnnn.
C
	IF(C1INP(1).EQ.'A')THEN
	  CALL ASCBIN(I4INP,2,INPLEN-1,VAL,ST)
	  IF(ST.NE.0)GO TO 7000
	ELSE
	  CALL ASCBIN(I4INP,1,INPLEN,VAL,ST)
	  IF(ST.NE.0)GO TO 7000
	  VAL=BIAS+VAL
	ENDIF
	IF(VAL.LT.1 .OR. VAL.GT.HIOFF)GO TO 7000
	CUROFF=VAL
	GO TO 1000
C
C
4000	CONTINUE
	CUROFF=MIN(CUROFF+1,HIOFF)
	GO TO 1000
C
C
7000	CONTINUE
	TYPE *,IAM(),'    INVALID ENTRY',BELL
	GO TO 1000
C
C
	END
