C  GXSRC:CRSRCV.FOR
C  
C  $Log:   GXAFIP:[GOLS]CRSRCV.FOV  $
C  
C     Rev 1.5   14 Feb 1997 19:44:14   WPW
C  Removed the the multiplication of TCMAXRLEN, to make it
C  consistent with UK. Per discussion with Mike Pindrik it
C  should be replaced by TCDATSIZ*4. As we do not have a time
C  to redesign the system we have to get back to the old value.
C  
C     Rev 1.4   07 Feb 1997 15:40:00   HXK
C  Changed check on MAXTCRLEN
C  
C     Rev 1.3   01 Feb 1997 13:45:26   HXK
C  Fix for message length limits between IPS/GOLS
C  
C     Rev 1.2   28 Jan 1997 19:27:54   RXK
C  Message numbers for Errlog changed
C  
C     Rev 1.1   05 Dec 1996 20:31:50   HXK
C  Updated for Finland IPS pre-release
C  
C     Rev 1.3   31 Mar 1995 12:08:26   DJO
C  Changed to fix a bug with the debugging feature.
C  
C     Rev 1.2   01 Sep 1994 17:09:48   MCM
C  SWAPPING BYTES IS NO LONGER NECESSARY FOR THE DEC LMS
C  
C     Rev 1.1   03 Jan 1994 20:04:22   SYSTEM
C  Applying PVCS header for automatic revision history
C  
C     Rev 1.0    21 Dec 1993 17:34:14   SYSTEM
C  Initial revision.
C
C
C
C V05 15-MAY-93 DSL added financial passthru         (FPT0001)
C V04 27-APR-93 TJR ADDED AGENT UPDATE PER DESIGN DOC CDH0001
C V03 11-Oct-92 ceb Removed DEBUG statements  (ph3-22)
C V02 18-AUG-92 NJA ADDED (CHECKWRITER)
C V01 18-NOV-91 KWP INITIAL RELEASE FOR VAX
C
C This subroutine processes transactions which have been placed
C on the Receive complete queue.  These include acknowledgements
C to transmission we have sent, and responses to our requests.
C
C Input parameters:
C
C     TBUF    Int*4   Buffer on receive queue.
C
C Output parameters:
C
C     None
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994,1997 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE CRSRCV(TBUF)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:CRSCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:QUECOM.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:PRMLOG.DEF'
C
	INTEGER*4   TBUF                !Transmit buffer number
	INTEGER*4   PBUF                !Procom buffer
	INTEGER*4   WRDLEN              !Word length of xfer
	INTEGER*4   IOLEN               !Byte length of xfer
	INTEGER*4   XRFNUM              !LOLITA Xrf #
	INTEGER*4   ST                  !Work variable
	INTEGER*4   XOFF                !Offset in PROCOM where LOL mess goes
	INTEGER*4   BLEN	        !Byte Length
	INTEGER*4   XMAX                !Maximum space left in PROCOM
	INTEGER*4   ROFF                !Record offset
	INTEGER*4   MESS(EDLEN)		!ERRLOG Message Buffer
	INTEGER*4   ILEN		!bytes to move
	INTEGER*4   BLEFT		!bytes left in current read buffer
C
C	INTERNAL BUFFER
C
	INTEGER*4   INTBUFFER(TCBUFSIZ)
	BYTE	    B_INTBUFFER(TCBUFSIZ*4)
	EQUIVALENCE (INTBUFFER,B_INTBUFFER)
C
	INTEGER*4   I4TEMP
	INTEGER*2   I2TEMP(2)
	BYTE	    I1TEMP(4)
	EQUIVALENCE (I4TEMP,I2TEMP,I1TEMP)
C
C IF DEBUG MODE ENABLED DUMP TRANSACTION TO CONSOLE.
C
	IF(P(XXDEBUG).EQ.0.AND.TCBUF(TCBUFSTS,TBUF).NE.TCGODWRT) 
     *      CALL PRTTCBUF(TBUF,B_TCBUFBEG,TCBUF(TCBUFLEN,TBUF),2)
	IF(TCP_DEBUG.NE.0) THEN
	  TYPE *,IAM(),'CRSRCV:  BUFFER      = ',TBUF
	  TYPE *,IAM(),'CRSRCV:  BUFF STATUS = ',TCBUF(TCBUFSTS,TBUF)
	ENDIF
C
C	CHECK THE BUFFER STATUS TO DETERMINE WHAT PROCESSING IS
C	REQUIRED BY CRSRCV.
C
	IF(TCBUF(TCBUFSTS,TBUF).EQ.TCGODRED) GOTO 1000
	IF(TCBUF(TCBUFSTS,TBUF).EQ.TCBADRED) GOTO 2000
	IF(TCBUF(TCBUFSTS,TBUF).EQ.TCDISRED) GOTO 3000
	IF(TCBUF(TCBUFSTS,TBUF).EQ.TCGODWRT) GOTO 4000
	IF(TCBUF(TCBUFSTS,TBUF).EQ.TCBADWRT) GOTO 5000
	IF(TCBUF(TCBUFSTS,TBUF).EQ.TCDISWRT) GOTO 6000
	IF(TCBUF(TCBUFSTS,TBUF).EQ.TCNOCWRT) GOTO 5000
C
C  ERROR HERE, BAD BUFFER STATUS FROM TCPASST, RELEASE BUFFER
C
	GOTO 10000
C
C
C	BUFFER STATUS = TCGODRED( GOOD READ, NO ERROR)
C
1000	CONTINUE
	IF(TCP_REDIGNORE.EQ.1) THEN
	  IF(TCP_DEBUG.NE.0) THEN
	    TYPE *,IAM(),'CRSRCV:  BUFFER IGNORED BECAUSE OF REDIGNORE ',TBUF
	  ENDIF
	  GOTO 10000   !IGNORE BUFFER
	ENDIF
C
	IOLEN   =TCBUF(TCBUFLEN,TBUF)	    !Length of I/O
C        TYPE *,' LENGTH = ',IOLEN
C
C
	ROFF = 0		!CURRENT OFFSET INTO TCBUF
C
1100	CONTINUE
	BLEFT = IOLEN - ROFF	!BYTES LEFT IN TCBUF
	IF(BLEFT.EQ.0) GOTO 10000
C
C	IF TCP_BUFFOFF IS 2 OR GREATER THEN THE LENGTH OF THE CURRENT
C	TRANSACTION IS KNOWN. GO AND DO A MOVE FROM TCBUF TO
C	INTBUFFER
C
	IF(TCP_BUFFOFF.GE.2) THEN
	  ILEN = TCP_BUFFLEN - TCP_BUFFOFF	!BYTES LEFT FOR CURRENT TRANS
	  IF(ILEN.GT.BLEFT) THEN    !NOT ENOUGH BYTES LEFT IN TCBUF
	    CALL LIB$MOVC3(BLEFT, B_TCBUF(B_TCBUFBEG+ROFF,TBUF),
     *			 B_INTBUFFER(TCP_BUFFOFF+1))
	    TCP_BUFFOFF = TCP_BUFFOFF + BLEFT
	    GOTO 10000	   !RELEASE CURRENT TCP BUFFER
	  ELSE			    !INTBUFFER IS FULL
	    CALL LIB$MOVC3(ILEN, B_TCBUF(B_TCBUFBEG+ROFF,TBUF),
     *			 B_INTBUFFER(TCP_BUFFOFF+1))
	    ROFF = ROFF + ILEN
	    BLEN = TCP_BUFFLEN
	    TCP_BUFFOFF = 0
	    TCP_BUFFLEN = 0
	  ENDIF
	ELSE
	  IF(TCP_BUFFOFF.EQ.0) THEN
	    B_INTBUFFER(1) = B_TCBUF(B_TCBUFBEG+ROFF+0,TBUF)
	    IF(BLEFT.GT.1) THEN
	      B_INTBUFFER(2) = B_TCBUF(B_TCBUFBEG+ROFF+1,TBUF)
	      ROFF=ROFF+2
	    ELSE
	      TCP_BUFFOFF=1
	      GOTO 10000
	    ENDIF
	  ELSE
	    B_INTBUFFER(2) = B_TCBUF(B_TCBUFBEG+ROFF+0,TBUF)
	    ROFF=ROFF+1
	  ENDIF
	  I4TEMP=0
	  I1TEMP(1)=B_INTBUFFER(1)
	  I1TEMP(2)=B_INTBUFFER(2)
	  TCP_BUFFLEN=I4TEMP		!Length of transaction in Bytes
	  TCP_BUFFOFF=2			!Reset buffer offset to byte 2
C
C	  IF THE OTHER SYSTEM SENDS A BAD LENGTH IN THE BUFFER THEN FORCE
C	  A DISCONNECT AND IGNORE ALL BUFFERS UNTIL RECONNECTION HAS BEEN
C	  ESTABLISHED
C
	  IF(TCP_BUFFLEN.LT.TCMINRLEN .OR. TCP_BUFFLEN.GT.TCMAXRLEN) THEN
	    TCP_REDIGNORE=1		!ignore all good reads until disconn
	    CALL TCPQUEUE(DISASST,ST)
	    IF(ST.NE.0) THEN
	      TYPE *,IAM(),'ERROR QUEUEING TCPASST:  ',ST
	    ENDIF
	    MESS(1)=CRS
	    MESS(2)=TEGEN
	    MESS(3)=36
	    MESS(4)=TCP_BUFFLEN
	    CALL QUEMES(MESS)
	    GOTO 10000			!IGNORE BUFFER
	  ENDIF
	  GOTO 1100
	ENDIF
C
C	FULL BUFFER, COME AND PROCESS IT!!!
C
	I4TEMP=0
	I1TEMP(1)=B_INTBUFFER(3)
	I1TEMP(2)=B_INTBUFFER(4)
C									 CDH0001
C	BRANCH TO ISUPROC IF THE MESSAGE IS UNSOLICITED	CLASS		 CDH0001
C									 CDH0001
	IF (I2TEMP(1).EQ.-1) THEN					!CDH0001
	  CALL ISUPROC(B_INTBUFFER,BLEN)				!CDH0001
	ELSE								!CDH0001
C
C	PROCESS SOLICITED CLASS MSGS					 CDH0001
C
	  PBUF=I4TEMP			!Procom Buffer #
C	  TYPE *,'CRSRCV**SLOT ID=',I4TEMP
C
	  I4TEMP=0
	  I1TEMP(1)=B_INTBUFFER(5)
	  I1TEMP(2)=B_INTBUFFER(6)
	  I1TEMP(3)=B_INTBUFFER(7)
	  I1TEMP(4)=B_INTBUFFER(8)
	  XRFNUM=I4TEMP			!Cross Reference #
C	  TYPE *,'CRSRCV**XRF NUM=',I4TEMP
C
C CHECK TO ENSURE THE TRANSACTION HAS NOT ALREADY TIMED OUT.
C IF SO, REPORT THE ERROR AND IGNORE.
C
	  CALL REMTIMER(XRFNUM,PBUF,ST)
	  IF (ST.LT.0) THEN
	    MESS(1)=CRS
	    MESS(2)=TEGEN
	    MESS(3)=32
	    MESS(4)=XRFNUM
	    MESS(5)=PBUF
	    CALL QUEMES(MESS)
	    GOTO 1100
	  ENDIF
C
C COPY MESSAGE FROM TCBUF TO PROCOM
C
	  CALL LIB$MOVC3(BLEN, B_INTBUFFER(1), BPRO(BINSTAB+1,PBUF))
C
C
	  HPRO(INPLEN,PBUF)=(BINSTAB+BLEN)-(BINPTAB)+1
C
C SET THE TRCODE TO THE APPROPRIATE VALUE.
C
	  IF((HPRO(TRCODE,PBUF).NE.TYPCWT) .AND.   !CHECKWRITER          CDH0001
	1  (HPRO(TRCODE,PBUF).NE.TYPSSI) .AND.	   !AGT UPDT ACK	 CDH0001
	1  (HPRO(TRCODE,PBUF).NE.TYPFPT)) THEN	   !FNCL PSTHRU	         FPT0001
	    HPRO(TRCODE,PBUF)=TYPCRS       !Send all others to INSOUT	 CDH0001
	  ENDIF
C
C QUEUE THE RESPONSE BACK TO DISPAT.
C
	  CALL ABL(PBUF,QUETAB(1,DIS),ST)
	ENDIF			    
C									 CDH0001
C	END OF SOLICITED CLASS MSG BRANCH				 CDH0001
C									 CDH0001
	GOTO 1100
C
C
C	BUFFER STATUS = TCBADRED( READ WITH ERROR)
C
2000	CONTINUE
	GOTO 10000
C
C
C	BUFFER STATUS = TCDISRED( READ WITH ERROR, FORCED DISCONNECT)
C
C	IGNORE CURRENT BUFFER
C
3000	CONTINUE
	TCP_BUFFOFF   = 0
	TCP_BUFFLEN   = 0
	TCP_REDIGNORE = 0	!ALL GOOD READS AFTER THIS WILL BE OKAY
	GOTO 10000
C
C
C	BUFFER STATUS = TCGODWRT( WRITE WITH NO ERRORS)
C
4000	CONTINUE
	GOTO 10000	    !RELEASE BUFFER
C
C
C	BUFFER STATUS
C
C     	      TCBADWRT( WRITE WITH ERROR)
C     	      TCDISWRT( WRITE WITH ERROR, FORCED DISCONNECT)
C     	      TCNOCWRT( COULDN'T SEND TO STRATUS AT ALL)
C	
C
5000	CONTINUE
	ROFF=0
	IOLEN   =TCBUF(TCBUFLEN,TBUF)	    !Length of I/O
C
5100	CONTINUE
C
	I4TEMP=0
	I1TEMP(1)=B_TCBUF(B_TCBUFBEG+ROFF+0,TBUF)
	I1TEMP(2)=B_TCBUF(B_TCBUFBEG+ROFF+1,TBUF)
	BLEN=I4TEMP			!Length of transaction in Bytes
C
	I4TEMP=0
	I1TEMP(1)=B_TCBUF(B_TCBUFBEG+ROFF+2,TBUF)
	I1TEMP(2)=B_TCBUF(B_TCBUFBEG+ROFF+3,TBUF)
	PBUF=I4TEMP			!Procom Buffer #
C
	I4TEMP=0
	I1TEMP(1)=B_TCBUF(B_TCBUFBEG+ROFF+4,TBUF)
	I1TEMP(2)=B_TCBUF(B_TCBUFBEG+ROFF+5,TBUF)
	I1TEMP(3)=B_TCBUF(B_TCBUFBEG+ROFF+6,TBUF)
	I1TEMP(4)=B_TCBUF(B_TCBUFBEG+ROFF+7,TBUF)
	XRFNUM=I4TEMP			!Cross Reference #
C
	IF(TCBUF(TCBUFSTS,TBUF).EQ.TCBADWRT .OR. 
     *	   TCBUF(TCBUFSTS,TBUF).EQ.TCDISWRT) THEN
	  MESS(1)=CRS
	  MESS(2)=TEGEN
	  MESS(3)=37
	  MESS(4)=XRFNUM
	  MESS(5)=PBUF
	  CALL QUEMES(MESS)
	ENDIF
C
C
C REMOVE FROM THE TIME OUT LIST. IF TRANSACTION IS NOT
C ON THE TIMEOUT QUEUE, BUFFER MUST HAVE ALREADY TIMED OUT.
C
	CALL REMTIMER(XRFNUM,PBUF,ST)
	IF(ST.LT.0) THEN
	  IF(TCP_DEBUG.NE.0) THEN
	    TYPE *,IAM(),'CRSRCV: TRANS NOT ON TIME QUE ST,XRF,PBUF= ',
     *			 ST,XRFNUM,PBUF
	  ENDIF
	  GOTO 5200
	ENDIF
C
C SET RESPONSE CODE AND SET THE TRCODE TO THE APPROPRIATE
C TYPE BASED ON THE INPUT REQUEST.
C
	I4TEMP=INCNS			    !COULD NOT SEND 
	BPRO(BINSTAB+13,PBUF) = I1TEMP(1)
	BPRO(BINSTAB+14,PBUF) = I1TEMP(2)
C	
C
C
C SET THE TRCODE TO THE APPROPRIATE VALUE.
C
	IF((HPRO(TRCODE,PBUF).NE.TYPCWT) .AND.	!CHECKWRITER 		 CDH0001
	1  (HPRO(TRCODE,PBUF).NE.TYPSSI) .AND.	!AGENT UPDATE		 CDH0001
	1  (HPRO(TRCODE,PBUF).NE.TYPFPT)) THEN  !FINANCIAL PASSTHRU      FPT0001
	    HPRO(TRCODE,PBUF)=TYPCRS         !Send all others to INSOUT	 CDH0001
	ENDIF
C
C QUEUE BACK TO DISPAT.
C
	CALL ABL(PBUF,QUETAB(1,DIS),ST)
C
C
5200	CONTINUE
	ROFF=ROFF+BLEN			    !UPDATE POINTER INTO TCBUF
C
C CHECK FOR ANOTHER RECORD IN THE TCBUF
C
	I4TEMP=0
	I1TEMP(1)=B_TCBUF(B_TCBUFBEG+ROFF+0,TBUF)
	I1TEMP(2)=B_TCBUF(B_TCBUFBEG+ROFF+1,TBUF)
	BLEN=I4TEMP	    !Length of next transaction in Bytes
	IF(BLEN.GT.0) GOTO 5100
	GOTO 10000
C
C
C	BUFFER STATUS = TCDISWRT( WRITE WITH ERROR, FORCED DISCONNECT)
C
C	IGNORE CURRENT BUFFER
C
6000	CONTINUE
	TCP_BUFFOFF   = 0
	TCP_BUFFLEN   = 0
	TCP_REDIGNORE = 0	!ALL GOOD READS AFTER THIS WILL BE OKAY
	GOTO 5000
C
C
C PUT THE BUFFER BACK ONTO THE FREE LIST.
C
10000	CONTINUE
	CALL ABL(TBUF,FREQUE,ST)
C
	RETURN
	END
