C SUBROUTINE RVALUPD
C
C V13 11-DEC-2014 SCML Fix for reprocessing new bank validations
c V12 12-MAR-2010 RXK TCLM commented out 
C V11 19-JUN-2000 OXK Cleanup w/ WARNINGS=ALL
C V10 01-OCT-1999 UXN Cashing terminal field updated for BANK winners.
C V09 30-JAN-1999 UXN Build exchange ticket reading TCF insted of TMF to 
C                     eliminate TCF reprocessing errors during recovery.
C V08 20-DEC-1994 HXK Use OFFLOG RLOG to read TMF
C V07 28-SEP-1993 GXA Changed condition for exchange ticket generation to use 
C                     trans. val status
C V06 19-SEP-1993 HXK PREVENT CHECK OF DAYHDR AGAINST KICKER GAME IF KICKER 
C                     GAME IS NOT SET FOR THE PARTICULAR GAME
C V05 15-SEP-1993 HXK Fix for Viking Winsel
C V04 31-AUG-1993 GXA Released for Finland Dec Conversion / Oddset.
C                     Add Exchange Tickets to carryover File
C V03 30-JAN-1999 DAB Initial Release
C                     Based on Netherlands Bible, 12/92, and Comm 1/93 update
C                     DEC Baseline
C V02 12-NOV-1991 MTK INITAL RELEASE FOR NETHERLANDS
C V01 01-AUG-1990 XXX RELEASED FOR VAX
C
C
C SUBROUTINE TO REAPPLY VALIDATIONS FOR REPROCESSING.
C
C CALLING SEQUENCE:
C      CALL RVALUPD(TRABUF,STATUS)
C
C INPUT
C       TRABUF - INTERNAL TRANSACTION BUFFER
C OUTPUT
C       STATUS - 0 NO ERROR
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 2000 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW/EXT
	SUBROUTINE RVALUPD(TRABUF,STATUS)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
        INCLUDE 'INCLIB:LTOCOM.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:DESVAL.DEF'
	INCLUDE 'INCLIB:VALFIL.DEF'
	INCLUDE 'INCLIB:PRMLOG.DEF'
	INCLUDE 'INCLIB:PRMHSH.DEF'
C
	INTEGER*4 LBUF(LREC*3),WRKBUF(TRALEN), ST, STATUS, FILE
        INTEGER*4 GAM,KGAM,DRAW,KDRAW
	INTEGER*4 GTYP,GIND,OFFDRW

	INTEGER*4 FDB(7)

        LOGICAL   FIRST/.TRUE./
C
C
	STATUS=0
        IF(FIRST) THEN
           FIRST  = .FALSE.
           CALL OPENW(26,SFNAMES(1,PTMF),4,0,0,ST)
           IF(ST.NE.0) CALL FILERR(SFNAMES(1,PTMF),1,ST,0)
	   CALL IOINIT(FDB,26,DBLOCK/64*256)
        ENDIF
C
C CHECK IF TICKET WAS CASHED FROM THE TMF
C
	IF(TRABUF(TVCDC).EQ.DAYCDC) GOTO 3000
C
C TRY TO READ RECORD FROM THE VALIDATION FILE
C
	CALL IREAD(TRABUF(TVCDC),V4BUF,VLF,ST)
	IF(ST.NE.0) GOTO 1000
	CALL LOGVAL(VALREC,V4BUF)
	IF(TRABUF(TVSTS).EQ.VCASH.OR.TRABUF(TVSTS).EQ.VCASHX) THEN
	  IF(VALREC(VCCDC).EQ.DAYCDC) THEN
	    IF(TRABUF(TVSTS).EQ.VCASH) RETURN
	    IF(TRABUF(TVSTS).EQ.VCASHX) GOTO 1000
	  ENDIF
	  VALREC(VCCDC)=DAYCDC
	  VALREC(VCTER)=TRABUF(TTER)
	  VALREC(VCSER)=TRABUF(TSER)
	  VALREC(VSTAT )=TRABUF(TVSTS)
	ENDIF
C
C NEW BANK VALIDATION !V13
C
	IF(TRABUF(TVSTS).EQ.VBANK) THEN
	  IF(VALREC(VCCDC).EQ.DAYCDC) RETURN
	  VALREC(VCCDC)=DAYCDC
	  VALREC(VCTER)=TRABUF(TTER)
	  VALREC(VCSER)=TRABUF(TSER)
	  VALREC(VSTAT )=TRABUF(TVSTS)
	ENDIF
C
	IF(TRABUF(TVSTS).EQ.VCLAM.OR.TRABUF(TVSTS).EQ.VCLAMX) THEN
	  IF(VALREC(VLCDC).EQ.DAYCDC) THEN
	    IF(TRABUF(TVSTS).EQ.VCLAM) RETURN
	    IF(TRABUF(TVSTS).EQ.VCLAMX) GOTO 1000
	  ENDIF
	  VALREC(VLCDC)=DAYCDC
	  VALREC(VLTER)=TRABUF(TTER)
	  VALREC(VLSER)=TRABUF(TSER)
	  VALREC(VSTAT )=TRABUF(TVSTS)
	ENDIF
C
C BANK VALIDATIONS ARE NOT REAL VALIDATIONS. THEY WILL BE SET TO CASH BY
C HBNKWIN, NOT BY VALPRO.
C
	IF(TRABUF(TVSTS).EQ.VSBNK.OR.TRABUF(TVSTS).EQ.VSBNKM) THEN
	   IF(VALREC(VBNKID).NE.0.AND.VALREC(VBNKNUM).NE.0) THEN
	      IF(TRABUF(TVSTS).EQ.VSBNK) RETURN
	      IF(TRABUF(TVSTS).EQ.VSBNKM) GOTO 1000
	   ENDIF
	   VALREC(VBNKID)  = TRABUF(TVBNKID)
	   VALREC(VBNKNUM) = TRABUF(TVBNKNUM)
	   VALREC(VCTER)   = TRABUF(TTER)
	ENDIF
C
C WRITE RECORD BACK TO VLF
C
	CALL VALLOG(VALREC,V4BUF)
	CALL IWRITE(V4BUF,VLF,ST)
	IF(ST.NE.0) THEN
	  CALL VALERR(ST,VLF,TRABUF(TSER))
	  STATUS=ST
	  RETURN
	ENDIF
C
C If the ticket expires either today or in the future, there should be a
C carryover record for it.
C
	IF(TRABUF(TVSTS).NE.VCASHX.AND.TRABUF(TVSTS).NE.VCLAMX.AND.
     *     TRABUF(TVSTS).NE.VSBNKM) RETURN
C
C UPDATE CARRYOVER FILE
C
1000	CONTINUE
	FILE=TCF
	IF(TRABUF(TGAMTYP).EQ.TNBR) FILE=DCF
	CALL IREAD(TRABUF(TVCDC),LBUF,FILE,ST)
	IF(ST.NE.0) THEN
	  CALL VALERR(ST,FILE,TRABUF(TSER))
	  STATUS=ST
	  RETURN
	ENDIF
C
C
	CALL LOGTRA(WRKBUF,LBUF)
	IF(WRKBUF(TSTAT).EQ.XCHD) RETURN
C
	IF(TRABUF(TVSTS).EQ.VSBNKM) THEN
	   WRKBUF(TWBNKID) = TRABUF(TVBNKID)
	   WRKBUF(TWBNKNM) = TRABUF(TVBNKNUM)
	ELSE
	   IF(TRABUF(TTYP).EQ.TVAL.OR.TRABUF(TTYP).EQ.TREF) THEN	
	      IF(WRKBUF(TSTAT).EQ.CASH .OR.
     *	         WRKBUF(TSTAT).EQ.XCSH) RETURN
C
              IF(WRKBUF(TSTAT).EQ.GOOD .OR.			
     *           WRKBUF(TSTAT).EQ.CLAM) WRKBUF(TSTAT)=CASH	
	      IF(WRKBUF(TSTAT).EQ.EXCH .OR.			
     *           WRKBUF(TSTAT).EQ.XCLM) WRKBUF(TSTAT)=XCSH	
	      IF(TRABUF(TFIL).NE.LATE ) WRKBUF(TSTAT)=XCHD	
	   ENDIF
C
C	   IF(TRABUF(TTYP).EQ.TCLM) THEN			
C              IF(WRKBUF(TSTAT).EQ.CLAM .OR.
C     *	         WRKBUF(TSTAT).EQ.XCLM) RETURN
C
C              IF(WRKBUF(TSTAT).EQ.GOOD) WRKBUF(TSTAT)=CLAM
C              IF(WRKBUF(TSTAT).EQ.EXCH) WRKBUF(TSTAT)=XCLM
C              IF(TRABUF(TFIL).NE.LATE ) WRKBUF(TSTAT)=XCHD
C	   ENDIF
	   WRKBUF(TWCTER) = TRABUF(TTER)			
	   WRKBUF(TWCSER) = TRABUF(TSER)			
	   WRKBUF(TWVSTS) = TRABUF(TVSTS)			
	ENDIF
C
	CALL TRALOG(WRKBUF,LBUF)
	CALL IWRITE(LBUF,FILE,ST)
	IF(ST.NE.0) CALL VALERR(STATUS,FILE,TRABUF(TSER))
C
C BUILD EXCHANGE TICKET AND 
C WRITE (ADD) IT TO CARRYOVER FILE
C
	IF(TRABUF(TVEXC).GT.0) THEN
	   KGAM  = VALREC(VKGME)
	   GAM   = VALREC(VGAM)
	   DRAW  = DAYHDR(GAM)
	   KDRAW = 0
	   IF(KGAM.GE.1.AND.KGAM.LE.MAXGAM) KDRAW = DAYHDR(KGAM)
C
C CHECK FOR POSTPONED DRAWS FOR THIS GAME BEFORE WINSEL
C
	   GTYP = GNTTAB(GAMTYP,GAM)
	   GIND = GNTTAB(GAMIDX,GAM)
	   IF (GTYP.EQ.TLTO.AND.GIND.GT.0) THEN
              OFFDRW = LTODAT(1,GIND) - LTOESD(GIND)
              IF(OFFDRW.GT.0 .AND. DAYCDC.LE.LTOBSD(GIND)+OFFDRW-1) DRAW = DRAW - 1
	   ENDIF

           CALL BUILDX(WRKBUF,TRABUF(TVEXC),DRAW,KDRAW,EARLY)

           CALL TRALOG(WRKBUF,LBUF)
	   CALL IWRITE(LBUF,FILE,ST)
	   IF(ST.NE.0) CALL VALERR(STATUS,FILE,WRKBUF(TSER))
	ENDIF
C
	RETURN
C
C TRY TO CASH TICKET FROM TM FILE
C
3000	CONTINUE
	CALL RLOG(TRABUF(TVSER),LBUF,VAL,ST)
	IF(ST.NE.0) THEN
	  STATUS=ST+7000
	  RETURN
	ENDIF
        CALL LOGTRA(WRKBUF,LBUF)
C
	IF(TRABUF(TTYP).EQ.TVAL.OR.TRABUF(TTYP).EQ.TREF) THEN	
	  IF(WRKBUF(TSTAT).EQ.CASH .OR.
     *	     WRKBUF(TSTAT).EQ.XCSH) RETURN
C
          IF(WRKBUF(TSTAT).EQ.GOOD .OR.			
     *       WRKBUF(TSTAT).EQ.CLAM) WRKBUF(TSTAT)=CASH	
	  IF(WRKBUF(TSTAT).EQ.EXCH .OR.			
     *       WRKBUF(TSTAT).EQ.XCLM) WRKBUF(TSTAT)=XCSH	
	ENDIF
C
C	IF(TRABUF(TTYP).EQ.TCLM) THEN			
C          IF(WRKBUF(TSTAT).EQ.CLAM .OR.
C     *	     WRKBUF(TSTAT).EQ.XCLM) RETURN
C
C          IF(WRKBUF(TSTAT).EQ.GOOD) WRKBUF(TSTAT)=CLAM
C          IF(WRKBUF(TSTAT).EQ.EXCH) WRKBUF(TSTAT)=XCLM
C	ENDIF
	WRKBUF(TWCTER) = TRABUF(TTER)			
	WRKBUF(TWCSER) = TRABUF(TSER)			
	WRKBUF(TWVSTS) = TRABUF(TVSTS)			
C
        CALL TRALOG(WRKBUF,LBUF)
	CALL WLOG(TRABUF(TVSER),LBUF,VAL)
	RETURN
	END
