C  GXSRC:ALLDLL.FOR
C  
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFIP:[GOLS]ALLDLL.FOV                                   $
C  $Date::   05 Feb 1997 17:28:46                                         $
C  $Revision::   1.2                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C V25 27-JAN-00 KW  Increase the length of segment zero for Altura terminal
C
C
C X2X Upgrade: 21-FEB-96 wsm Added default news/tv message in BLDNWS,
C                            build BLDNWS(TVNEWS) for Finland.
C
C V08 13-NOV-97 UXN SNIF_AND_WRKSET call added.
C V07 01-SEP-95 DAS INTERGRATED LEIPZIG BACKGROUND LOAD
C V06 22-NOV-95 WJK INITIALIZE UNINITIALIZE DATA FOR ALPHA
C V05 09-NOV-95 WJK USE SYSTEM FLAG TO DETERMINE SCF.FIL PATH
C V04 13-SEP-95 SCD MODIFIED TO READ ROM REV AND FILE NAMES FROM A FILE
C                   INSTEAD OF RELYING ON DATA STATEMENTS IN PRMDLL.DEF
C V03 01-FEB-92 PJS HANDLE GVT (64180) DLLs & CLEANED UP..
C V02 08-MAY-91 TKO CHANGED NAME OF 'DELETE' SUBROUTINE
C V01 01-AUG-90 XXX RELEASED FOR VAX
C V00 30-OCT-89 LOU MODIFIED FOR INITIAL RELEASE FOR FINLAND
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C THIS PROGRAM READS BINARY FILES AND PLACES THEM INTO MSGCOM.
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C FORMAT: 68000 SEGHEAD -> BYTES 1-70 (ALL FLEX FILES)
C
C	BYTE(S)		LEN	DESCRIPTION
C	  1- 16		16	FILE ID STRING
C	 17- 18		 2	CRC-16 OF THE DATA IN THE FILE
C	 19- 22		 4	LENGTH OF DATA IN BYTES
C	 23- 26		 4	STARTING ADDRESS OF DATA
C	 27- 52		26	ASCTIME() STRING
C	 53- 54		 2	NUMBER OF BLOCKS
C	 55- 56		 2	BLOCK SIZE
C	 57- 58		 2	NUMBER OF SEGMENTS
C	 59- 60		 2	SEGMENT SIZE
C	 61- 64		 4	TASK NAME
C	 65- 68		 4	LENGTH OF DOWNLOAD DATA
C	 69- 69		 1	MAJOR REVISION LEVEL OF THIS LOAD
C	 70- 70		 1	MINOR REVISION LEVEL OF THIS LOAD
C        71-126		56	COPYRIGHT NOTICE (MCP ONLY)
C
C FORMAT: 68000 SEGZERO -> BYTES 1-18 (MCP, MASTER CONTROL PROGRAM)
C	BYTE(S)		LEN	DESCRIPTION
C         1-  1          1      CONTROL/SEQUENCE
C         2-  2          1      TYPE/SUBTYPE
C         3-  6          4      ROM ID
C         7-  8          2      SEGMENT NUMBER (0)
C         9- 10          2      NUMBER OF SEGMENTS
C        11- 12          2      SEGMENT SIZE
C
C FORMAT: 68000 APPLICATION REVISIONS CONTROL LOAD
C	BYTE(S)         LEN     DESCRIPTION
C	  1-  1          1	CONTROL/SEQUENCE (10 HEX)
C	  2-  2		 1	CONTROL/SEQUENCE (58 HEX)
C	  3-  4		 2	CRC-16
C	  5-  5		 1	TERMINAL ID NO
C	  6-  6		 1	NO OF APPLICATION VERSIONS
C	  7-  8		 2	VERSION OF THE CURRENT ACTIVE APPLICATION
C	  9- 10		 2	OTHER INACTIVE APP RESIDENT IN THE TERMINAL
C	 11- 12		 2	OTHER INACTIVE APP ...
C 
C FORMAT: 68000 SEGZERO -> BYTES 1-34 (FLEX APPLICATION FILES)
C	BYTE(S)		LEN	DESCRIPTION
C         1-  1		 1      CONTROL/SEQUENCE
C	  2-  2		 1	TYPE/SUBTYPE
C         3-  3		 1	LOAD ID NUMBER
C	  4-  4		 1	LOAD ACCEPTANCE BITMASK (LAB)
C	  5-  6		 2	SEGMENT NUMBER (0)
C	  7-  8		 2	NUMBER OF SEGMENTS
C	  9- 10		 2	CRC-16 OF THE DATA IN THE FILE
C	 11- 13		 3	LOAD MODULE LEN IN BYTES (HIGH-BYTE/LOW-BYTE)
C	 14- 14		 1	PAGES OF ADDITIONAL NON-DOWNLOADED SPACE TO
C				ALLOCATE FOR MODULE'S UNINITIALIZED DATA AREA
C	 15- 15		 1	NOT USED
C	 16- 16		 1	NOT USED
C	 17- 32		16	APPLICATION DEFINED ADDITIONAL DATA
C	 33- 33		 1	MAJOR REVISION LEVEL OF THIS LOAD
C	 34- 34		 1	MINOR REVISION LEVEL OF THIS LOAD
C
C FORMAT: 68000 SEGDATA -> BYTES 1-12 (MCP, MASTER CONTROL PROGRAM)
C	BYTE(S)		LEN	DESCRIPTION
C         1-  1          1      CONTROL/SEQUENCE
C         2-  2          1      TYPE/SUBTYPE
C         3-  6          4      ROM ID
C         7-  8          2      SEGMENT NUMBER (0)
C         9- 10          2      NUMBER OF SEGMENTS
C        11- 12          2      SEGMENT SIZE
C        13- 13          1      PROGRAM TYPE
C        14- 14          1      PROGRAM REVISION
C        15- 18          4      LOAD MODULE LEN IN BYTES (HIGH-BYTE/LOW-BYTE)
C
C FORMAT: 68000 SEGDATA -> BYTES 1-20 (FLEX APPLICATION FILES)
C	BYTE(S)		LEN	DESCRIPTION
C         1-  1		 1	CONTROL/SEQUENCE
C	  2-  2		 1	TYPE/SUBTYPE
C         3-  3		 1	LOAD ID NUMBER
C	  4-  4		 1	LOAD ACCEPTANCE BITMASK (LAB)
C	  5-  6		 2	SEGMENT NUMBER
C	  7-  8		 2	NUMBER OF SEGMENTS
C	  9- 10		 2	SIZE OF THIS SEGMENT IN BYTES
C	 11- 13		 3	LOAD MODULE LEN IN BYTES (HIGH-BYTE/LOW-BYTE)
C	 14- 14		 1	PAGES OF ADDITIONAL NON-DOWNLOADED SPACE TO
C				ALLOCATE FOR MODULE'S UNINITIALIZED DATA AREA
C	 15- 15		 1	MAJOR REVISION OF LOAD
C	 16- 16		 1	MINOR REVISION OF LOAD
C	 17- 19		 3	BYTE OFFSET (FROM BEGINNING OF LOAD) OF DATA
C	 20- 20		 1	RESERVED
C	 21-???		 N	N BYTES OF DATA
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C FORMAT: 64180 SEGHEAD -> BYTES 1-130 (ALL GVT APPLICATION FILES)
C	BYTE(S)		LEN	DESCRIPTION
C	  1- 16		16	FILE ID STRING REVISION
C	 17- 72		56	COPYRIGHT NOTICE
C	 73- 74		 2	CRC-16 OF THE DATA IN THE FILE
C	 75- 78		 4	LENGTH OF DATA IN BYTES
C	 79- 80		 2	LOAD EXECUTABLE ADDRESS
C	 81-106		26	ASCTIME() STRING
C	107-108		 2	NUMBER OF BLOCKS
C	109-110		 2	BLOCK SIZE
C	111-112		 2	NUMBER OF SEGMENTS
C	113-114		 2	SIZE OF SEGMENT 0
C	115-116		 2	LENGTH OF DOWNLOAD DATA
C	117-124		 8	TERMINAL NAME
C	125-126		 2	ROM ID (NOT FLIPPED)
C	127-128		 2	PROGRAM TYPE/REV FOR FIRMWARE OR LOAD REV
C	129-130		 2	TYPE OF LOAD (!0=OLD FORMAT)
C
C FORMAT: 64180 SEGZERO -> BYTES 1-12 (GVT SOFTLOADER FILES, NO HEADER)
C	BYTE(S)		LEN	DESCRIPTION
C	  1-  1		 1	CONTROL/SEQUENCE
C	  2-  2		 1	TYPE/SUBTYPE
C	  3-  4		 2	ROM-ID (FLIPPED)
C	  5-  5		 1	SEGMENT NUMBER (0)
C	  6-  6		 1	NUMBER OF SEGMENTS
C	  7-  8		 2	PROGRAM ID
C	  9- 10		 2	NUMBER OF SEGMENTS
C	 11- 12		 2	EXECUTABLE ADDRESS
C
C FORMAT: 64180 SEGZERO -> BYTES 1-20 (GVT APPLICATION FILES)
C	BYTE(S)		LEN	DESCRIPTION
C	  1-  1		 1	CONTROL/SEQUENCE
C	  2-  2		 1	TYPE/SUBTYPE
C	  3-  4		 2	ROM-ID (FLIPPED)
C	  5-  6		 2      SEGMENT NUMBER (0)
C	  7-  8		 2	NUMBER OF SEGMENTS
C	  9- 10		 2	BBR VALUE
C	 11- 12		 2	EXECUTABLE ADDRESS
C	 13- 14		 2	CRC-16 OF THE DATA IN THE FILE
C	 15- 18		 4	LOAD LENGTH IN BYTES (NOT ROUNDED)
C	 19- 19		 1	MAJOR REVISION LEVEL OF THIS LOAD
C	 20- 20		 1	MINOR REVISION LEVEL OF THIS LOAD
C
C FORMAT: 64180 SEGDATA -> BYTES 1- 7 (GVT SOFTLOADER FILES)
C	BYTE(S)		LEN	DESCRIPTION
C	  1-  1		 1	CONTROL/SEQUENCE
C	  2-  2		 1	TYPE/SUBTYPE
C	  3-  4		 2	ROM-ID (FLIPPED)
C	  5-  5		 1	SEGMENT NUMBER
C         6-  7          2      SEGMENT ADDRESS (LOW-BYTE/HIGH-BYTE)
C         8-???		 N	N BYTES OF DATA
C
C FORMAT: 64180 SEGDATA -> BYTES 1-12 (GVT APPLICATION FILES)
C	BYTE(S)		LEN	DESCRIPTION
C	  1-  1		 1	CONTROL/SEQUENCE
C	  2-  2		 1	TYPE/SUBTYPE
C	  3-  4		 2	ROM-ID (FLIPPED)
C	  5-  6		 2      SEGMENT NUMBER
C	  7-  8		 2	NUMBER OF SEGMENTS
C	  9- 10		 2	BBR VALUE
C	 11- 12		 2	ABSOLUTE ADDRESS
C	 13-???		 N	N BYTES OF DATA
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C NOTE: THE FIRST RECORD OF ALL THE FILES (EXCEPT THE GVT SOFTLOADER) CONTAINS
C HEADER INFORMATION. THE NEXT RECORD CONTAINS SEGZERO AND THE REMAINING
C RECORDS CONTAIN DATA SEGMENTS.
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	PROGRAM ALLDLL
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
        INCLUDE 'INCLIB:PRMDLL.DEF'
C	INCLUDE 'INCLIB:CONCOM.DEF'
C       

C
	INTEGER*4	ALLBYTES,
     *			ALLSEG,
     *			APPBYT(APPISIZ),
     *			CHKSM16,
     *			FCLTAB(5000),
     *			FILNAMES(2),
     *			GVTBYT(GVTISIZ),
     *			I, J,
     *			RECORD_INDEX
	INTEGER*4	LENSEG0,
     *			LODLEN,
     *			LODNUM,
     *			MCPBYT(MCPISIZ),
     *			MEMORY(512),
     *			MESSAG,
     *			MODNAM,
     *			MODREV,
     *			MSEG0,
     *			MYSIZE,
     *			NEWLOADS
	INTEGER*4	NEXTADDR,
     *			NUMSEG,
     *			OFF,
     *			PTR,
     *			RECLEN,
     *			REVNUM,
     *			REVNUM1,
     *			SEGADR,
     *			SEGNUM,
     *			SFTBYT(SFTISIZ),
     *			ACLBYT(ACLISIZ),
     *			ST,
     *			SEGMENT_COUNTER,
     *			TRAIL,
     *                  TOTAPP,
     *                  C_CHKSM16,
     *                  U_ALLSEG,
     *                  C_ALLSEG
C
	INTEGER*4	FCL_OFFSET,FCL_NAME
	INTEGER*4	CURRENT_APPLICATION
	INTEGER*4	NEXT_APPLICATION
	INTEGER*4	APPLICATION_TYPE, STATUS
	INTEGER*4	LOAD_NO, FILE_INDEX
	INTEGER*4	NUMFCL				      !NO OF VALID FCLs
	INTEGER*4	ROMID, TID, TMPREV
	INTEGER*4	FCL_REV
	INTEGER*4	I4
	INTEGER*4	START_DATA
	INTEGER*4	TMP_ROMID
	INTEGER*4	DLLFIL(2,MAXLOADS,MAXAPP)	      !FILE NAMES
	INTEGER*4       NLOADS,
     *                  U_FIRST,
     *                  C_FIRST
C
	INTEGER*2	DLLATR(MAXLOADS, MAXDLLTAB,MAXAPP)    !FILE ATRIBUTES
	INTEGER*2	DOUBLE_BINFILE, I2TEMP
	INTEGER*2	I2(2)
C
	BYTE	        I1ACLBYT(ACLISIZ*4)
	BYTE		I1(4)
	BYTE		I1FCLTAB(2000)

C
	LOGICAL		ACL_FORMAT	      !USE NEW ACL FORMAT
	LOGICAL		ACL_PRESENT
C					
	LOGICAL		EOF,
     *			FCL,
     *			GVT,
     *			MCP,
     *			SFT,
     *                  APP,
     *			NEW,
     *                  DBLBIN,
     *                  FCLDTA_FLAG,
     *			ACL
C
	CHARACTER*512	CRECBUF
C
	CHARACTER*(APPCSIZ) CAPPBYT	! BUFF USED WHEN READING APP LOAD
	CHARACTER*(GVTCSIZ) CGVTBYT	! BUFF USED WHEN READING GVT APP LOAD
	CHARACTER*(MCPCSIZ) CMCPBYT	! BUFF USED WHEN READING MCP LOAD
	CHARACTER*(SFTCSIZ) CSFTBYT	! BUFF USED WHEN READING GVT SFTLDR
	CHARACTER*(ACLCSIZ) CACLBYT	! BUFF USED WHEN READING ACL LOAD
C
        INTEGER*4       AUX_STATUS

C       Error status values
        INTEGER*4       OPEN_ERROR              !file open error
        PARAMETER      (OPEN_ERROR = 1)
        INTEGER*4       INV_BLOCK_TYPE          !invalid block type error
        PARAMETER      (INV_BLOCK_TYPE = 2)
        INTEGER*4       MAX_MCP_REC_EXCEEDED    !number of records exceeds
        PARAMETER      (MAX_MCP_REC_EXCEEDED = 3)!MAXMCP or MAXFCL error
        INTEGER*4       MAX_SFT_REC_EXCEEDED    !number of records exceeds
        PARAMETER      (MAX_SFT_REC_EXCEEDED = 4)!MAXSFT or MAXGVT error
C
	EQUIVALENCE (I1,I2,I4)
	EQUIVALENCE (I1FCLTAB,FCLTAB)
	EQUIVALENCE (CAPPBYT,  APPBYT(1))
	EQUIVALENCE (CGVTBYT,  GVTBYT(1))
	EQUIVALENCE (CMCPBYT,  MCPBYT(1))
	EQUIVALENCE (CSFTBYT,  SFTBYT(1))
	EQUIVALENCE (CACLBYT,  ACLBYT(1), I1ACLBYT)
C
	DATA DOUBLE_BINFILE/'2B'/
C
	COMMON /ALLDLLCOM/ DLLFIL,DLLATR
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
	CALL COPYRITE
	CALL SNIF_AND_WRKSET
C
        CALL READ_ROM_REV (STATUS,AUX_STATUS)
        IF (STATUS .NE. 0) THEN
          IF (STATUS .EQ. OPEN_ERROR) THEN
           TYPE *,' ROM REV file error - VMS error code ',AUX_STATUS
          ELSEIF (STATUS .EQ. INV_BLOCK_TYPE) THEN
           TYPE *,' ROM REV file contains an invalid block type'
          ELSEIF (STATUS .EQ. MAX_MCP_REC_EXCEEDED) THEN
           TYPE *,' Record count in ROM REV file exceeds MCP '
     *              ,'or FCL max ', AUX_STATUS
          ELSEIF (STATUS .EQ. MAX_SFT_REC_EXCEEDED) THEN
           TYPE *,' Record count in ROM REV file exceeds SFT '
     *           ,'or GVT max ', AUX_STATUS
          ENDIF                               !on error status type check
          CALL GSTOP(GEXIT_FATAL)
        ENDIF                                   !on error status check
C
C       INITIALIZE THE ATRIBUTES AND FILE NAMES TABLES
C
	CALL FASTSET(0,DLLFIL,2*MAXLOADS*MAXAPP)
	CALL FASTSET(0,DLLATR,MAXLOADS*MAXDLLTAB*MAXAPP/2)
C
C	READ THE SMF INTO MEMORY
C
	CALL LOADSMF(3)

C
C       INITIALIZE MESSAGE COMMON
C
	DO 1000 J = 1, MSGS				! CLEAR ALL MESSAGES
	  I4MSGTAB(SEGLEN, J) = 0				! SET LENGTHS TO ZERO
	  I4MSGTAB(MSGLNK, J) = 0				! CLEAR LINKS
1000	CONTINUE
	I4MSGTAB(MFRLNK, MSGCTL) = MSGS + 1		! FIRST FREE SEGMENT
C
	DO 1100 J = MSGS + 1, MSGSIZ - 2		! INIT FREE LIST
	  I4MSGTAB(MSGLNK, J) = J + 1			! LINK TO NEXT
1100    CONTINUE
	I4MSGTAB(MSGLNK, MSGCTL-1) = 0			! NO LINK,END OF COMMON 
	I4MSGTAB(MFRCNT, MSGCTL) = MSGCTL - MSGS - 1	! NUMBER OF OVERFLOWS.

C
C       INITIALIZE VARIABLES
C
	NEWLOADS = 0
	CURRENT_APPLICATION=0
	ACL_PRESENT=.FALSE.
	NEXTADDR = DLLBEG

C
C	PRESET THE GVT SOFT AND  GVT LOADS
C       NOTE THAT THESE ARE SET IN PREDEFINED AREAS
C       OF THE DLL TABLE
C
	DO 1200 I = 1, ACTSFT
	  DLLFIL(1,1,I + SFT_APP_NO-1) = SFTNAM(I)
 	  DLLFIL(2,1,I + SFT_APP_NO-1) = 0
	  DLLATR(1, APPTYPE, I + SFT_APP_NO-1) = SFT_TYPE
1200  	CONTINUE
C
	DO 1300 I = 1, ACTGVT
          DLLFIL(1,1,I + GVT_APP_NO-1) = GVTNAM(I)
          DLLFIL(2,2,I + GVT_APP_NO-1) = 0
          DLLATR(1, APPTYPE, I + GVT_APP_NO-1) = GVT_TYPE
1300	CONTINUE
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C	MAIN LOOP TO READ NEXT BIN FILE
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
1600    CONTINUE				!READ NEXT FILE AND PROCESS
C
C	GET NEXT FILE AND APPLICATION NO TO PROCESS
C           LODNUM: LOAD NUMBER 
C           CURRENT_APPLICATION: 
C           APPLICATION_TYPE: TYPE OF LOAD (I.E. MCP, FCL, APPLICATION)
C           STATUS: 0 - SUCCESS, 1 - END OF PROCESSING
C
	CALL DLLFILENUM(LODNUM,CURRENT_APPLICATION,APPLICATION_TYPE,STATUS)
        IF(STATUS.EQ.-1) CALL GSTOP(GEXIT_FATAL)
C
C	IF ALL LOADS HAVE BEEN READ AND PROCESSED 	
C       UPDATE THE SMF FILE
C
	IF (STATUS.EQ.1) THEN
           CALL UPDATE_SMF(NEWLOADS,NEXTADDR)
           CALL GSTOP(GEXIT_SUCCESS)
        ENDIF 
C
C	PROCESS NEXT LOAD NOW
C       IF THE SECOND WORD OF THE FILE NAME IS 0 THEN THIS 
C       IS AN OLD LOAD TYPE AND ONLY CONTAINS A LOAD NAME
C       AND NO VERSION NUMBER
C
	IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
	    WRITE(6, 2000) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *	                   DLLFIL(2,LODNUM,CURRENT_APPLICATION)
2000	    FORMAT(/,' *** Processing file ', A4,Z4.4, '.BIN *** ')
	ELSE
	    WRITE(6, 2001) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
2001	    FORMAT(/,' *** Processing file ', A4, '.BIN *** ')
	ENDIF
C
C       INITIALIZE WORK SEGMENT WORK AREA
C
	CALL FASTSET(0, MCPBYT, MCPISIZ)
	CALL FASTSET(0, APPBYT, APPISIZ)
	CALL FASTSET(0, SFTBYT, SFTISIZ)
	CALL FASTSET(0, GVTBYT, GVTISIZ)
	CALL FASTSET(0, ACLBYT, ACLISIZ)
C
	TRAIL    = 0
	ALLSEG   = 0
	U_ALLSEG = 0
	C_ALLSEG = 0
	MSEG0    = NEXTADDR
	EOF      = .FALSE.
        MCP      = .FALSE.
        ACL      = .FALSE.
        FCL      = .FALSE.
        SFT      = .FALSE.
        GVT      = .FALSE.
        APP      = .FALSE.
	ALLBYTES = 1
	FCLDTA_FLAG=.FALSE.
	DBLBIN=.FALSE.
C
C       DETERMINE THE TYPE OF LOAD (BIN FILE)
C
	IF(APPLICATION_TYPE.EQ.FCL_TYPE) FCL = .TRUE.
	IF(APPLICATION_TYPE.EQ.APP_TYPE) APP = .TRUE.
	IF(APPLICATION_TYPE.EQ.MCP_TYPE) MCP = .TRUE.
	IF(APPLICATION_TYPE.EQ.SFT_TYPE) SFT = .TRUE.
	IF(APPLICATION_TYPE.EQ.GVT_TYPE) GVT = .TRUE.
	IF(APPLICATION_TYPE.EQ.ACL_TYPE) ACL = .TRUE.
C
C       OPEN CURRENT FILE FOR PROCESSING
C
	IF (MCP) THEN
	  RECLEN = MCPCSIZ
	  ACL_FORMAT=.FALSE.		    !ASSUME IT IS AN OLD FORMAT
	ELSE IF (SFT) THEN
	  RECLEN = SFTSEG0                  !?????? MAY NOT BE RIGHT
	ELSE IF (GVT) THEN
	  RECLEN = GVTCSIZ
	ELSE IF (APP .OR. FCL) THEN
	  RECLEN = APPCSIZ
	ELSE IF (ACL) THEN
	  RECLEN = ACLCSIZ
	  ACL_FORMAT=.TRUE.
	ELSE
	  TYPE *,'Invalid load type ',APPLICATION_TYPE,
     *	                     ' LODNUM,CURRENT_APPLICATION ',
     *                         LODNUM,CURRENT_APPLICATION
	  CALL GSTOP(GEXIT_FATAL)
	ENDIF
C
C
C
	MESSAG = MSEG0
	NEW = .TRUE.
	DLLATR(LODNUM, LODADR,CURRENT_APPLICATION) = MSEG0
	FILNAMES(1) = DLLFIL(1,LODNUM,CURRENT_APPLICATION)
	FILNAMES(2) = DLLFIL(2,LODNUM,CURRENT_APPLICATION)
C
C       READ THE RECORD FROM THE FILE 
C
       	CALL DLLREC(NEW, FILNAMES, 2, RECLEN, CRECBUF, ST)
	IF (ST .NE. 0) THEN
	  IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
	    WRITE(6, 2100) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *			   DLLFIL(2,LODNUM,CURRENT_APPLICATION)
2100	    FORMAT(' FILE ', A4,Z4.4, '.BIN NOT THERE ... PLEASE CHECK')
	  ELSE
	    WRITE(6, 2101) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
2101	    FORMAT(' FILE ', A4, '.BIN NOT THERE ... PLEASE CHECK')
	  ENDIF
	  CALL GSTOP(GEXIT_FATAL)
	ENDIF
C
	SEGNUM = 0		! FIRST SEGMENT
	NUMSEG = 0		! NUMBER OF SEGMENTS CONVERTED
	PTR    = 0		! POINTER TO NEXT ALLOCATABLE MEMORY LOCATION
C
C     READ LOOP. READ A RECORD & LOAD INTO MSGCOM
C
	RECORD_INDEX=0
	SEGMENT_COUNTER=0
C
C       GVT SOFT LOADER ?
C
        IF (SFT) THEN
	  RECORD_INDEX = 1        ! NO HEADER SEGMENT FOR GVT SOFTLOADER
	  SEGMENT_COUNTER = -1
	ENDIF
C
2200	CONTINUE
C
	IF (MCP) THEN
	  CALL DLLREC(NEW, FILNAMES, 2, RECLEN, CMCPBYT, ST)
	ELSE IF (SFT) THEN
	  IF (RECORD_INDEX .GT. 1) RECLEN = SFTCSIZ
	  CALL DLLREC(NEW, FILNAMES, 2, RECLEN, CSFTBYT, ST)
	ELSE IF (GVT) THEN
	  RECLEN=GVTCSIZ
	  CALL DLLREC(NEW, FILNAMES, 2, RECLEN, CGVTBYT, ST)
	ELSE IF (ACL) THEN
	  CALL DLLREC(NEW, FILNAMES, 2, RECLEN, CACLBYT, ST)
	ELSE
	  CALL DLLREC(NEW, FILNAMES, 2, RECLEN, CAPPBYT, ST)
	ENDIF
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C IF GVT LOAD THEN EXTRACT COMPRESSED/UNCOMPRESSED INFO FROM FILE HEADER
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
	IF(GVT.AND.GVT_COMPRESSED_FORMAT) THEN
	  RECLEN=GVTCSIZ
	  IF(RECORD_INDEX.EQ.0) THEN
	    CALL MOVBYTN(GVTBYT,1,NLOADS,1,4)
	    CALL MOVBYTN(GVTBYT,5,U_FIRST,1,4)
	    CALL MOVBYTN(GVTBYT,9,U_ALLSEG,1,4)
	    CALL MOVBYTN(GVTBYT,13,C_FIRST,1,4)
	    CALL MOVBYTN(GVTBYT,17,C_ALLSEG,1,4)
	    IF(NLOADS.EQ.2) THEN
	      DLLATR(LODNUM,C_NBRSEG,CURRENT_APPLICATION)=C_ALLSEG
	      NEXTADDR=NEXTADDR+(U_ALLSEG)*2
	      ALLSEG=U_ALLSEG+C_ALLSEG
	    ELSE
	      DLLATR(LODNUM,C_NBRSEG,CURRENT_APPLICATION)=0
	      NEXTADDR=NEXTADDR+U_ALLSEG
	      ALLSEG=U_ALLSEG
	    ENDIF
	    DLLATR(LODNUM,NBRSEG,CURRENT_APPLICATION)=U_ALLSEG
	    RECORD_INDEX=RECORD_INDEX+1
	    GOTO 2200
	  ENDIF
C
C         GET UNCOMPRESSED LOAD HEADER INFORMATION
C
	  IF(RECORD_INDEX.EQ.U_FIRST) THEN
	    CHKSM16=0
	    CALL MOVBYT(GVTBYT,73,CHKSM16, 3,2)
	    DLLATR(LODNUM,CRC16,CURRENT_APPLICATION)=CHKSM16
	    IF(DLLATR(LODNUM,SNDFLG,CURRENT_APPLICATION).EQ.0.AND.
     *         DLLATR(LODNUM,CRC16,CURRENT_APPLICATION).NE.
     *         SMFDLTAB(LODNUM,CRC16,CURRENT_APPLICATION) .OR.
     *        SMFDLTAB(LODNUM,CRC16,CURRENT_APPLICATION).EQ.0) THEN

	      DLLATR(LODNUM,SNDFLG,CURRENT_APPLICATION)=1
	      NEWLOADS=NEWLOADS+1
	      IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
		WRITE(6, 2300) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *			 DLLFIL(2,LODNUM,CURRENT_APPLICATION)
	      ELSE
		WRITE(6, 2301) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
	      ENDIF
	    ENDIF
	    SEGADR=MSEG0
	    RECORD_INDEX=RECORD_INDEX+1
	    GOTO 2200
	  ENDIF
C
C         GET COMPRESSED LOAD HEADER INFORMATION
C
          IF(RECORD_INDEX.EQ.C_FIRST) THEN
	    C_CHKSM16=0
            CALL MOVBYT(GVTBYT,73,C_CHKSM16, 3,2)
            DLLATR(LODNUM,C_CRC16,CURRENT_APPLICATION)=C_CHKSM16
            IF(DLLATR(LODNUM,SNDFLG,CURRENT_APPLICATION).EQ.0.AND.
     *        DLLATR(LODNUM,CRC16,CURRENT_APPLICATION).NE.
     *         SMFDLTAB(LODNUM,CRC16,CURRENT_APPLICATION)) THEN
               
		 IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
      		      WRITE(5,9877) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *			       DLLFIL(2,LODNUM,CURRENT_APPLICATION)      
		 ELSE
		      WRITE(5,9878) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
		 ENDIF
            ENDIF
	    MESSAG=MSEG0+1
	    SEGADR=MSEG0+1
	    RECORD_INDEX=RECORD_INDEX+1
	    GOTO 2200
          ENDIF
C
C GET SEGMENT ZERO OF UNCOMPRESSED LOAD
C
	  IF(RECORD_INDEX.EQ.U_FIRST+1) THEN
	    RECLEN=GVTSEG0
	    CALL MOVBYTN(GVTBYT,19,REVNUM,4,1)
	    CALL MOVBYTN(GVTBYT,20,REVNUM1,4,1)
	    DLLATR(LODNUM,LODREV,CURRENT_APPLICATION)=REVNUM+REVNUM
	  ENDIF
C
C GET SEGMENT ZERO OF COMPRESSED LOAD
C
          IF(RECORD_INDEX.EQ.C_FIRST+1.AND.C_FIRST.NE.0) THEN
	    RECLEN=GVTSEG0
	    GOTO 2250
          ENDIF
C
C LOAD SEGMENT TO MESSAGE FILE
C
2250	  CONTINUE
	  PTR=0
	  DO 2275 J=0,RECLEN-1
	    PTR=PTR+1
	    CALL ILBYTE(MEMORY(PTR),GVTBYT(1),J)
2275	  CONTINUE
	  CALL ADDMSG(MESSAG, MEMORY, RECLEN)
	  NUMSEG=NUMSEG+1
	  MESSAG=MESSAG+2
	  RECORD_INDEX=RECORD_INDEX+1
C
C         CHECK IF DONE
C
	  IF(NUMSEG.GE.ALLSEG-2) THEN
            LODLEN   = (NUMSEG - 1) * RECLEN
	    GOTO 3350
	  ENDIF
 	  GOTO 2200
	ENDIF
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C       END OF GVT SPECIAL FILE FORMAT CHANGES
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
	SEGMENT_COUNTER = SEGMENT_COUNTER + 1
C
C       IF DOUBLE BIN FILE, ONLY READ EVERY SECOND FCL RECORD,
C       SINCE ONLY EVERY SECOND RECORD WILL CONTAIN DATA THAT
C       WE CAN UNDERSTAND (UNCOMPRESSED)
C
	IF(FCL.AND.DBLBIN.AND.FCLDTA_FLAG.AND.RECORD_INDEX.NE.1) THEN
	   FCLDTA_FLAG=.FALSE.
	ELSEIF(FCL) THEN
	   FCLDTA_FLAG=.TRUE.
	ENDIF
C
C	ACL DOES NOT HAVE A CONTROL HEADER, RETRIEVE CONTROL INFO FROM MESSAGE
C	
	IF(ACL.AND.RECORD_INDEX.EQ.1) THEN
	  CALL MOVBYTN(ACLBYT,8,MODREV,3,2)
	  DLLATR(ACL_LOAD_NO, LODREV,CURRENT_APPLICATION) = MODREV
	  CALL MOVBYTN(ACLBYT,3,CHKSM16, 3, 2)	! CRC16 OF DATA
	  DLLATR(LODNUM, CRC16,CURRENT_APPLICATION) = CHKSM16
	  CALL ILBYTE(TID,ACLBYT,6-1)
	  DLLATR(LODNUM, TERMINAL_ID_NO,CURRENT_APPLICATION)=TID
	  WRITE(6,9002) CHKSM16, TID
9002	  FORMAT(1H ,'ACL checksum ',Z4.4,', ACL TID ',Z2.2)
C
C         TEST ALL THE LOADS
C
	  DO 2260 NEXT_APPLICATION=1,SFT_APP_NO-1
          TMPREV = ZEXT(SMFDLTAB(LODNUM, LODREV,NEXT_APPLICATION))
	  IF ((DLLATR(ACL_LOAD_NO, CRC16,CURRENT_APPLICATION).EQ. 
     *	       SMFDLTAB(ACL_LOAD_NO, CRC16,NEXT_APPLICATION) .AND. 
     *		 SMFDLTAB(ACL_LOAD_NO, CRC16,NEXT_APPLICATION) .NE.0) .AND.
     *		 (DLLFIL(1,LODNUM,CURRENT_APPLICATION).EQ.
     *		  SMFDLNAM(1,LODNUM,NEXT_APPLICATION))		      .AND.
     *		  TMPREV.EQ.MODREV) 
     *								  GOTO 2270
2260	  CONTINUE
	  WRITE(6, 2300) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *			 DLLFIL(2,LODNUM,CURRENT_APPLICATION),MODREV
	  DLLATR(LODNUM, SNDFLG,CURRENT_APPLICATION) = 1
	  NEWLOADS = NEWLOADS + 1
2270	  CONTINUE
	ENDIF
        IF (FCLDTA_FLAG) THEN
	  IF (ACL_FORMAT) THEN
      	      CALL MOVBYT(APPBYT, 27, FCLTAB, ALLBYTES, 250)   ! OFFSET HEADER
      	      ALLBYTES = ALLBYTES + 250
	  ELSE
	      CALL MOVBYT(APPBYT, 21, FCLTAB, ALLBYTES, 256)   ! OFFSET HEADER
	      ALLBYTES = ALLBYTES + 256
	  ENDIF
        ENDIF
C
C       EXTRACT HEADER INFORMATION FROM RECORD ONE
C       (NOT DONE FOR GVT SOFTLOADER)
C
	IF (RECORD_INDEX.EQ.0) THEN
	  CHKSM16=0
C
C         EXTRACT MCP HEADER INFORMATION 
C
	  IF (MCP) THEN
       	    CALL MOVBYTN(MCPBYT, 17, CHKSM16, 3, 2)	! CRC16 OF DATA
       	    CALL MOVBYTN(MCPBYT, 57, U_ALLSEG,  3, 2)	! NUMBER OF SEGMENTS
	    DLLATR(LODNUM, CRC16,CURRENT_APPLICATION) = CHKSM16
	    MODREV=0
	    CALL MOVBYTN(MCPBYT,69,MODREV,3,2)
	    DLLATR(LODNUM, LODREV,CURRENT_APPLICATION) = MODREV
C
C         EXTRACT GVT HEADER INFORMATION
C
	  ELSE IF (GVT) THEN
	    CALL MOVBYT(GVTBYT,  73, CHKSM16, 3, 2)	! CRC16 OF DATA
	    CALL MOVBYT(GVTBYT, 107, U_ALLSEG,  1, 2)	! NUMBER OF SEGMENTS
	    DLLATR(LODNUM, CRC16,CURRENT_APPLICATION) = CHKSM16
	    CALL MOVBYTN(GVTBYT,69,MODREV,3,2)
C
C         EXTRACT ACL INFORMATION
C
	  ELSE IF (ACL) THEN
	    U_ALLSEG=1				
	    GOTO 2310
C
C         EXTRACT APPLICATION LOAD INFORMATION
C					
	  ELSE IF (.NOT. SFT) THEN 	
	    CALL MOVBYTN(APPBYT, 17, CHKSM16, 3, 2)	! CRC16 OF DATA
	    CALL MOVBYTN(APPBYT, 57, U_ALLSEG,  3, 2)	! NUMBER OF SEGMENTS
	    DLLATR(LODNUM, CRC16,CURRENT_APPLICATION) = CHKSM16
	    CALL MOVBYTN(APPBYT,69,MODREV,3,2)
	  ENDIF
C
C         TEST IF THIS LOAD HAS CHANGED BASED ON CRC  
C         IF LOAD HAS CHANGED THEN MARK AS SUCH (SNDFLG)
C
	  DO 2290 NEXT_APPLICATION=1,SFT_APP_NO - 1
            TMPREV = ZEXT(SMFDLTAB(LODNUM, LODREV,NEXT_APPLICATION))
	    IF ((DLLATR(LODNUM, CRC16,CURRENT_APPLICATION).EQ. 
     *		 SMFDLTAB(LODNUM, CRC16,NEXT_APPLICATION) .AND. 
     *		 SMFDLTAB(LODNUM, CRC16,NEXT_APPLICATION) .NE.0) .AND.
     *		 (DLLFIL(1,LODNUM,CURRENT_APPLICATION).EQ.
     *		  SMFDLNAM(1,LODNUM,NEXT_APPLICATION))) THEN
		  IF (GVT .OR. SFT) GOTO 2310
		  IF (TMPREV.EQ.MODREV)
     *						  GOTO 2310
	     ENDIF
2290	  CONTINUE
	  DLLATR(LODNUM, SNDFLG, CURRENT_APPLICATION) = 1
	  NEWLOADS = NEWLOADS + 1
C
C         ANNOUNCE THAT LOAD HAS CHANGED
C
	  IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
	    WRITE(6, 2300) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *			   DLLFIL(2,LODNUM,CURRENT_APPLICATION),MODREV
2300	    FORMAT(' File ', A4,Z4.4, '.BIN marked as new release in DLL ',
     *	           1X,' new revision ',Z4.4)
	  ELSE
	    WRITE(6, 2301) DLLFIL(1,LODNUM,CURRENT_APPLICATION),MODREV
2301	    FORMAT(' File ', A4, '.BIN marked as new release in DLL ',
     *             1X,' new revision ',Z4.4)
	  ENDIF
C
C
C         CHECK FOR DOUBLE BIN MCP 
C
2310	  CONTINUE
	  DLLATR(LODNUM, NBRSEG,CURRENT_APPLICATION) = ALLSEG
	  IF(MCP) THEN
            CALL MOVBYT(MCPBYT,71,I2TEMP,1,2)      !DOUBLE BIN FILE ID. 
            IF(I2TEMP.EQ.DOUBLE_BINFILE) THEN                          
              DBLBIN=.TRUE.            
	      C_CHKSM16=0                  
              CALL MOVBYTN(MCPBYT,75,C_CHKSM16, 3,2)                    
              CALL MOVBYTN(MCPBYT,73,C_ALLSEG,3,2)                     
              DLLATR(LODNUM,C_CRC16,CURRENT_APPLICATION)=C_CHKSM16 
C
C             CHECK IF THE COMPRESSED PORTION OF THE DOUBLE BIN
C             FILE HAS CHANGED 
C
              IF(DLLATR(LODNUM,SNDFLG,CURRENT_APPLICATION).EQ.0 .AND.
     *           DLLATR(LODNUM,C_CRC16,CURRENT_APPLICATION).NE.
     *           SMFDLTAB(LODNUM,C_CRC16,CURRENT_APPLICATION)) THEN
		 IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
      		      WRITE(6,9877) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *			       DLLFIL(2,LODNUM,CURRENT_APPLICATION)      
9877  		      FORMAT(' File ',A4,Z4.4,
     *			' BIN has changes to compressed', 
     *                  ' data but not to regular load data')   
		 ELSE
		      WRITE(6,9878) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
9878  		      FORMAT(' File ',A4,
     *			' BIN has changes to compressed', 
     *                  ' data but not to regular load data')   
		 ENDIF
              ENDIF                                             
            ENDIF                                               
	  ENDIF
C
C         CHECK FOR DOUBLE BIN APPLICATION OR FCL
C
	  IF(APP .OR. FCL) THEN
            CALL MOVBYT(APPBYT,71,I2TEMP,1,2)                        
            IF(I2TEMP.EQ.DOUBLE_BINFILE) THEN                        
              DBLBIN=.TRUE.                                          
	      C_CHKSM16=0
              CALL MOVBYTN(APPBYT,75,C_CHKSM16, 3,2)                  
              CALL MOVBYTN(APPBYT,73,C_ALLSEG,3,2)                   
              DLLATR(LODNUM,C_CRC16,CURRENT_APPLICATION)=C_CHKSM16
C
C             TEST IF COMPRESSED PORTION OF LOAD HAS CHANGED
C
              IF(DLLATR(LODNUM,SNDFLG,CURRENT_APPLICATION).EQ.0.AND.
     *           DLLATR(LODNUM,C_CRC16,CURRENT_APPLICATION).NE.
     *            SMFDLTAB(LODNUM,C_CRC16,CURRENT_APPLICATION)) THEN
		 IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
      		      WRITE(6,9877) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *			       DLLFIL(2,LODNUM,CURRENT_APPLICATION)      
		 ELSE
		      WRITE(6,9878) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
		 ENDIF
              ENDIF                                                  
            ENDIF
          ENDIF
C
C         CALCULATE NUMBER OF SEGMENTS AND ADJUST FOR THE FILE HEADER  
C         AND SEG0 FOR BOTH COMPRESSED AND UNCOMPRESSED                    
C
          ALLSEG = U_ALLSEG + 1                                          
          IF(DBLBIN) ALLSEG=ALLSEG*2                                 
          ALLSEG = ALLSEG + 1
C
C         SET DOWNLOAD TABLE FOR NUMBER UNCOMPRESSED SEGMENTS
C                                                
          DLLATR(LODNUM,NBRSEG,CURRENT_APPLICATION) = U_ALLSEG+1
	  IF(GVT) ALLSEG = U_ALLSEG
C
C         SET DOWNLOAD TABLE FOR NUMBER COMPRESSED SEGMENTS
C
          IF(DBLBIN) THEN                                            
            DLLATR(LODNUM,C_NBRSEG,CURRENT_APPLICATION)=C_ALLSEG+1
          ELSE                                                       
            DLLATR(LODNUM,C_NBRSEG,CURRENT_APPLICATION)=0         
          ENDIF                                                      
	  RECORD_INDEX = 1
	  GOTO 2200					! READ NEXT RECORD
C
C       EXTRACT SEGMENT ZERO AND LOAD INTO MEMORY
C
	ELSE IF (RECORD_INDEX .EQ. 1) THEN
C
C
C
	  IF (MCP) THEN
	    CALL MOVBYT(MCPBYT, 3, ROMID, 1,4)
	    I4 = ROMID
	    DLLATR(LODNUM, DLL_ROMREV,CURRENT_APPLICATION) =I2(1)
	    DLLATR(LODNUM, DLL_ROMREV1,CURRENT_APPLICATION)=I2(2)
            CALL MOVBYTN(I1, 1, TMP_ROMID, 1, 4)
            IF(TMP_ROMID.NE.MCPROM(CURRENT_APPLICATION)) THEN
              WRITE(6,8999) MCPNAM(CURRENT_APPLICATION),ROMID
8999          FORMAT(' Romrev for ',A4,' ',A4
     *               ' does not match that in ROMREV.FIL')    
            ENDIF
C
	    WRITE(6,9001)I1,LODNUM,CURRENT_APPLICATION
9001	    FORMAT(' Romrev ',4A1,' Load ',I4,' application ',I4)

C           START OF V25--IF IT IS ALTURA, THEN INCREASE THE LENGTH OF SEGMENT
C           ZERO FOR MCP

            IF (TMP_ROMID .NE. ALTURA_ROM) THEN
               LENSEG0 = MCPSEG0
            ELSE
               LENSEG0 = MCPCSIZ
            ENDIF

C           END OF V25
C
C
C
	  ELSE IF (SFT) THEN
	    CHKSM16=0
	    CALL MOVBYTN(SFTBYT,  7, CHKSM16, 3, 2)	! PROGRAM ID
	    CALL MOVBYTN(SFTBYT,  9, ALLSEG,  3, 2)	! NUMBER OF BLOCKS
	    DLLATR(LODNUM, CRC16,CURRENT_APPLICATION) = CHKSM16
C
C           TEST LOAD AND DETERMINE IF IT HAS CHANGED BASED ON CRC
C
	    IF (DLLATR(LODNUM,CRC16,CURRENT_APPLICATION).NE.
     *	         SMFDLTAB(LODNUM, CRC16,CURRENT_APPLICATION) .OR.
     *	        SMFDLTAB(LODNUM, CRC16,CURRENT_APPLICATION) .EQ. 0) THEN
	      IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
		WRITE(6, 2300) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *	                       DLLFIL(2,LODNUM,CURRENT_APPLICATION)
	      ELSE
		WRITE(6, 2301) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
	      ENDIF
C
C             MARK LOAD AS CHANGED
C
	      DLLATR(LODNUM, SNDFLG,CURRENT_APPLICATION) = 1
	      NEWLOADS = NEWLOADS + 1
	    ENDIF
            U_ALLSEG = ALLSEG
	    DLLATR(LODNUM, NBRSEG,CURRENT_APPLICATION) = ALLSEG
	    LENSEG0 = SFTSEG0
C
C
C
	  ELSE IF (GVT) THEN
	    LENSEG0 = GVTSEG0
C
C
C
	  ELSE IF (.NOT.ACL) THEN
            CALL MOVBYTN(APPBYT,33,REVNUM,3,2)                       
	    CALL ILBYTE(TID,APPBYT,4-1)
            IF (FCL) THEN 
               IF(IAND(TID,FCLTIN(CURRENT_APPLICATION))
     *            .NE.FCLTIN(CURRENT_APPLICATION)) THEN
                 WRITE(6,9872) TID, FCLTIN(CURRENT_APPLICATION)
9872             FORMAT(' FCLTIN number',Z4.4,/,
     *                  ' does not match revision number in ROMREV.FIL ',/,
     *                  Z4.4)
               ENDIF
            ENDIF  
C
	    DLLATR(LODNUM, TERMINAL_ID_NO,CURRENT_APPLICATION)=TID
	    IF(APP .AND. .NOT.DBLBIN) THEN  
              TMPREV = ZEXT(DLLATR(LODNUM,LODREV,CURRENT_APPLICATION))
              IF(TMPREV.NE.REVNUM) THEN

		IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
      		  WRITE(6,9873) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *			      DLLFIL(2,LODNUM,CURRENT_APPLICATION)
9873  		  FORMAT(' Revision number extracted from seg zero ',/,  
     *                 ' does not match revision number in FCL for',/, 
     *                 ' file ',A4,Z4.4,'.BIN cannot convert')

		ELSE
      		  WRITE(6,9874) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
9874  		  FORMAT(' Revision number extracted from seg zero ',/,  
     *                 ' does not match revision number in FCL for',/, 
     *                 ' file ',A4,'.BIN cannot convert')
		ENDIF              
                  CALL GSTOP(GEXIT_FATAL)
C...            PAUSE                                                  
              ENDIF                                                    
              DLLATR(LODNUM,LODREV,CURRENT_APPLICATION)=REVNUM
            ENDIF                                                      
C           START OF V25--IF IT IS ALTURA TERMINAL, THEN INCREASE
C           THE LENGTH OF SEMENT ZERO FOR BOTH FCL AND APPLICATION.

            IF (TID .NE. ALTURA_TIN) THEN
                LENSEG0 = FCLSEG0
            ELSE
                LENSEG0 = APPCSIZ
            ENDIF

C           END OF V25

	  ENDIF
C
C
C
	  DO 2500 J = 0, LENSEG0 - 1
	    IF (.NOT. MCP .AND. .NOT.ACL) THEN
               CALL MOVBYTN(APPBYT, 33, REVNUM, 3, 2)	! REVISION NUMBER
	       IF (DLLATR(LODNUM,APPTYPE,CURRENT_APPLICATION)
     *						  .EQ.APP_TYPE) THEN
                TMPREV=ZEXT(DLLATR(LODNUM,LODREV,CURRENT_APPLICATION))
	        IF (TMPREV .NE. REVNUM) THEN
		  IF (DLLFIL(2,LODNUM,CURRENT_APPLICATION).NE.0) THEN
		    WRITE(6, 2400) DLLFIL(1,LODNUM,CURRENT_APPLICATION),
     *				 DLLFIL(2,LODNUM,CURRENT_APPLICATION)
2400		    FORMAT(' Revision number extracted from segzero ', /,
     *		         ' does not match revision number in fcl for ', /,
     *		         ' file ', A4,Z4.4, '.bin cannot convert ')
		    CALL GPAUSE
		  ELSE
		    WRITE(6, 2401) DLLFIL(1,LODNUM,CURRENT_APPLICATION)
2401		    FORMAT(' Revision number extracted from segzero ', /,
     *		         ' does not match revision number in fcl for ', /,
     *		         ' file ', A4,'.bin cannot convert ')
		    CALL GSTOP(GEXIT_FATAL)
		  ENDIF
	        ENDIF
	        DLLATR(LODNUM, LODREV,CURRENT_APPLICATION) = REVNUM
	      ENDIF
	    ENDIF
C
C
C
	    PTR = PTR + 1
	    IF (MCP) THEN
	      CALL ILBYTE(MEMORY(PTR), MCPBYT(1), J)
	    ELSE IF (SFT) THEN
	      CALL ILBYTE(MEMORY(PTR), SFTBYT(1), J)
	    ELSE IF (GVT) THEN
	      CALL ILBYTE(MEMORY(PTR), GVTBYT(1), J)
	    ELSE IF (ACL) THEN
	      CALL ILBYTE(MEMORY(PTR), ACLBYT(1), J)
	    ELSE
	      CALL ILBYTE(MEMORY(PTR), APPBYT(1), J)
	    ENDIF
2500	  CONTINUE
C
C
C
	  RECORD_INDEX = 2
	  GOTO 2700					! WRITE SEGMENT ZERO
	ENDIF
C
C
C
	IF (SEGMENT_COUNTER .GE. ALLSEG) EOF = .TRUE.
C
C        NOW SAVE INTO MEMORY
C
	DO 2600 J = 0, RECLEN - 1
	  PTR = PTR + 1
	  IF (MCP) THEN
	    CALL ILBYTE(MEMORY(PTR), MCPBYT(1), J)
	  ELSE IF (SFT) THEN
	    CALL ILBYTE(MEMORY(PTR), SFTBYT(1), J)
	  ELSE IF (GVT) THEN
	    CALL ILBYTE(MEMORY(PTR), GVTBYT(1), J)
	  ELSE IF (ACL) THEN
	    CALL ILBYTE(MEMORY(PTR), ACLBYT(1), J)
	  ELSE
	    CALL ILBYTE(MEMORY(PTR), APPBYT(1), J)
	  ENDIF
2600	CONTINUE
C
	IF (PTR .GE. RECLEN) GOTO 2700			! WE HAVE A SEGMENT
	GOTO 2200
C
C     NOW STORE SEGMENT
C
2700	CONTINUE
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C        NOW ADD TO MSGCOM
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
	IF (ACL .AND. RECORD_INDEX.GE.1) THEN
	    ACL_PRESENT=.TRUE.
	    EOF=.TRUE.		      !ACL HAS ONLY ONE SEGMENT
	    CALL ADDMSG(5,MEMORY,PTR) !FOR "RESTART"
	ENDIF
C
	IF (FCL .AND. SEGNUM.EQ.1 .AND. .NOT.ACL_PRESENT) !CREATE MESSAGE # 5
     *		  CALL ADDMSG(5,MEMORY,PTR)               !FOR "RESTART"
	CALL ADDMSG(MESSAG, MEMORY, PTR)
	SEGNUM = SEGNUM + 1
	MESSAG = MESSAG + 1
C
C       CHECK IF MESSAGE # IS VALID FOR THIS TASK (SEE PRMDLL.DEF)
C
	IF (MESSAG .GE. MSGS) THEN
	  TYPE *, 'Task is going out of bounds in msgcom ',MESSAG
	  CALL GSTOP(GEXIT_FATAL)
	ENDIF
C
	NUMSEG = NUMSEG + 1
	TRAIL  = PTR
	PTR    = 0
	IF (EOF) GOTO 2800
	GOTO 2200
C
2800	CONTINUE
	LODLEN   = (NUMSEG - 1) * RECLEN + TRAIL
	NEXTADDR = MSEG0 + NUMSEG 
C
C
C       DECODE APPLICATION CONTROL LOAD, THIS MAY BE AN ACL OR A FCL
C
	IF (ACL) THEN
C
C           EXTRACT NUMBER OF FCL's and PROCESS EACH BLOCK
C
	    FCL_OFFSET=8
	    CALL ILBYTE(NUMFCL,ACLBYT,6)
	    WRITE(6,2084) NUMFCL
2084        FORMAT(' No of FCL files found in ACL ',I4.4)
C
C           EXTRACT FCL NAMES AND REVISIONS	
C
	    DO 2810, NEXT_APPLICATION=0,NUMFCL-1
	       MODREV=0
	       CALL MOVBYTN(ACLBYT,FCL_OFFSET,MODREV,3,2)
	       CALL MOVBYT(ACLBYT,FCL_OFFSET+2,FCL_NAME,1,4)

	       DLLFIL(1,FCL_LOAD_NO,NEXT_APPLICATION+
     *				      CURRENT_APPLICATION)=FCL_NAME
	       DLLFIL(2,FCL_LOAD_NO,NEXT_APPLICATION+
     *				      CURRENT_APPLICATION)=MODREV
	       DLLATR(FCL_LOAD_NO, APPTYPE, NEXT_APPLICATION+
     *				      CURRENT_APPLICATION) = FCL_TYPE
	       FCL_OFFSET=FCL_OFFSET + 6
	       WRITE(6,2805) NEXT_APPLICATION+CURRENT_APPLICATION,
     *			     FCL_NAME,MODREV
2805	       FORMAT(' Processing ACL ',I3,' retrieving ',A4,Z4.4,
     *		      '.BIN')
2810	    CONTINUE
	ENDIF
C
	IF (FCL) THEN
	  TOTAPP = 0
	  IF (ACL_FORMAT) THEN
	    CALL MOVBYTN(FCLTAB, 501, MYSIZE, 3, 2)	! SIZE OF FCL STRUCTURE
	    CALL MOVBYTN(FCLTAB, 505, TOTAPP, 3, 2)	! # OF LOADS IN THE FCL STRUCTURE
	    START_DATA=515
	  ELSE
	    CALL MOVBYTN(FCLTAB, 513, MYSIZE, 3, 2) ! SIZE OF FCL STRUCTURE
	    CALL MOVBYTN(FCLTAB, 517, TOTAPP, 3, 2) ! # OF LOADS IN THE FCL STRUCTURE
	    START_DATA=527
	  ENDIF
	  FCL_REV=0
	  DO 3100 OFF = START_DATA, ALLBYTES, MYSIZE
C
C           EXTRACT MODULE NAMES,LOAD NUMBERS AND REVISION DATA FROM FILE
C
	    CALL MOVBYTN(FCLTAB, OFF-12, LOAD_NO, 3,2)
	    CALL MOVBYT(FCLTAB, OFF, MODNAM, 1, 4)
	    CALL MOVBYTN(FCLTAB, OFF+4, MODREV, 3, 2)
C
C	    SKIP UNDEFINED MODULES
C
	    IF (MODNAM .EQ. 0 .AND. MODREV .EQ. 0) GOTO 3100
	    FILE_INDEX = LOAD_NO + FCL_LOAD_NO
	    IF (FILE_INDEX.GT.MAXLOADS) THEN
	      WRITE(6, 3000) 
3000	      FORMAT('Number of files exceeds the maximum supported')
	      CALL GSTOP(GEXIT_FATAL)
	    ENDIF
C
	    IF (FILE_INDEX.EQ.FCL_LOAD_NO) FCL_REV=MODREV
	    DLLFIL(1,FILE_INDEX,CURRENT_APPLICATION) = MODNAM
            IF (ACL_FORMAT) THEN
              DLLFIL(2,FILE_INDEX,CURRENT_APPLICATION) = FCL_REV
            ELSE
              DLLFIL(2,FILE_INDEX,CURRENT_APPLICATION) = 0
            ENDIF
	    DLLATR(FILE_INDEX, LODREV,CURRENT_APPLICATION) = MODREV
	    IF (FILE_INDEX.NE.FCL_LOAD_NO)
     *	      DLLATR(FILE_INDEX, APPTYPE, CURRENT_APPLICATION) = APP_TYPE
	    WRITE(6, 3050)FILE_INDEX,CURRENT_APPLICATION,
     *                    DLLFIL(1,FILE_INDEX,CURRENT_APPLICATION),
     *	                  MODREV
3050	    FORMAT(' Extracting load: ',I4,', app: ',I3,
     *             ' from FCL ', A4,' rev ',Z4.4) 
	    
3100	  CONTINUE
C
	ENDIF

3350	CONTINUE
	WRITE(6, *) 'Uncompressed segments        = ', U_ALLSEG
	WRITE(6, *) 'Compressed segments          = ', C_ALLSEG
	WRITE(6, *) 'Number of segments processed = ', NUMSEG + 1
	WRITE(6, *) 'Message number of segzero    = ', MSEG0
	WRITE(6, *) 'Total program length         = ', LODLEN
	WRITE(6, *) 'Next available message #     = ', NEXTADDR
	WRITE(6, *) 'Maximum message # available  = ', MSGS
	WRITE(6, *) 'Maximum overflow #           = ', I4MSGTAB(MFRLNK, MSGCTL)
C
	CALL USRCLOS1(2)
	GOTO 1600
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE ADDMSG(MSGNUM, MEMORY, LEN)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
	INCLUDE 'INCLIB:PRMDLL.DEF'
C
	INTEGER*4	C,
     *			LEN,
     *			MEMORY(LEN),
     *			MESNUM,
     *			MSGLEN,
     *			MSGNUM,
     *			P
C
	CHARACTER*1000	MSGBUF
	CHARACTER*1	CTMP
C
	COMMON /STUFFC/ C, MSGBUF			! FOR STUFFIT PROC.
C
C ADD THE CODE SEGMENT TO /MSGCOM/ USING THE EXISTING MESMNT ROUTINES.
C FOR AUSTRALIA, THE MESSAGE NUMBER AND THE SEGMENT NUMBER WILL BE THE SAME.
C
	C = 0
C
C COPY THE ACTUAL CODE BYTE-BY-BYTE INTO THE MESSAGE TABLE
C
	DO 1000 P = 1, LEN				! LOOP THROUGH MEMORY
	  CALL STUFFIT(CHAR(MEMORY(P)))			! STUFF ANOTHER CHAR
1000	CONTINUE
	MSGLEN = C
C
C NOW ADD THE BYTES IN MSGBUF INTO /MSGCOM/
C
	CALL WRITMSG(MSGCHR, MSGNUM, MSGBUF(:MSGLEN))
	RETURN
C
C ENTRY POINT TO BUILD ULTIMATE RESET MESSAGE
C
	ENTRY BLDURS(MESNUM)				! ULTIMATE RESET
	C = 0
	CTMP = CHAR(3*16+0)				! CONTROL=Z30, SEQ=00
	CALL STUFFIT(CTMP)
	CTMP = CHAR(7*16+5)				! TYPE=7, SUBTYPE=5
	CALL STUFFIT(CTMP)				! (ULTIMATE RESET)
	CTMP = CHAR(4*16+10)
	CALL STUFFIT(CTMP)
	MSGLEN = C
	CALL WRITMSG(MSGCHR, MESNUM, MSGBUF(:MSGLEN))
	RETURN
C
C ENTRY POINY TO BUILD SOFT RESET MESSAGE
C
	ENTRY BLDSRS(MESNUM)				! SOFT RESET
	C = 0
	CTMP = CHAR(3*16+0)				! CONTROL=Z30, SEQ=00
	CALL STUFFIT(CTMP)
	CTMP = CHAR(7*16+7)				! TYPE=7, SUBTYPE=7
	CALL STUFFIT(CTMP)				! (SOFT RESET)
	MSGLEN = C
	CALL WRITMSG(MSGCHR, MESNUM, MSGBUF(:MSGLEN))
	RETURN
C
C ENTRY POINY TO BUILD HARD RESET MESSAGE
C
	ENTRY BLDHRS(MESNUM)				! HARD RESET
	C = 0
	CTMP = CHAR(3*16+0)				! CONTROL=Z30, SEQ=00
	CALL STUFFIT(CTMP)
	CTMP = CHAR(7*16+9)				! TYPE=7, SUBTYPE=9
	CALL STUFFIT(CTMP)				! (HARD RESET)
	MSGLEN = C
	CALL WRITMSG(MSGCHR, MESNUM, MSGBUF(:MSGLEN))
	RETURN
C
C ENTRY POINT TO BUILD RESTART RESET MESSAGE
C
C
        ENTRY BLDRRS(MESNUM)      !RESTART
        C=0
        CTMP=CHAR(3*16+0)        !CONTROL = Z30, SEQ = 00
        CALL STUFFIT(CTMP)
        CTMP=CHAR(10*16+10) !TYPE = A / SUBTYPE = A (RESTART MESSAGE)
        CALL STUFFIT(CTMP)
        MSGLEN=C
        CALL WRITMSG(MSGCHR,MESNUM,MSGBUF(:MSGLEN))
        RETURN   
C
C ENTRY POINT TO BUILD NEWS MESSAGE (Finland specific here)
C
        ENTRY BLDNWS (MESNUM)       !NEWS MESSAGE CONTROL
        IF(MESNUM.EQ.MNEWS .OR. MESNUM.EQ.TVNEWS) THEN
           MSGBUF( 1:26)=  '   BEM VINDO AO SISTEMA   '
           MSGBUF(27:52)=  '   ON - LINE DE APOSTAS   '
           MSGBUF(53:78)=  '                          '
           MSGBUF(79:104)= '     TENHA UM BOM DIA     '
           MSGBUF(105:130)='                          '
           MSGBUF(131:156)='   DEPARTAMENTO DE JOGOS  '
           MSGLEN=156
           CALL WRITMSG(MSGCHR,MESNUM,MSGBUF(:MSGLEN))
        ELSEIF(MESNUM.EQ.GVTNEWS) THEN
           MSGBUF( 1:26)=  '   BEM VINDO AO SISTEMA   '
           MSGBUF(27:52)=  '  INSTANTANEA DE APOSTAS  '
           MSGBUF(53:78)=  '                          '
           MSGBUF(79:104)= '     TENHA UM BOM DIA     '
           MSGBUF(105:130)='                          '
           MSGBUF(131:156)='   DEPARTAMENTO DE JOGOS  '
           MSGLEN=156
           CALL WRITMSG(MSGCHR,MESNUM,MSGBUF(:MSGLEN))
	ENDIF
        RETURN
C
C ENTRY POINT TO BUILD COMMUNICATION DISABLE MESSAGE FOR TERMINAL
C
	ENTRY BLDCOM(MESNUM)				! COMM DISABLE MESSAGE
	C = 0
	CTMP = CHAR(3*16+0)				! CONTROL=Z30, SEQ=00
	CALL STUFFIT(CTMP)
	CTMP = CHAR(7*16+6)				! TYPE=7, SUBTYPE=6
	CALL STUFFIT(CTMP)				! (COMM. DISABLE MESS)
	MSGLEN = C
	CALL WRITMSG(MSGCHR, MESNUM, MSGBUF(:MSGLEN))
C
	RETURN
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE STUFFIT (CHAR)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C     THIS SUBROUTINE LOADS A CHARACTER ARGUMENT INTO THE /MSGCOM/ BUFFER.
C
	INTEGER*4	PTR
C
	CHARACTER*1000	MSGBUF
	CHARACTER*1	CHAR
C
	COMMON /STUFFC/ PTR, MSGBUF
C
	PTR = PTR + 1
	MSGBUF(PTR: PTR) = CHAR
C
	RETURN
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C EXTRACT MESSAGE NUMBER, TEST FOR LEGALITY:
C
	INTEGER*4 FUNCTION GTMSGNUM(CMDLINE)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
C
	INTEGER*4	J
C
	CHARACTER*(*)	CMDLINE				! CONTAINS MESSAGE #.
C
	GTMSGNUM = CTOI(CMDLINE, J)			! CONVERT MESSAGE #.
	IF (GTMSGNUM .LT. 1 .OR. GTMSGNUM .GT. MSGS) THEN
	  WRITE(6, *) CMDLINE(:J), ' ILLEGAL MESSAGE NUMBER (1-100).'
	  GTMSGNUM = 0					! ERROR FLAG.
	  RETURN
	ENDIF
C
C NEGATE GTMSGNUM AS 'FREE' FLAG.
C
	IF (I4MSGTAB(SEGLEN, GTMSGNUM) .LE. 0) GTMSGNUM = -GTMSGNUM
C
	RETURN
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C WRITE MSGBUF INTO MSGCOM OR DISCIMG:
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE WRITMSG(IMGCHR, MSGNUM, MSGBUF)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
C
	INTEGER*4	CURSOR,
     *			FREESEG,
     *			LENGTH,
     *			LOCMSG,
     *			MSGNUM,
     *			NEXTSEG
C
        CHARACTER*(MSGSZH*2) IMGCHR(*)
C
	CHARACTER*(*)	MSGBUF
C
	LOCMSG = MSGNUM					! LOCAL COPY

C
	IF (I4MSGTAB(SEGLEN, LOCMSG) .GT. 0) CALL FLXDELETE(LOCMSG)
	IMGCHR(LOCMSG)(:MIN(LEN(MSGBUF), MSGLST)) = MSGBUF
	IF (LEN(MSGBUF) .LE. MSGLST) GOTO 20		! SET NULL LINK & EXIT.
C
	DO 10 CURSOR = MSGLST + 1, LEN(MSGBUF), MSGLST
	  NEXTSEG = FREESEG()
	  IF (NEXTSEG .LE. 0) THEN
	    WRITE(6, *) 'ERROR: OUT OF SPACE. MESSAGE PARTIALLY WRITTEN.'
	    GOTO 20 					! SET NULL LINK & EXIT.
	  ENDIF
	  I4MSGTAB(MSGLNK, LOCMSG) = NEXTSEG		! SET LINK.
	  LOCMSG = NEXTSEG
	  LENGTH = LEN(MSGBUF) - CURSOR + 1
	  IMGCHR(LOCMSG)(:MIN(MSGLST, LENGTH)) =
     *    MSGBUF(CURSOR: CURSOR + MIN(MSGLST, LENGTH) - 1)
	  I4MSGTAB(SEGLEN, LOCMSG) = MIN(LENGTH, MSGLST)
10	CONTINUE
C
C WAIT UNTIL NOW TO SET LENGTH OF FIRST SEGMENT IN ORDER TO LOCK
C MESSAGE UNTIL IT IS COMPLETELY WRITTEN, TO MAINTAIN INTEGRITY:
C
20	I4MSGTAB(SEGLEN, MSGNUM) = MIN(MSGLST, LEN(MSGBUF))
	I4MSGTAB(MSGLNK, LOCMSG) = 0			! LAST / ONLY SEGMENT.
C
	RETURN
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C READ MESSAGE FROM MSGCOM OR DISCIMG INTO MSGBUF:
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE READMSG(IMGCHR, MSGNUM, MSGBUF, MSGLEN)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
C
	INTEGER*4	LENGTH,
     *			LOCMSG,
     *			MSGLEN,
     *			MSGNUM
C
	CHARACTER*(*)	MSGBUF
	CHARACTER*64	IMGCHR(*)
C
	LOCMSG = MSGNUM					! LOCAL COPY OF MSGNUM.
	MSGLEN = 0
10	LENGTH = I4MSGTAB(SEGLEN, LOCMSG)
	MSGBUF(MSGLEN+1: MSGLEN+LENGTH) = IMGCHR(LOCMSG)(:LENGTH)
	MSGLEN = MSGLEN + LENGTH
C
	IF (MSGLEN .GT. LEN(MSGBUF))THEN
	  WRITE(6, *) 'ERROR: MESSAGE TOO BIG, TRUNCATED TO FIT.'
	  RETURN
	ENDIF
C
	LOCMSG = I4MSGTAB(MSGLNK, LOCMSG)			! LOCMSG = NEXT SEGMENT.
	IF (LOCMSG .LE. 0) RETURN			! NO MORE SEGMENTS.
	GOTO 10						! CONTINUE.
C
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C READ MESSAGE INTO BUFFER, DISPLAY MESSAGE BUFFER:
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE TYPEMSG(MSGNUM, MSGBUF, MSGLEN)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
C
	INTEGER*4	C,
     *			CURSOR,
     *			J,
     *			LASTSEG,
     *			MSGLEN,
     *			MSGNUM,
     *			NUMSEGS
C
	CHARACTER*(*)	MSGBUF
C
	CALL READMSG(MSGCHR, MSGNUM, MSGBUF, MSGLEN)
C
	ENTRY TYPEBUF(MSGBUF, MSGLEN)			! JUST TYPE BUFFER.
C
	CURSOR  = 1
	NUMSEGS = MSGLEN / 30
	LASTSEG = MOD(MSGLEN, 30)
C
C DISPLAY BUFFER IN 30-CHAR SEGS.
C
	DO 10 J = 1, NUMSEGS
	  WRITE(6, 19) J, (MSGBUF(C: C), C = CURSOR, CURSOR + 29)
19	  FORMAT(1X, I2, 1X, 30(Z2, 1X))
	  CURSOR = CURSOR + 30
10	CONTINUE
C
	IF (LASTSEG .GT. 0) WRITE(6, 19 ) NUMSEGS + 1,
     *    (MSGBUF(C: C), C = CURSOR, CURSOR + LASTSEG - 1)
C
	RETURN
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C DELETE MESSAGE #MSGNUM AND FREE ITS SEGMENTS:
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE FLXDELETE(MSGNUM)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
C
	INTEGER*4 	LINK,
     *			LOCMSG,
     *			MSGNUM
C
C
	LOCMSG = MSGNUM					! LOCAL COPY OF MSGNUM.
	I4MSGTAB(SEGLEN, LOCMSG) = 0			! FREE BASE SEGMENT.
	LINK = I4MSGTAB(MSGLNK, LOCMSG)			! GET LINK, IF ANY.
	I4MSGTAB(MSGLNK, LOCMSG) = 0			! CLEAR LINK.
C
10	IF (LINK .GT. 0) THEN				! IF ANOTHER SEGMENT
	  LOCMSG = LINK					! MAKE IT CURRENT SEG.
	  LINK = I4MSGTAB(MSGLNK, LOCMSG)			! SAVE LINK.
	  I4MSGTAB(MFRLNK, LOCMSG) = I4MSGTAB(MFRLNK, MSGCTL) 	! ADD TO CHAIN.
	  I4MSGTAB(MFRLNK, MSGCTL) = LOCMSG
	  I4MSGTAB(MFRCNT, MSGCTL) = I4MSGTAB(MFRCNT, MSGCTL) + 1	! INC. COUNT.
	  GOTO 10					! CONTINUE UNTIL ALL
	ENDIF						! SEGS FREED.
C
	RETURN
	END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C REMOVE FREE SEGMENT FROM FREE LIST AND RETURN ITS NUMBER AS
C FUNCTION VALUE, 0 IF NO FREE SEGMENTS LEFT:
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	INTEGER*4 FUNCTION FREESEG
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
C
	FREESEG = I4MSGTAB(MFRLNK, MSGCTL)		! OBTAIN FREE SEGMENT.
C
	IF (FREESEG .GT. 0) THEN
	  I4MSGTAB(MFRLNK, MSGCTL) = I4MSGTAB(MFRLNK, FREESEG)	! ADJUST LIST.
	  I4MSGTAB(MFRCNT, MSGCTL) = I4MSGTAB(MFRCNT, MSGCTL) - 1	! INC. COUNT.
	ENDIF
C
	RETURN
	END
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C	CALL DLLFILENUM(FILE_NO,APPLICATION_NO,APPLICATION_TYPE,STATUS)
C
C	GET NEXT FILE TO PROCESS
C
	SUBROUTINE DLLFILENUM(FILE_NO, APPLICATION_NO, 
     *				       APPLICATION_TYPE,STATUS)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:PRMDLL.DEF'
C
	INTEGER*4   FILE_NO	    !LAST FILE PROCESSED, 0 IF NONE 
	INTEGER*4   APPLICATION_NO  !APPLICATION NO 
	INTEGER*4   APPLICATION_TYPE	    !APPLICATION TYPE
	INTEGER*4   STATUS	    !RETURN STATUS
	INTEGER*4   CURRENT_MCP /0/
	INTEGER*4   FILE, NEXT_FILE
	INTEGER*4   DLLFIL(2,MAXLOADS,MAXAPP)	      !FILE NAMES
C
	INTEGER*2   DLLATR(MAXLOADS, MAXDLLTAB,MAXAPP)    !FILE ATRIBUTES
C
	LOGICAL	    LAST_MCP	
C
	SAVE CURRENT_MCP, LAST_MCP
C
	COMMON /ALLDLLCOM/ DLLFIL,DLLATR
	
	STATUS=0	!ASSUME RETURNED WITH SUCCESS

C
C	IF FIRST TIME DEFAULT TO FIRST MCP
C
	IF (APPLICATION_NO.LE.0) THEN
C
C           LOAD FIRST MCP NAME
C
	    CURRENT_MCP = 1
	    FILE_NO = 1
	    APPLICATION_NO = 1
	    APPLICATION_TYPE = MCP_TYPE
	    DLLFIL(1,1,APPLICATION_NO) = MCPNAM(CURRENT_MCP)
	    DLLFIL(2,1,APPLICATION_NO) = 0
	    IF (DLLFIL(1,1,APPLICATION_NO).EQ.0) GOTO 200
	    LAST_MCP=.TRUE.
	    DLLATR(FILE_NO, APPTYPE, APPLICATION_NO)=APPLICATION_TYPE
	    GOTO 10000
	ENDIF
C
C	IF LAST PROCESSED MCP, NOW IT IS A TIME FOR ACL
C
	IF (LAST_MCP) THEN
	    FILE_NO = 2
	    LAST_MCP = .FALSE.
	    APPLICATION_TYPE = ACL_TYPE
	    DLLFIL(1,FILE_NO,APPLICATION_NO)=ACLNAM(CURRENT_MCP)		
	    DLLFIL(2,FILE_NO,APPLICATION_NO)=0
C
C	    CHECK IF ACL EXISTS, IF NOT TRY TO USE FCL
C
	    IF (ACLNAM(CURRENT_MCP).EQ.0) THEN
		FILE_NO = FCL_LOAD_NO
		APPLICATION_TYPE=FCL_TYPE
		DLLFIL(1,FILE_NO,APPLICATION_NO)=FCLNAM(CURRENT_MCP)
		DLLFIL(2,FILE_NO,APPLICATION_NO)=0
		IF (DLLFIL(1,FILE_NO,APPLICATION_NO).EQ.0) THEN
		    TYPE *,'Invalid FCL name for the MCP ',CURRENT_MCP
		    DLLFIL(1,FILE_NO,APPLICATION_NO)=0
		    STATUS=-1
		ENDIF
	    ENDIF		
	    DLLATR(FILE_NO, APPTYPE, APPLICATION_NO)=APPLICATION_TYPE
	    GOTO 10000
	ENDIF
C
C	NOW IT SHOULD BE EITHER APPLICATION OR FCL LOAD (IF ACL USED)
C
	NEXT_FILE = FILE_NO + 1
C
	DO 100 FILE = NEXT_FILE, MAXLOADS
	  IF (DLLFIL(1,FILE,APPLICATION_NO).EQ.0) GOTO 100!SKIP NOT DEFINED FILES
	  FILE_NO = FILE
	  APPLICATION_TYPE=DLLATR(FILE_NO,APPTYPE,APPLICATION_NO)
	  GOTO 10000
100	CONTINUE
C
C	TRY TO GET NEXT APPLICATION 
C
200	CONTINUE
	APPLICATION_NO = APPLICATION_NO+1
C
C	IF ALL PROCESSED
	IF (APPLICATION_NO .GT. MAXAPP) THEN
	  STATUS=1
	  GOTO 10000
	ENDIF
C
C	CHECK IF FCL ALREADY DEFINED (FROM MULTI FCL LOAD)
C
	IF (DLLFIL(1,FCL_LOAD_NO,APPLICATION_NO).NE.0) THEN
	  FILE_NO=FCL_LOAD_NO
	  APPLICATION_TYPE=DLLATR(FILE_NO,APPTYPE,APPLICATION_NO)
	  GOTO 10000
	ENDIF
C
C	TRY TO GET NEXT MCP (IF MANY DIFFERENT MCPS DEFINED)
C
	IF (APPLICATION_NO.LT.SFT_APP_NO) THEN
          CURRENT_MCP=CURRENT_MCP+1
          IF (CURRENT_MCP.GT.MAXMCP)    GOTO 200
          IF (MCPNAM(CURRENT_MCP).EQ.0) GOTO 200
          FILE_NO=1
          APPLICATION_TYPE=MCP_TYPE
          DLLFIL(1,1,APPLICATION_NO)=MCPNAM(CURRENT_MCP)
          DLLFIL(2,1,APPLICATION_NO)=0
          LAST_MCP=.TRUE.
          GOTO 10000
	ENDIF
C
C	TRY TO GET  GVT LOAD
C
	IF (DLLFIL(1,1,APPLICATION_NO).EQ.0) GOTO 200
	FILE_NO=1
	APPLICATION_TYPE=DLLATR(FILE_NO,APPTYPE,APPLICATION_NO)
        TYPE *,' APPTYE = ',APPLICATION_TYPE
	GOTO 10000
C
10000	CONTINUE
	RETURN
	END	
C
C
	SUBROUTINE UPDATE_SMF(NEWLOADS,NEXTADDR)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
        INCLUDE 'INCLIB:MSGCOM.DEF'
        INCLUDE 'INCLIB:PRMDLL.DEF'
C
	INTEGER*4 MSGLEN
        INTEGER*4 NEXTADDR
        INTEGER*4 J,K,YESNO_FLAG
        INTEGER*4 LAST_MCP_REV,LAST_MCP_REV1
        INTEGER*4 NEWLOADS, DUMMY, NEXT_APPLICATION  
	INTEGER*4 DLLFIL(2, MAXLOADS, MAXAPP)
	INTEGER*2 DLLATR(MAXLOADS, MAXDLLTAB, MAXAPP)
C
	CHARACTER*1000	MSGBUF
	CHARACTER*68 MSGCHR_SAVE(MSGSIZ)
C
        LOGICAL   TO_CREATE_NEWS_MESSAGE
C
	COMMON /ALLDLLCOM/ DLLFIL,DLLATR
C
C	CREATE A NEWS MESSAGE 
C
	TO_CREATE_NEWS_MESSAGE=.TRUE.
	IF (I4MSGTAB(MFRCNT,MSGCTL).NE.0) THEN 
           IF (I4MSGTAB(SEGLEN,MNEWS).NE.0) THEN
	       TO_CREATE_NEWS_MESSAGE=.FALSE.
	       CALL READMSG(MSGCHR_SAVE,MNEWS,MSGBUF,MSGLEN)
	   ENDIF
           IF (I4MSGTAB(SEGLEN,GVTNEWS).NE.0) THEN
	       TO_CREATE_NEWS_MESSAGE=.FALSE.
	       CALL READMSG(MSGCHR_SAVE,GVTNEWS,MSGBUF,MSGLEN)
	   ENDIF
	ENDIF
C
	DO 1000  NEXT_APPLICATION = 1,MAXAPP
          DO 500 J = 1, MAXLOADS
C
C           IF NO NEWLOADS HAVE BEEN PROCESSED THEN ?????
C           (WHY PROCESS ANYTHING ???)
C
	    IF (NEWLOADS .EQ. 0) DLLATR(J, SNDFLG, NEXT_APPLICATION) 
     *				 = SMFDLTAB(J, SNDFLG, NEXT_APPLICATION)
C
C           SAVE LOAD ATTRIBUTE TABLE 
C
	    DO 250 K = 1, MAXDLLTAB
	      SMFDLTAB(J, K,NEXT_APPLICATION) = DLLATR(J, K, NEXT_APPLICATION)
250	    CONTINUE
C
C           SAVE APPLICATION NAME (1 = NAME, 2 = REVISION) 
C
	    SMFDLNAM(1,J,NEXT_APPLICATION)   = DLLFIL(1,J,NEXT_APPLICATION)
	    SMFDLNAM(2,J,NEXT_APPLICATION)   = DLLFIL(2,J,NEXT_APPLICATION)
500       CONTINUE
1000    CONTINUE
C
C
C	SET BACKGROUND/FORGROUND FLAG AND ROMREV
C
	DO 1500 NEXT_APPLICATION = 1,SFT_APP_NO-1
C
C         SET ROMREV FOR MCP IF FCL EXISTS
C
	  IF (SMFDLTAB(MCP_LOAD_NO,NBRSEG,NEXT_APPLICATION).NE.0) THEN
	    LAST_MCP_REV=SMFDLTAB(MCP_LOAD_NO,DLL_ROMREV,NEXT_APPLICATION)
	    LAST_MCP_REV1=SMFDLTAB(MCP_LOAD_NO,DLL_ROMREV1,NEXT_APPLICATION)
	  ENDIF
C
	  IF (SMFDLTAB(FCL_LOAD_NO,NBRSEG,NEXT_APPLICATION).NE.0) THEN
	    SMFDLTAB(MCP_LOAD_NO,DLL_ROMREV,NEXT_APPLICATION)=LAST_MCP_REV
	    SMFDLTAB(MCP_LOAD_NO,DLL_ROMREV1,NEXT_APPLICATION)=LAST_MCP_REV1
	  ENDIF
C
C	  SET FORGROUND BACKGROUND FLAG
C         THIS IS DETERMINED BY EXAMINING EACH LOAD INDIVIDUALLY AND DETERMINING IF AN
C         A UNIQUE MCP EXISTS FOR THIS APPLICATION. IF AN MCP DOES NOT EXIST FOR THIS
C         APPLICATION THEN IT MUST BE IN BACKGROUND.  
C
	  DO 1250 J = 1, MAXLOADS
	    IF (SMFDLTAB(J,NBRSEG,NEXT_APPLICATION).EQ.0) GOTO 1250
C
	    SMFDLTAB(J,FOREGROUND_FLAG,NEXT_APPLICATION)=FOREGROUND_LOAD
	    IF (SMFDLTAB(MCP_LOAD_NO,NBRSEG,NEXT_APPLICATION).EQ.0)
     *	        SMFDLTAB(J,FOREGROUND_FLAG,NEXT_APPLICATION)=
     *						      BACKGROUND_LOAD
1250	  CONTINUE
C
1500	CONTINUE
C
C       LOAD SMF WITH RESETS AND NEWS MESSAGES
C
	CALL BLDHRS(HRESET)				! BUILD HARD RESET
	CALL BLDSRS(SRESET)				! BUILD SOFT RESET
	CALL BLDURS(URESET)				! BUILD ULTIMATE RESET
	CALL BLDRRS(RRESET)				! BUILD RESTART  RESET
	IF (TO_CREATE_NEWS_MESSAGE) THEN
	  CALL BLDNWS(MNEWS)				!BUILD ONLINE NEWS MES
          CALL BLDNWS(TVNEWS)                           !BUILD TV NEWS MESSAGE
	  CALL BLDNWS(GVTNEWS)				!BUILD GVT NEWS MESSAG
	ELSE
	  CALL WRITMSG(MSGCHR_SAVE,MNEWS,MSGBUF(1:158))   !SAVE ONLINE NEWS MES
	  CALL WRITMSG(MSGCHR_SAVE,GVTNEWS,MSGBUF(201:320)) !SAVE GVT NEWS
	ENDIF
C
C       INFORM USER OF CHANGES
C
	CALL SPCDLL(DUMMY)
	TYPE *, ' '
	TYPE *, '*********************************************'
	TYPE *, ' Hard, soft and ultimate reset messages built'
	TYPE *, ' News message preserved'
	TYPE *, ' There are ',I4MSGTAB(MFRCNT,MSGCTL),' overflows available.'
	TYPE *, ' Next available message # = ',NEXTADDR,' out of ',MSGS
	TYPE *, ' Number of new loads:  ',NEWLOADS
	TYPE *, '*********************************************'
C
C
	CALL WIMG(5,'Do you want to save to SMF file ?')
	CALL YESNO(YESNO_FLAG)
	IF (YESNO_FLAG.EQ.1) THEN
	    CALL SAVESMF(3)
	ENDIF
C
	CALL WIMG(5,'Do you want to update commons ?')
	CALL YESNO(YESNO_FLAG)
	IF (YESNO_FLAG.EQ.1) THEN
	    CALL LOADSMF(3)
	ENDIF
C
       RETURN
       END
