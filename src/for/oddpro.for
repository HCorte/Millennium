C PROGRAM ODDPRO
C  
C V19 21-JUN-2001 JHR Checksum & sequence # update for cancellations moved here.
C V18 25-JAN-2001 UXN All cancellations are now 2 phase transactions.
C V17 04-OCT-2000 UXN GLOBAL RFSS #91
C V16 26-JUN-2000 OXK BTEST -> TSBIT
C V15 05-JUN-2000 OXK  SSOREC removed           
C V14 14-MAY-1999 UXN  Super Triple added.
C V13 29-MAR-1999 UXN&WS FIX FOR FAILURE TO READ FROM TMF IN CASE
C                        IF ORIGINAL WAGER RECORD NOT WRITTEN YET BY APULOG
C V12 18-MAR-1999 RXK  Game type/game index change.
C V11 29-JAN-1999 UXN  Fractions and unfractions added.
C V10 21-MAY-1996 HXK  Updates from Mike Pindrik for TEBE
C V09 23-NOV-1995 PXB  Couple and Double games added
C V08 02-SEP-1994 HXK  Merge of May,June RFSS batch
C V07 21-MAY-1994 HXK  CHANGE CHECK FOR 2 BYTE CHECKSUM; CHECK FOR LSTSER.EQ.0 
C V06 03-SEP-1993 HXK  Removed supression of priv ter wagering
C V05 19-JUL-1993 GXA  Released for Finland Dec Conversion / Oddset
C V04 08-JUL-1992 GCAN CHECK KICKER (Y/N) FLAG, BEFORE SUPPRESSION DECISION.
C V03 24-MAY-1992 HDB  ADDED UPDSTA (STATISTICS)
C V02 07-OCT-1991 MTK  INITAL RELEASE FOR NETHERLANDS
C V01 01-AUG-1990 XXX  RELEASED FOR VAX
C
C ODDSET GAMES WAGER PROCESSING TASK
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 2000 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM ODDPRO
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:AGTCOM.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:PRMLOG.DEF'
	INCLUDE 'INCLIB:CHKSUMCM.DEF'	
	INCLUDE 'INCLIB:SCRCOM.DEF'
	INCLUDE 'INCLIB:WITCOM.DEF'
	INCLUDE 'INCLIB:DBLCOM.DEF'
	INCLUDE 'INCLIB:CPLCOM.DEF'
	INCLUDE 'INCLIB:SSCCOM.DEF'
	INCLUDE 'INCLIB:TRPCOM.DEF'
	INCLUDE 'INCLIB:STRCOM.DEF'
	INCLUDE 'INCLIB:TSLCOM.DEF'
	INCLUDE 'INCLIB:KIKCOM.DEF'
C
	INTEGER*4 MESS(EDLEN),LOGREC(LREC*3),WRKBUF(TRALEN)
	INTEGER*4 ERCODE, I, ST, LSTSER, ENCMES, ENCACT, KGAM
	INTEGER*4 GAME, AGAME, GTYP, TYPE, TER, BUF, STATUS
	INTEGER*4 TASK
	INTEGER*4 KIND
C
	INTEGER*4 SIMOUTTAB(40)
	INTEGER*2 SIMOUTLEN
C
        INTEGER*4  I4TEMP               ! rev 1.3
        INTEGER*2  I2TEMP(2)            ! rev 1.3
        EQUIVALENCE (I4TEMP,I2TEMP(1))  ! rev 1.3
C
	CALL COPYRITE
	CALL SNIF_AND_WRKSET
  
	TASK=ODD
	MESS(1)=TASK
5	CONTINUE
        BASECHKSUM=IAND(DAYCDC,'FFFF'X)
C
C WAIT FOR SOMETHING TO DO
C IF END OF DAY THEN CALL GSTOP(GEXIT_SUCCESS)
C
10	CONTINUE
	IF(DAYSTS.EQ.DSCLOS) CALL GSTOP(GEXIT_SUCCESS)
	IF(DAYSTS.EQ.DSSUSP) THEN
	  CALL HOLD(0,STATUS)
	  IF(DAYSTS.EQ.DSOPEN) GOTO 5
	  GOTO 10
	ENDIF
	CALL HOLD(0,STATUS)
C
C GET BUFFER NUMBER FROM TOP OF QUEUE.
C IF NO WAGERS QUEUED, GO BACK TO WAIT STATE.
C
20	CONTINUE
	CALL TOPQUE(TASK,BUF)
	IF(BUF.EQ.0) GOTO 10
C
C DECODE TERMINAL MESSAGE INTO INTERNAL TRANSACTION FORMAT
C
	TER =HPRO(TERNUM,BUF)
	TYPE=HPRO(TRCODE,BUF)
	IF(TYPE.EQ.TYPOCN.OR.TYPE.EQ.TYPODL) GOTO 1000
C
        IF(TYPE.EQ.TYPFRA) THEN                          ! FRACTIONS
            CALL FRACTWO(TRABUF,BUF,TASK)
	    CALL QUETRA(LOG,BUF)
            CALL DQUTRA(TASK,BUF)
            GOTO 20
        ENDIF
C
        IF(TYPE.EQ.TYPUNF) THEN                         ! UNFRACTIONS
            CALL UNFRACTWO(TRABUF,BUF,TASK)
	    CALL QUETRA(LOG,BUF)
            CALL DQUTRA(TASK,BUF)
            GOTO 20
        ENDIF
C
	CALL FASTSET(0,TRABUF,TRALEN)
	TRABUF(TSTAT)=GOOD
	TRABUF(TERR)=NOER
	TRABUF(TSUBERR)=NOER
	TRABUF(TTYP)=TWAG
	TRABUF(TCDC)=DAYCDC
	TRABUF(TCDC_SOLD)=DAYCDC
	TRABUF(TTER)=TER
	TRABUF(TSER)=PRO(SERIAL,BUF)
	TRABUF(TTIM)=PRO(TSTAMP,BUF)
	TRABUF(TSIZE)=HPRO(NUMLRC,BUF)
	TRABUF(TAGT)=AGTTAB(AGTNUM,TER)
C
	GTYP = BPRO(BINPTAB+5,BUF)
	IF(GTYP.EQ.TSCR) THEN
	  CALL DSCORE(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
	ELSEIF(GTYP.EQ.TWIT) THEN
	  CALL DWIT(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
	ELSEIF(GTYP.EQ.TDBL) THEN
	  CALL DDOUBLE(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
	ELSEIF(GTYP.EQ.TCPL) THEN
	  CALL DCOUPLE(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
	ELSEIF(GTYP.EQ.TSSC) THEN
	  CALL DSSCORE(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
	ELSEIF(GTYP.EQ.TTRP) THEN
	  CALL DTRIPLE(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
	ELSEIF(GTYP.EQ.TSTR) THEN
	  CALL DSTRIPLE(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
	ELSE
	  CALL DTSEL(PRO(INPTAB,BUF),TRABUF,HPRO(INPLEN,BUF))
        ENDIF
C
C CHECK IF TRANSACTION TYPE IS SUPRESSED ON
C AGENT AND GLOBAL LEVELS
C
        AGAME=0
        GAME=TRABUF(TGAM)
        IF(GAME.NE.0) AGAME=AGTGAM(GFLAGS,GAME,TER)
	IF(TSBIT(AGTTAB(AGTTYP,TER),AGTWAG))   TRABUF(TERR)=SUPR
C***	IF(TSBIT(AGTTAB(AGTTYP,TER),AGTPRV))   TRABUF(TERR)=SUPR !not in Finland
	IF(TSBIT(AGAME,AGTWAG))                TRABUF(TERR)=SUPR
	IF(TSBIT(P(SUPGWA),GAME))              TRABUF(TERR)=SUPR
	IF(P(SUPWAG).NE.0)                     TRABUF(TERR)=SUPR
C
C CHECK AGENT AND SYSTEM STATUS
C
	IF(AGTHTB(AOPSTS,TER).NE.SIGNON)       TRABUF(TERR)=NOTON
	IF(P(SYSSTS).EQ.SYSDRW)                TRABUF(TERR)=SDRW
	IF(P(SYSSTS).EQ.SYSDOR)                TRABUF(TERR)=SDOR
C
C IF KICKER BET THEN CHECK IF SUPRESSED
C
	KGAM=TRABUF(TWKGME)
	IF(TRABUF(TWKFLG).EQ.0) KGAM = 0
	IF(KGAM.NE.0) THEN
	  AGAME=AGTGAM(GFLAGS,KGAM,TER)
	  IF(TSBIT(AGAME,AGTWAG))              TRABUF(TERR)=SUPR
	  IF(TSBIT(P(SUPGWA),KGAM))            TRABUF(TERR)=SUPR
	ENDIF
C
C CHECK FOR DES ERROR
C
	IF(P(DESACT).EQ.0) THEN
	  ENCMES = BPRO(BINPTAB,BUF)
	  ENCMES = IAND(ENCMES,'08'X)
	  IF(P(DESFLG).EQ.0.AND.
     *	     TSBIT(AGTTAB(AGTTYP,TER),AGTDES)) THEN
	    ENCACT = '08'X
	  ELSE
	    ENCACT = 0
	  ENDIF
	  IF(ENCMES.NE.ENCACT) TRABUF(TERR)=DESMOD
	ENDIF
	IF(TRABUF(TERR).NE.NOER) TRABUF(TSTAT)=REJT
C
C IF TERMINAL RETRY, AND TRANSACTION STATUS IS GOOD, AND
C TRANSACTION SEQUENCE NUMBER MATCHES THE LAST SEQUENCE
C NUMBER FOR THIS TERMINAL, CONTINUE RETRY PROCESSING, ELSE
C PROCESS AS NORMAL.
C

        LSTSER = AGTTAB(ALSTRA,TER)          ! rev 1.3
        IF(LSTSER.EQ.0) GOTO 80              ! rev 1.3

	IF(HPRO(SIMMOD,BUF).EQ.-999) GOTO 80	!NO RETRIES FOR SIM
	IF(TRABUF(TTRN).EQ.AGTHTB(ATRNUM,TER)) THEN

          IF(TRABUF(TCHK).NE.ZEXT(AGTHTB(ACHKSM,TER))) THEN    

	    LSTSER=AGTTAB(ALSTRA,TER)
	    CALL RLOG(LSTSER,LOGREC,TASK,ST)
CV13
	    IF (ST.NE.0) THEN
		CALL WAIT_APUQUE
      		CALL RLOG(LSTSER,LOGREC,TASK,ST)
	    ENDIF
CEV13
	    IF(ST.NE.0) GOTO 80
	    CALL LOGTRA(WRKBUF,LOGREC)
	    IF(WRKBUF(TTYP).NE.TWAG)             GOTO 80
	    IF(WRKBUF(TTRN).NE.TRABUF(TTRN))     GOTO 80
	    IF(WRKBUF(TGAM).NE.TRABUF(TGAM))     GOTO 80
	    IF(WRKBUF(TWAMT).NE.TRABUF(TWAMT))   GOTO 80
	    DO 40 I=TWBORD,TWBEND
	      IF(WRKBUF(I).NE.TRABUF(I))         GOTO 80
40	    CONTINUE
            IF(TRABUF(TWBEG).GT.WRKBUF(TWBEG)) THEN
                IF(TRABUF(TTIM)-WRKBUF(TTIM).GT.60) GOTO 80
                IF(WRKBUF(TGAMTYP).EQ.TSCR) THEN
                   IF(SCRSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                IF(WRKBUF(TGAMTYP).EQ.TWIT) THEN
                   IF(WITSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                IF(WRKBUF(TGAMTYP).EQ.TDBL) THEN
                   IF(DBLSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                IF(WRKBUF(TGAMTYP).EQ.TCPL) THEN
                   IF(CPLSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                IF(WRKBUF(TGAMTYP).EQ.TSSC) THEN
                   IF(SSCSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                IF(WRKBUF(TGAMTYP).EQ.TTRP) THEN
                   IF(TRPSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                IF(WRKBUF(TGAMTYP).EQ.TSTR) THEN
                   IF(STRSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                IF(WRKBUF(TGAMTYP).EQ.TTSL) THEN
                   IF(TSLSTS(WRKBUF(TGAMIND)).GT.GAMBFD) GOTO 80
                ENDIF
                TRABUF(TWBEG) = WRKBUF(TWBEG)
                TRABUF(TWEND) = WRKBUF(TWEND)
            ENDIF
            IF(KGAM.NE.0.AND.TRABUF(TWKBEG).GT.WRKBUF(TWKBEG)) THEN
                IF(TRABUF(TTIM)-WRKBUF(TTIM).GT.60) GOTO 80
                KIND = GNTTAB(GAMIDX,KGAM)
                IF(KIKSTS(KIND).GT.GAMBFD) GOTO 80
                TRABUF(TWKBEG) = WRKBUF(TWKBEG)
                TRABUF(TWKEND) = WRKBUF(TWKEND)
            ENDIF
	    IF(WRKBUF(TWBEG).NE.TRABUF(TWBEG))   GOTO 80
	    IF(WRKBUF(TWEND).NE.TRABUF(TWEND))   GOTO 80
	  ENDIF
	  IF(TRABUF(TWKGME).NE.0) TRABUF(TWKICK)=AGTTAB(AGTLKN,TER)
	  TRABUF(TSTAT)=REJT
	  TRABUF(TERR )=RETY
	  CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
	  TRABUF(TSER)  = AGTTAB(ALSTRA,TER)
	  TRABUF(TSTAT) = GOOD
	  TRABUF(TERR)  = NOER
	  TRABUF(TWKICK)=AGTTAB(AGTLKN,TER)
	  CALL OUTWAG(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
	  GOTO 90
	ENDIF
C
C UPDATE POOL AND FINANCIAL INFORMATION
C
80	CONTINUE
	IF(TRABUF(TSTAT).EQ.GOOD) CALL UPDPOL(TRABUF)
	IF(TRABUF(TSTAT).EQ.GOOD) THEN
	  CALL UPDSUB(TRABUF)
	  CALL UPDSTA(TRABUF)
	  PERFRM(1,GAME)=PERFRM(1,GAME)+1
	ENDIF
	CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
	IF(TRABUF(TERR).EQ.TBAD) HPRO(ENCOVR,BUF)=-1
	IF(HPRO(SIMMOD,BUF).EQ.-999) THEN
	  CALL OUTWAG(TRABUF,SIMOUTTAB,SIMOUTLEN)   !DON'T DESTROY INPUT
	ELSE
	  CALL OUTWAG(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
	ENDIF
C
C IF SYNTAX ERROR THEN PRINT ERROR CODE
C ON THE CONSOLE.
C
	IF(P(SUPSYN).EQ.0.AND.SYNTERRCOD.NE.0.AND.
     *	   TRABUF(TERR).NE.NOTON) THEN
	  MESS(2)=TEGEN
	  MESS(3)=10
	  MESS(4)=SYNTERRCOD
	  MESS(5)=TER
	  MESS(6)=TRABUF(TGAMTYP)
	  MESS(7)=TRABUF(TGAMIND)
	  MESS(8)=TRABUF(TSER)
	  CALL QUEMES(MESS)
	ENDIF
C
C QUEUE TRANSACTION TO APU LOGGER QUEUE
C
90	CONTINUE
	AGTHTB(ATRNUM,TER)=TRABUF(TTRN)
	IF(TRABUF(TSTAT).NE.GOOD.AND.TRABUF(TERR).NE.RETY) THEN
	  AGTHTB(ACHKSM,TER)=-1
	ELSE
	  AGTHTB(ACHKSM,TER)=TRABUF(TCHK)
	ENDIF
	CALL QUETRA(APU, BUF)
	CALL DQUTRA(TASK,BUF)
	GOTO 20
C
C PROCESS ODDSET CANCELLATIONS AND DELETIONS.
C CANCELLATION AND WAGER ARE ENCODED IN THE WORK
C AREA OF THE PROCOM BUFFER (FROM CANPRO/INCPRO).
C UPDATE SALES DATA FOR ODDSET CANCELLATIONS.
C
1000	CONTINUE
	CALL LOGTRA(TRABUF,PRO(WRKTAB,BUF))
C 
        AGTHTB(ATRNUM,TER)=TRABUF(TTRN)        ! V19
        AGTHTB(ACHKSM,TER)=-1                  ! V19
C
	TERMCHKSUM = TRABUF(TCHK)
	ERCODE     = TRABUF(TSUBERR)

	IF(TRABUF(TSTAT).EQ.REJT) GOTO 1100

	CALL RLOG(TRABUF(TWCSER),LOGREC,TASK,STATUS)
CV13
	IF (STATUS.NE.0) THEN
	    CALL WAIT_APUQUE
      	    CALL RLOG(TRABUF(TWCSER),LOGREC,TASK,STATUS)
	ENDIF
CEV13
	CALL LOGTRA(WRKBUF,LOGREC)
	IF(STATUS.NE.0.OR.WRKBUF(TSER).NE.TRABUF(TWCSER)) THEN
	  TRABUF(TSTAT)=REJT
	  TRABUF(TERR)=INVL
	  CALL TRALOG(TRABUF,PRO(WRKTAB,BUF))
	  ERCODE=1
	ELSE
	  WRKBUF(TSTAT)=VOID
	  IF(TRABUF(TTYP).EQ.TINC) WRKBUF(TSTAT)=INCA
	  WRKBUF(TWCSER)=TRABUF(TSER)
	  WRKBUF(TWCTER)=TRABUF(TTER)
	  CALL TRALOG(WRKBUF,LOGREC)
	  CALL UPDSUB(TRABUF)
	  CALL UPDSTA(TRABUF)
	  CALL UPDPOL(TRABUF)
	  CALL WLOG(WRKBUF(TSER),LOGREC,TASK)
	  ERCODE=0
	ENDIF
C
1100	CONTINUE
C
	IF(TRABUF(TTYP).EQ.TCAN) THEN
	  IF(HPRO(SIMMOD,BUF).EQ.-999) THEN
	    CALL OUTCAN(TRABUF,SIMOUTTAB,SIMOUTLEN,ERCODE)
	  ELSE
	    CALL OUTCAN(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF),ERCODE)
	  ENDIF
	ELSE
	  CALL OUTDEL(TRABUF,PRO(OUTTAB,BUF),HPRO(OUTLEN,BUF))
	ENDIF
	HPRO(TRCODE,BUF)=TYPREG
	CALL QUETRA(APU, BUF)
	CALL DQUTRA(TASK,BUF)
	GOTO 20

900     FORMAT(1X,5A4,' - Open error   status - ',I2)

	END

