C GUI_028.FOR
C
C V03 09-MAY-2001 SKM Fixed read from disk.
C V02 22-MAR-2001 UXN Passive game added.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 2001 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C This subroutine returns GUI FUNCTION.
C
C Input parameters:
C	NONE               
C
C Output parameters:
C
C	BYTE		OUTBUF(*)    OUTPUT MESSAGE
C	INTEGER*4	MES_LEN	     MESSAGE LENGTH
C	INTEGER*4	RET_CODE:
C		0		-  no error, message accepted;
C		value >= 11	-  error number to be sent to Client.
C
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GUI_028(OUTBUF,MES_LEN,RET_CODE)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:GUIMPRM.DEF'
	INCLUDE 'INCLIB:GUIARGS.DEF'
	INCLUDE 'INCLIB:LTOCOM.DEF'
	INCLUDE 'INCLIB:SPTCOM.DEF'
	INCLUDE 'INCLIB:NBRCOM.DEF'
	INCLUDE 'INCLIB:TSLCOM.DEF'
	INCLUDE 'INCLIB:BNGCOM.DEF'
	INCLUDE 'INCLIB:KIKCOM.DEF'
	INCLUDE 'INCLIB:WITCOM.DEF'
	INCLUDE 'INCLIB:CPLCOM.DEF'
	INCLUDE 'INCLIB:TRPCOM.DEF'
	INCLUDE 'INCLIB:DBLCOM.DEF'
	INCLUDE 'INCLIB:STRCOM.DEF'
	INCLUDE 'INCLIB:SCRCOM.DEF'
	INCLUDE 'INCLIB:SSCCOM.DEF'
	INCLUDE 'INCLIB:DLTREC.DEF'
	INCLUDE 'INCLIB:DSPREC.DEF'
	INCLUDE 'INCLIB:DNBREC.DEF'
	INCLUDE 'INCLIB:DBNREC.DEF'
	INCLUDE 'INCLIB:DKKREC.DEF'
	INCLUDE 'INCLIB:DWIREC.DEF'
	INCLUDE 'INCLIB:DCPREC.DEF'
	INCLUDE 'INCLIB:DTRREC.DEF'
	INCLUDE 'INCLIB:DDBREC.DEF'
	INCLUDE 'INCLIB:DSTREC.DEF'
	INCLUDE 'INCLIB:DSCREC.DEF'
	INCLUDE 'INCLIB:DSSREC.DEF'
	INCLUDE 'INCLIB:DTSREC.DEF'
	INCLUDE 'INCLIB:DATBUF.DEF'
	INCLUDE 'INCLIB:DTGREC.DEF'
	INCLUDE 'INCLIB:TGLCOM.DEF'
	INCLUDE 'INCLIB:GUIFIL.DEF'
	INCLUDE 'INCLIB:PASCOM.DEF'
	INCLUDE 'INCLIB:DPAREC.DEF'
C
C
	BYTE	    OUTBUF(*)
	INTEGER*4   MES_LEN,RET_CODE
	INTEGER*2   DAT(LDATE_LEN)
	LOGICAL*4   DATA_TO_SEND
	CHARACTER*10 SPACES

	INTEGER*4   GAMREC
	EQUIVALENCE(GAMREC,DLTREC,DSPREC,DNBREC,DKKREC,DBNREC,DWIREC,
     *              DCPREC,DTRREC,DDBREC,DSTREC,DTSREC,DSCREC,DTGREC,
     *              DPAREC)
C
	INTEGER*4 NUM_COLS,NUM_ROWS, CURDRW_DAT, ABSOLUTE_CURDRW_DAT
C
        INTEGER*4  I,GNUM,GIND,GTYP,ST,DRAW, EMIOFF
	LOGICAL*4  ON_MEMORY 
C
	INTEGER*4 MAXADVDRW
	PARAMETER(MAXADVDRW = 10)
	INTEGER*4  GDATA(MAXADVDRW+1)
C
	RET_CODE = 0	
	SPACES = ' '	
	CALL GUI_GETPARAMS(OUTBUF,ST)
	IF(ST.NE.0) THEN
	    RET_CODE = 11
	    RETURN
	ENDIF
	GNUM = GUI_ARGVAL(1)
	DRAW = GUI_ARGVAL(2)
	IF(GNUM.LT.1.OR.GNUM.GT.MAXGAM) GNUM = 1
	GTYP = GNTTAB(GAMTYP,GNUM)
	GIND = GNTTAB(GAMIDX,GNUM)
C
	IF(GTYP.LT.1.OR.GTYP.GT.MAXTYP) THEN
	    RET_CODE = 11
	    RETURN
	ENDIF
	IF(GIND.LT.1.OR.GIND.GT.MAXIND) THEN
	    RET_CODE = 11
	    RETURN
	ENDIF
	IF(DRAW.LE.0) DRAW = DAYDRW(GNUM)
	IF(DRAW.LE.0) DRAW = MAX(1,DAYHDR(GNUM))
	CALL FASTSET(0,GDATA,(MAXADVDRW+1)*MAXGAM)
C
C GET DATA FROM COMMON OR DISK
C
	CURDRW_DAT = 0
	ABSOLUTE_CURDRW_DAT = 0
	IF(GTYP.EQ.TPAS) THEN
	  ON_MEMORY = .FALSE.
	  DO I = 1, PAGEMI
            IF(DRAW.EQ.PASEMIS(I,GIND)) THEN
                ON_MEMORY = .TRUE.
                EMIOFF = I
            ENDIF
          ENDDO
10	  CONTINUE
          IF (ON_MEMORY) THEN
              CALL GAMLOGPAS(EMIOFF,GIND,DPAREC,PASSTS)
	      CURDRW_DAT = DPAESD
          ELSE
	      GOTO 90
	  ENDIF
        ELSEIF(DRAW.EQ.DAYDRW(GNUM)) THEN
          IF(GTYP.EQ.TLTO) THEN
	     CALL GAMLOG(TLTO,GIND,DLTREC,LTOSTS)
	     CURDRW_DAT = DLTDAT(CURDRW)
          ELSEIF(GTYP.EQ.TSPT) THEN
	     CALL GAMLOG(TSPT,GIND,DSPREC,SPTSTS)
	     CURDRW_DAT = DSPDAT(CURDRW)
          ELSEIF(GTYP.EQ.TTGL) THEN
	     CALL GAMLOG(TTGL,GIND,DTGREC,TGLSTS)
	     CURDRW_DAT = DTGDAT(CURDRW)
          ELSEIF(GTYP.EQ.TKIK) THEN
	     CALL GAMLOG(TKIK,GIND,DKKREC,KIKSTS)
	     CURDRW_DAT = DKKDAT(CURDRW)
          ELSEIF(GTYP.EQ.TNBR) THEN
	     CALL GAMLOG(TNBR,GIND,DNBREC,NBRSTS)
	     CURDRW_DAT = DNBDAT(CURDRW)
          ELSEIF(GTYP.EQ.TBNG) THEN
	     CALL GAMLOG(TBNG,GIND,DBNREC,BNGSTS)
	     CURDRW_DAT = DBNDAT(CURDRW)
	  ELSEIF(GTYP.EQ.TWIT) THEN
	     CALL GAMLOG(TWIT,GIND,DWIREC,WITSTS)
	     CURDRW_DAT = DWIDAT
	  ELSEIF(GTYP.EQ.TCPL) THEN
	     CALL GAMLOG(TCPL,GIND,DCPREC,CPLSTS)
	     CURDRW_DAT = DCPDAT
	  ELSEIF(GTYP.EQ.TTRP) THEN
	     CALL GAMLOG(TTRP,GIND,DTRREC,TRPSTS)
	     CURDRW_DAT = DTRDAT
	  ELSEIF(GTYP.EQ.TDBL) THEN
	     CALL GAMLOG(TDBL,GIND,DDBREC,DBLSTS)
	     CURDRW_DAT = DDBDAT
	  ELSEIF(GTYP.EQ.TSTR) THEN
	     CALL GAMLOG(TSTR,GIND,DSTREC,STRSTS)
	     CURDRW_DAT = DSTDAT
	  ELSEIF(GTYP.EQ.TTSL) THEN
	     CALL GAMLOG(TTSL,GIND,DTSREC,TSLSTS)
	     CURDRW_DAT = DTSDTE
	  ELSEIF(GTYP.EQ.TSCR) THEN
	    CALL GAMLOG(TSCR,GIND,DSCREC,DSCSTS)
	    CURDRW_DAT = DSCDAT
	  ELSEIF(GTYP.EQ.TSSC) THEN
	    CALL GAMLOG(TSSC,GIND,DSSREC,SSCSTS)
	    CURDRW_DAT = DSSDAT
	  ELSE
	    RET_CODE = 11
	    RETURN
	  ENDIF
          GOTO 100
        ENDIF
C
90	CONTINUE	
C
	CALL READW(GAMFDB(1,GNUM),DRAW,GAMREC,ST)
	IF(ST.NE.0) THEN
	    CALL OPS('Failed to read '//CGFNAMES(GNUM),ST,DRAW)
	    RET_CODE = 11
	    RETURN
	ENDIF
C
100	CONTINUE
	IF(GTYP.EQ.TLTO) THEN
	     GDATA(1) = DLTDRW
	     CALL FASTMOV(DLTDAT,GDATA(2),MAXADVDRW)
             CURDRW_DAT = DLTESD
 	     CALL GAMLOG(TLTO,GIND,DLTREC,LTOSTS)
	     ABSOLUTE_CURDRW_DAT = DLTDAT(CURDRW)
	ELSEIF(GTYP.EQ.TSPT) THEN
	     GDATA(1) = DSPDRW
	     CALL FASTMOV(DSPDAT,GDATA(2),MAXADVDRW)
             CURDRW_DAT = DSPESD
 	     CALL GAMLOG(TSPT,GIND,DSPREC,SPTSTS)
	     ABSOLUTE_CURDRW_DAT = DSPDAT(CURDRW)
	ELSEIF(GTYP.EQ.TTGL) THEN
	     GDATA(1) = DTGDRW
	     CALL FASTMOV(DTGDAT,GDATA(2),MAXADVDRW)
             CURDRW_DAT = DTGESD
 	     CALL GAMLOG(TTGL,GIND,DTGREC,TGLSTS)
	     ABSOLUTE_CURDRW_DAT = DTGDAT(CURDRW)
	ELSEIF(GTYP.EQ.TKIK) THEN
	     GDATA(1) = DKKDRW
	     CALL FASTMOV(DKKDAT,GDATA(2),MAXADVDRW)
             CURDRW_DAT = DKKESD
 	     CALL GAMLOG(TKIK,GIND,DKKREC,KIKSTS)
	     ABSOLUTE_CURDRW_DAT = DKKDAT(CURDRW)
	ELSEIF(GTYP.EQ.TBNG) THEN
	     GDATA(1) = DBNDRW
	     CALL FASTMOV(DBNDAT,GDATA(2),MAXADVDRW)
             CURDRW_DAT = DBNESD
 	     CALL GAMLOG(TNBR,GIND,DNBREC,NBRSTS)
	     ABSOLUTE_CURDRW_DAT = DNBDAT(CURDRW)
	ELSEIF(GTYP.EQ.TNBR) THEN
	     GDATA(1) = DNBDRW
	     CALL FASTMOV(DNBDAT,GDATA(2),MAXADVDRW)
             CURDRW_DAT = DBNESD
	     CALL GAMLOG(TBNG,GIND,DBNREC,BNGSTS)
	     ABSOLUTE_CURDRW_DAT = DBNDAT(CURDRW)
	ELSEIF(GTYP.EQ.TWIT) THEN
	     GDATA(1) = DWIDRW
	     GDATA(2) = DWIDAT
             CURDRW_DAT = DWIESD
	     CALL GAMLOG(TWIT,GIND,DWIREC,WITSTS)
	     ABSOLUTE_CURDRW_DAT = DWIDAT
	ELSEIF(GTYP.EQ.TCPL) THEN
	     GDATA(1) = DCPDRW
	     GDATA(2) = DCPDAT
             CURDRW_DAT = DCPESD
	     CALL GAMLOG(TCPL,GIND,DCPREC,CPLSTS)
	     ABSOLUTE_CURDRW_DAT = DCPDAT
	ELSEIF(GTYP.EQ.TTRP) THEN
	     GDATA(1) = DTRDRW
	     GDATA(2) = DTRDAT
             CURDRW_DAT = DTRESD
	     CALL GAMLOG(TTRP,GIND,DTRREC,TRPSTS)
	     ABSOLUTE_CURDRW_DAT = DTRDAT
	ELSEIF(GTYP.EQ.TDBL) THEN
	     GDATA(1) = DDBDRW
	     GDATA(2) = DDBDAT
             CURDRW_DAT = DDBESD
	     CALL GAMLOG(TDBL,GIND,DDBREC,DBLSTS)
	     ABSOLUTE_CURDRW_DAT = DDBDAT
	ELSEIF(GTYP.EQ.TSTR) THEN
	     GDATA(1) = DSTDRW
	     GDATA(2) = DSTDAT
             CURDRW_DAT = DSTESD
	     CALL GAMLOG(TSTR,GIND,DSTREC,STRSTS)
	     ABSOLUTE_CURDRW_DAT = DSTDAT
	ELSEIF(GTYP.EQ.TTSL) THEN
	     GDATA(1) = DTSDRW
	     GDATA(2) = DTSDTE
             CURDRW_DAT = DTSESD
	     CALL GAMLOG(TTSL,GIND,DTSREC,TSLSTS)
	     ABSOLUTE_CURDRW_DAT = DTSDTE
	ELSEIF(GTYP.EQ.TSCR) THEN
	     GDATA(1) = DSCDRW
	     GDATA(2) = DSCDAT
             CURDRW_DAT = DSCESD
	     CALL GAMLOG(TSCR,GIND,DSCREC,DSCSTS)
	     ABSOLUTE_CURDRW_DAT = DSCDAT
	ELSEIF(GTYP.EQ.TSSC) THEN
	     GDATA(1) = DSSDRW
	     GDATA(2) = DSSDAT
             CURDRW_DAT = DSSESD
 	     CALL GAMLOG(TSSC,GIND,DSSREC,SSCSTS)
	     ABSOLUTE_CURDRW_DAT = DSSDAT
	ELSEIF(GTYP.EQ.TPAS) THEN
	     GDATA(1) = DRAW
	     GDATA(2) = DPAESD
	     ABSOLUTE_CURDRW_DAT = DPAESD
	ENDIF
C
C INITIALIZE OUTPUT 
C
	CALL GUIARG_INIT()
C
	NUM_COLS = 5
	NUM_ROWS = 1
	CALL GUIARG_NEXT_SET(OUTBUF,NUM_COLS)
	CALL GUIARG_INT2(OUTBUF,DAYCDC)
	CALL GUIARG_INT2(OUTBUF,DAYJUL)
	CALL GUIARG_INT2(OUTBUF,DAYDRW(GNUM))
	DAT(VCDC) = ABSOLUTE_CURDRW_DAT
	CALL LCDATE(DAT)
	IF(ABSOLUTE_CURDRW_DAT.EQ.0) THEN
	    CALL GUIARG_CHAR(OUTBUF,%REF(SPACES),10)
	    CALL GUIARG_INT2(OUTBUF,0)
	ELSE
	    CALL GUIARG_DATE(OUTBUF,DAT(VCDC))
	    CALL GUIARG_INT2(OUTBUF,DAT(VJUL))
	ENDIF
C
C RESULT SET 2
C
	NUM_COLS = 3
	NUM_ROWS = 10
	CALL GUIARG_NEXT_SET(OUTBUF,NUM_COLS)
	CALL LCDATE(DAT)
	DATA_TO_SEND = .FALSE.
        DO 500 I=1,MAXADVDRW
	   IF(GDATA(1+I).LE.0) GOTO 500
	   DATA_TO_SEND = .TRUE.
	   DAT(VCDC) = GDATA(1+I)
	   CALL LCDATE(DAT)
	   CALL GUIARG_INT2(OUTBUF,GDATA(1)+I-1)
	   IF(DAT(VCDC).EQ.0) THEN
	     CALL GUIARG_CHAR(OUTBUF,%REF(SPACES),10)
	     CALL GUIARG_INT2(OUTBUF,0)
	   ELSE
	     CALL GUIARG_DATE(OUTBUF,DAT(VCDC))
	     CALL GUIARG_INT2(OUTBUF,DAT(VJUL))
	   ENDIF
500	CONTINUE
	IF(.NOT.DATA_TO_SEND) THEN
	   CALL GUIARG_NO_DATA(OUTBUF,NUM_COLS)
	ENDIF
C
C FINALLY SET OUTPUT MESSAGE LENGTH 
C
	CALL GUIARG_SET_MESLEN(MES_LEN)
C
	RETURN
C
	END
