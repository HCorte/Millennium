C SPTCANEVTLIB.FOR
C
C CANCEL EVENTS LIBRARY
C
C     **************************************************************************
C
C        THIS ITEM IS THE PROPERTY OF GTECH CORPORATION, POVIDENCE, RHODE
C     ISLAND, AND CONTAINS CONFIDENTIAL AND TRADE SECRET INFORMATION. IT MAY
C     NOT BE TRANSFERRED FROM THE CUSTODY OR CONTROL OF GTECH EXCEPT AS AUTO -
C     RIZED IN WRITING BY AN OFFICER OF GTECH. NEITHER THIS ITEM NOR THE
C     INFORMATION IT CONTAINS MAY BE USED, TRANSFERRED, REPRODUCED, PUBLISHED
C     OR DISCLOSED, IN WHOLE OR IN PART, AND DIRECTLY OR INDIRECTLY, EXCEPT AS
C     EXPRESSLY AUTHORIZED BY AN OFFICER OR GTECH, PURSUANT TO WRITTEN AGREEMENT
C
C     Copyright 2000 GTECH Corporation. All Rights Reserved
C
C     **************************************************************************
C
C ******************************************************************************
C
C     SUBROUTINE: GET_CANCEL_EVENT_DATE_TIME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 03 / 04 / 2017
C
C ******************************************************************************
C
C FUNCTION GET THE CANCEL EVENT DATE AND TIME
C
C==== OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE GET_CANCEL_EVENT_DATE_TIME(ZIPDATE, DRWDATE, CANCEL_DATE, CANCEL_TIME)
      IMPLICIT NONE
C
      INTEGER * 4 ZIPDATE        ! 3 BYTES FOR TIME AND 1 BYTE FOR OFFSET TO DRAW DATE
      INTEGER * 4 DRWDATE        ! DRAW DATE
      INTEGER * 4 CANCEL_DATE    ! CANDEL DATE
      INTEGER * 4 CANCEL_TIME    ! CANCEL TIME
C
      INTEGER * 4 I4TEMP
C
      BYTE I1TEMP(4)
C
      EQUIVALENCE(I4TEMP, I1TEMP)
C
      I4TEMP = ZIPDATE
C
      CANCEL_DATE = DRWDATE - I1TEMP(4)
C
      I1TEMP(4) = 0
C
      CANCEL_TIME = I4TEMP
C
      END


C ******************************************************************************
C
C     SUBROUTINE: SET_CANCEL_EVENT_DATE_TIME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 03 / 04 / 2017
C
C ******************************************************************************
C
C FUNCTION GET THE CANCEL EVENT DATE AND TIME
C
C==== OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE SET_CANCEL_EVENT_DATE_TIME(ZIPDATE, DRWDATE, CANCEL_DATE, CANCEL_TIME)
      IMPLICIT NONE
C
      INTEGER * 4 ZIPDATE        ! 3 BYTES FOR TIME AND 1 BYTE FOR OFFSET TO DRAW DATE
      INTEGER * 4 DRWDATE        ! DRAW DATE
      INTEGER * 4 CANCEL_DATE    ! CANDEL DATE
      INTEGER * 4 CANCEL_TIME    ! CANCEL TIME
C
      INTEGER * 4 I4TEMP
C
      BYTE I1TEMP(4)
C
      EQUIVALENCE(I4TEMP, I1TEMP)
C
      I4TEMP = CANCEL_TIME
C
      I1TEMP(4) = DRWDATE - CANCEL_DATE
C
      ZIPDATE = I4TEMP
C
      END

C ******************************************************************************
C
C     SUBROUTINE: FRMT_CANCEL_EVENT_DATE_TIME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 03 / 04 / 2017
C
C ******************************************************************************
C
C FUNCTION TO FORMAT THE CANCEL EVENT DATE AND TIME
C
C==== OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE FRMT_CANCEL_EVENT_DATE_TIME(ZIPDATE, DRWDATE, EVENT_CANCEL_MESSAGE)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:DATBUF.DEF'
C
      INTEGER * 4 ZIPDATE        ! 3 BYTES FOR TIME AND 1 BYTE FOR OFFSET TO DRAW DATE
      INTEGER * 4 DRWDATE        ! DRAW DATE
C
      CHARACTER EVENT_CANCEL_MESSAGE * (*)
C
      INTEGER * 4 CANCEL_DATE    ! CANDEL DATE
      INTEGER * 4 CANCEL_TIME    ! CANCEL TIME
C
      INTEGER * 2 DATE(LDATE_LEN)
C
      WRITE(EVENT_CANCEL_MESSAGE, 100)
C
      IF(ZIPDATE .EQ. 0) RETURN
C
      CALL GET_CANCEL_EVENT_DATE_TIME(ZIPDATE, DRWDATE, CANCEL_DATE, CANCEL_TIME)        
C
      DATE(VCDC) = CANCEL_DATE
C
      CALL CDATE(DATE)
C
      WRITE(EVENT_CANCEL_MESSAGE, 101) DATE(VDAY), 
     *                                 DATE(VMON),
     *                                 DATE(VYEAR) + 2000,
     *                                 DISTIM(CANCEL_TIME)
C
100   FORMAT(32X)
101   FORMAT('Cancelled', X,  I2.2, '/', I2.2, '/', I4.4, X, 'At', X, A8)
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_SPORTS_TOT_CANCEL_EVENTS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 03 / 04 / 2017
C
C ******************************************************************************
C
C FUNCTION TO GE THE TOTAL NUMBER OF CANCELLED EVENTS FROM COMMON MEMORY OR DISK
C
C==== OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE GET_SPORTS_TOT_CANCEL_EVENTS(DRAW, GIND, SHW_EMITC, TOTCAN_EVENTS, FSTS)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:DSPREC.DEF'
C
      INTEGER * 4 DRAW          ! DRAW NUMBER
      INTEGER * 4 GIND          ! GAME INDEX
      INTEGER * 4 TOTCAN_EVENTS ! TOTAL NUMBER OF EVENTS CANCELLED
      INTEGER * 4 FSTS          ! FUNCTION STATUS
C
      LOGICAL SHW_EMITC         ! SHOW ERROR MESSAGE IN THE CONSOLE
C
      INTEGER * 4 ROW_IDX       ! ROW INDEX COUNTER
C
      CALL READ_SPORTS_DRAW_FROM_MEM_OR_DISK(DRAW, GIND, DSPREC, SHW_EMITC, FSTS)
C
      IF(FSTS .NE. 0) RETURN
C
      TOTCAN_EVENTS = 0
C
      DO ROW_IDX = 1, MIN(DSPMAX, SPGNBR)
        IF(DSPECD(ROW_IDX) .NE. 0) TOTCAN_EVENTS = TOTCAN_EVENTS + 1
      ENDDO
C
      END


C ******************************************************************************
C
C     SUBROUTINE: READ_SPORTS_DRAW_FROM_MEM_OR_DISK
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 03 / 04 / 2017
C
C ******************************************************************************
C
C FUNCTION TO READ THE SPORT DRAW REQUESTED FROM THE COMMOND MEMORY OR FROM THE DISK
C
C==== OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE READ_SPORTS_DRAW_FROM_MEM_OR_DISK(DRAW, GIND, GAMREC, SHW_EMITC, FSTS)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:DSPREC.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:SPTCOM.DEF'
C
      INTEGER * 4 DRAW        ! DRAW NUMBER
      INTEGER * 4 GIND        ! GAME INDEX
      INTEGER * 4 GAMREC(*)   ! GAME RECORD
      INTEGER * 4 FSTS        ! FUNCTION STATUS
C
      LOGICAL SHW_EMITC       ! SHOW ERROR MESSAGE IN THE CONSOLE
C
      INTEGER * 4 IDX         ! INDEX COUNTER
      INTEGER * 4 GNUM        ! GAME NUMBER
      INTEGER * 4 IDFIL       ! FILE ID
      INTEGER * 4 GAM_FDB(7)  ! GAME FILE DESCRIPTOR BLOCK
C
      FSTS = 0
C
      ! READ THE DRAW FROM COMMON MEMORY
      IF(SPTDRW(GIND) .EQ. DRAW) THEN
        CALL GAMLOG(TSPT, GIND, GAMREC, SPTSTS)
        RETURN
      ENDIF
C
      ! READ THE DRAW FROM THE DISK
      IDFIL = 3
      GNUM  = GTNTAB(TSPT, GIND)
C
      CALL OPENW(IDFIL, GFNAMES(1, GNUM), 4, 0, 0, FSTS)
C
      IF(FSTS .NE. 0 .AND. SHW_EMITC .EQ. .FALSE.) THEN
         TYPE   *, IAM()
         TYPE 100, IAM(), (GFNAMES(IDX, GNUM), IDX = 1, 5), FSTS
         TYPE   *, IAM()
         CALL GSTOP(GEXIT_FATAL)
         RETURN  ! FILE NOT OPEN YET,SO RETURN
      ENDIF
C
      IF(FSTS .NE. 0 .AND. SHW_EMITC .EQ. .TRUE.) THEN
         CALL OPS('Unable To Open The Sports Game File', GNUM, DRAW)
         RETURN  ! FILE NOT OPEN YET,SO RETURN
      ENDIF
C
      CALL IOINIT(GAM_FDB, IDFIL, DSPSEC * 256)
C
      CALL READW(GAM_FDB, DRAW, GAMREC, FSTS)
C
      IF(FSTS .NE. 0 .AND. SHW_EMITC .EQ. .FALSE.) THEN
         TYPE   *, IAM()
         TYPE 101, IAM(), (GFNAMES(IDX, GNUM), IDX = 1, 5), FSTS
         TYPE   *, IAM()
         CALL GSTOP(GEXIT_FATAL)
         GOTO 1000
      ENDIF
C
      IF(FSTS .NE. 0 .AND. SHW_EMITC .EQ. .TRUE.) THEN
         CALL OPS('Unable To Read The Sports Game File', GNUM, DRAW)
         GOTO 1000
      ENDIF
C
1000  CONTINUE
      CALL CLOSEFIL(GAM_FDB)
C
      IF(FSTS .NE. 0) RETURN   ! RETURN ONCE THE FILE HAS BEEN CLOSED
C
100   FORMAT(X, A, 'Error Opening File:', X, 5A4, 'Status:', X, I)
101   FORMAT(X, A, 'Error Reading File:', X, 5A4, 'Status:', X, I)
C
      END
