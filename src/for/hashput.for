C
C SUBROUTINE HASHPUT
C $Log:   GXAFXT:[GOLS]HASHPUT.FOV  $
C  
C     Rev 1.0   17 Apr 1996 13:31:34   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 16:34:36   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - hashmem.for **
C
C
C***********************************************************************
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE HASHPUT(INDEX1,INDEX2,RECORD,RECSTAT,NEXT_REC,
     *	                   NEXT_BLOCK,RETURN_STATUS)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:HASHMEM.DEF'
C
	INTEGER*4   INDEX1,INDEX2,RECORD(*),RETURN_STATUS
	INTEGER*4   NEXT_REC,NEXT_BLOCK,TIMES,BLOCK,RECSTAT
C
C
	IF (INDEX1.EQ.0 .OR. INDEX2.GT.15 .OR. INDEX2.LT.0) THEN
	    RETURN_STATUS = HASH_RETURN_INVALID_KEY
	    GOTO 9000
	ENDIF
	RETURN_STATUS = HASH_RETURN_OK  !ASSUME IT IS GOOD
C
C IF COMBINATION OF 3 USE DIRECT ACCESS TABLE
C
	IF(INDEX2.LE.3.AND.INDEX2.GT.0)THEN
	   HASH_DIR(INDEX1)=RECORD(1)    !CHANGED TO (1)
	   RETURN
	ENDIF
C
C IF RECORD HAS ALREADY BEEN FOUND BY HASHGET USE RECORD
C NUMBER AND BLOCK FROM HASHGET TO FIND THE RECORD
C
	 IF(RECSTAT.EQ.SAME_RECORD)THEN
	    IF(HASH_TAB(1,NEXT_REC,NEXT_BLOCK) .EQ. 0) THEN
C
C RECORD NOT FOUND, PUT A NEW ONE
C
	       HASH_TAB(1,NEXT_REC,NEXT_BLOCK) = INDEX1
	       IF(HASH_RECORD_SIZE .GT. 1)
     *	          CALL FASTMOV(RECORD,HASH_TAB(2,NEXT_REC,
     *	                       NEXT_BLOCK), HASH_RECORD_SIZE)
	       HASH_TAB(2,NEXT_REC,NEXT_BLOCK) =
     *	                INDEX2 + RECORD(1)*16
	       GOTO 9000
	    ELSEIF(HASH_TAB(1,NEXT_REC,NEXT_BLOCK).EQ.INDEX1) THEN
	       IF(IAND(HASH_TAB(2,NEXT_REC,NEXT_BLOCK),15) .EQ.
     *	          INDEX2) THEN
C
C RECORD FOUND
C
	          IF(HASH_RECORD_SIZE .GT. 1)
     *	             CALL FASTMOV(RECORD,HASH_TAB(2,NEXT_REC,
     *	                          NEXT_BLOCK), HASH_RECORD_SIZE)
	          HASH_TAB(2,NEXT_REC,NEXT_BLOCK)=INDEX2+RECORD(1)*16
	          GOTO 9000
	       ENDIF
	    ELSE
C
C CALL WITH WRONG RECORD STATUS WILL NEED TO SEARCH FOR RECORD
C WARN USER
C
	       RETURN_STATUS=HASH_RETURN_NOT_SAME
	    ENDIF
	ENDIF
C
C GET MEMORY BLOCK FOR THE RECORD
C
	TIMES   = 1
	CALL HASHBLOCK(INDEX1,BLOCK,TIMES)
	NEXT_BLOCK=BLOCK
C
C FIND THE PLACE FOR THE RECORD AND PUT IT IN THE HASH_TAB
C
10	CONTINUE
	DO 100, NEXT_REC = 1,HASH_RECORDS
	    IF(HASH_TAB(1,NEXT_REC,NEXT_BLOCK) .EQ. 0) THEN
C
C RECORD NOT FOUND, PUT A NEW ONE
C
	       HASH_TAB(1,NEXT_REC,NEXT_BLOCK) = INDEX1
	       IF(HASH_RECORD_SIZE .GT. 1)
     *	          CALL FASTMOV(RECORD,HASH_TAB(2,NEXT_REC,
     *	                       NEXT_BLOCK), HASH_RECORD_SIZE)
	          HASH_TAB(2,NEXT_REC,NEXT_BLOCK) =
     *	                   INDEX2 + RECORD(1)*16
	          GOTO 9000
	       ELSEIF(HASH_TAB(1,NEXT_REC,NEXT_BLOCK).EQ.INDEX1) THEN
	           IF(IAND(HASH_TAB(2,NEXT_REC,NEXT_BLOCK),15) .EQ.
     *	              INDEX2) THEN
C
C RECORD FOUND
C
	           IF(HASH_RECORD_SIZE .GT. 1)
     *	              CALL FASTMOV(RECORD,HASH_TAB(2,NEXT_REC,
     *	                           NEXT_BLOCK), HASH_RECORD_SIZE)
	           HASH_TAB(2,NEXT_REC,NEXT_BLOCK)=INDEX2+RECORD(1)*16
	           GOTO 9000
	        ENDIF
	    ENDIF
100	CONTINUE
C
	TIMES = TIMES+1
	IF (TIMES .GT. HASH_MAX_SEARCH) THEN
C
C LOOPED TO MANY TIMES
C
	    RETURN_STATUS = HASH_RETURN_TOO_MANY
	    GOTO 9000
	ENDIF
C
C FIND NEXT BLOCK FOR SEARCH
C
	CALL HASHBLOCK(INDEX1,NEXT_BLOCK,TIMES)
	GOTO 10
C
9000	CONTINUE
	RETURN
	END
