C
C SUBROUTINE INTERN_UPD
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]X2INTERN_UPD.FOV                             $
C  $Date::   17 Apr 1996 16:20:38                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C  
C ** Source - INTERN_UPD.FOR **
C
C INTERN_UPD.FOR
C
C V01 13-DEC-94 GPR RELEASED FOR UK
C
C This routine updates an 'internal file', containing information
C regarding installation date of the terminal, first day accessed and 
C last date accessed. The record-number is the terminal number.
C It also updates the buffer that contains info
C that should be printed out.
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE X2UPDATE_INTERNALFILE(SORTARRAY)
	IMPLICIT NONE  
 	INCLUDE 'INCLIB:X2TERMSTA.DEF'
        INCLUDE 'INCLIB:AGTCOM.DEF'
C
        INTEGER*4 SORTARRAY(LEN_SORTARRAY,X2X_TERMS) ! ARRAY CONTAINING INFO
						     ! TO BE PUT ON LISTING
	CHARACTER*20 INTERN_FILENAME/'INTERN_UPD.INT'/ ! FILENAME OF INTERNAL
						       ! FILE
	INTEGER*4 FILE_INT(5)			    ! HELP VARIABLE FOR OPENW 
	EQUIVALENCE (INTERN_FILENAME,FILE_INT)	    
C
	INTEGER*4 TERMSTAREC(LENRECORD)		! A RECORD READ FROM FILE
	INTEGER*4 FIRST_INSTALLED,FIRST_ACCESSED,LAST_ACCESSED
C			    ! FIELDS OF THE RECORD
	EQUIVALENCE (FIRST_INSTALLED,TERMSTAREC(1))
	EQUIVALENCE (FIRST_ACCESSED,TERMSTAREC(2))
	EQUIVALENCE (LAST_ACCESSED,TERMSTAREC(3))
C
C	Variable Declarations:
C
C	INTEGER*4 TEMPRECORD(LEN_SORTARRAY)
	INTEGER*4 I
	INTEGER*4 STN
C
	INTEGER*4 FDB(7)
	INTEGER*4 ST
	INTEGER*4 TERM
C
C OPEN INTERNAL FILE FOR READING/WRITING
C
	CALL OPENW(1,FILE_INT,4,0,0,ST)
	CALL IOINIT(FDB,1,BLOCKSIZE*4)
	IF (ST.NE.0) THEN
	    CALL USRCLOS1(1)
	ENDIF
C
C LOOP THROUGH ALL RECORDS
C IF A TERMINAL IS ADDED, (RE)SET FIRST_ACCESSED, LAST_ACCESSED TO ZERO
C
	DO 1000,I=1,X2X_TERMS
	    TERM = SORTARRAY(TERM_NUMBER,I)
	    IF (TERM.EQ.0) GOTO 1000
C
	    STN = X2XT_STATION_NO(TERM)
	    IF (STN.EQ.0) GOTO 1000
C
	    CALL X2READREC(TERM,FDB,TERMSTAREC)
C
	    IF (FIRST_INSTALLED.NE.AGTHTB(AGTCDC,TERM)) THEN
		FIRST_INSTALLED=AGTHTB(AGTCDC,TERM)
		FIRST_ACCESSED=0
		LAST_ACCESSED=0
		CALL X2WRITEREC(TERM,FDB,TERMSTAREC)
	    ENDIF
C
C IF TERMINAL WAS OPERATIONAL TODAY (I.E. X2XT_TIME(TERM_NR).NE.0)
C SET LAST_ACCESSED TO CDC-DAY
C
	    IF (FIRST_INSTALLED.NE.0 .AND. X2XT_TIME(TERM).NE.0) THEN
	        IF (FIRST_ACCESSED.EQ.0.OR.LAST_ACCESSED.NE.DAYCDC) THEN
C		    ! SPEED UP THINGS A LITTLE BIT
		   IF (FIRST_ACCESSED.EQ.0) FIRST_ACCESSED=DAYCDC
		   LAST_ACCESSED=DAYCDC
		CALL X2WRITEREC(TERM,FDB,TERMSTAREC)
		ENDIF
	    ENDIF
C
C UPDATE SORTARRAY WITH INFORMATION READ
C
	    SORTARRAY(INST_DATE,I)=FIRST_INSTALLED
	    SORTARRAY(FIRST_DATE,I)=FIRST_ACCESSED
	    SORTARRAY(LAST_DATE,I)=LAST_ACCESSED
1000	CONTINUE

	CALL USRCLOS1(1)
C
	END
C
C************** READREC() ************************
C READREC PROVIDES BUFFERED I/O READING. IT READS RECORD WITH RECORD-
C NUMBER 'RECNR' INTO RECORD 'RECORD'. THE FILE IS READ IN BLOCKS OF
C SIZE 'BLOCKSIZE' (CURRENTLY 512 BYTES).
C

	SUBROUTINE X2READREC(RECNR,FDB,RECORD)
	IMPLICIT NONE  
	INCLUDE 'INCLIB:X2TERMSTA.DEF'
C
	INTEGER*4 RECNR
	INTEGER*4 FDB(*)
	INTEGER*4 RECORD(*)
C
	INTEGER*4 CURR_BLOCK_READ
	INTEGER*4 BUFFER
	COMMON/READBLOCK/CURR_BLOCK_READ,BUFFER(BLOCKSIZE)
	INTEGER*4 ST,I,TEMP,TEMP2
C
	TEMP2 = RECNR*LENRECORD
C
	IF (TEMP2/BLOCKSIZE+1.NE.CURR_BLOCK_READ) THEN
	    CURR_BLOCK_READ = TEMP2/BLOCKSIZE+1
	    CALL READW(FDB,CURR_BLOCK_READ,BUFFER,ST)
	    IF (ST.NE.0) THEN
	        TYPE *,'INVALID READ'
		CALL USRCLOS1(1)
	    ENDIF
	ENDIF


	TEMP = MOD(TEMP2,BLOCKSIZE)
	DO I=1,LENRECORD
		RECORD(I) = BUFFER(I+TEMP)
	END DO

	RETURN    

	END	    
C
C************** WRITEREC() ************************
C READREC PROVIDES BUFFERED I/O WRITING. IT WRITES RECORD 'RECORD' WITH
C  RECORDNUMBER 'RECNR' TO THE FILE. THE FILE IS WRITTEN IN BLOCKS OF
C SIZE 'BLOCKSIZE' (CURRENTLY 512 BYTES).
C

	SUBROUTINE X2WRITEREC(RECNR,FDB,RECORD)
	IMPLICIT NONE  
	INCLUDE 'INCLIB:X2TERMSTA.DEF'
C
	INTEGER*4 RECNR
	INTEGER*4 FDB(*)
	INTEGER*4 RECORD(*)
C
	INTEGER*4 CURR_BLOCK_WRITTEN
	INTEGER*4 WRITEBUFFER
	COMMON/WRITEBLOCK/CURR_BLOCK_WRITTEN,WRITEBUFFER(BLOCKSIZE)
C
	INTEGER*4 ST,I,BLOCK_READ,TEMP
C
	BLOCK_READ = (RECNR*LENRECORD)/BLOCKSIZE+1
	IF (BLOCK_READ.NE.CURR_BLOCK_WRITTEN) THEN
	    CURR_BLOCK_WRITTEN = BLOCK_READ
	    CALL READW(FDB,BLOCK_READ,WRITEBUFFER,ST)
	    IF (ST.NE.0) THEN
	        TYPE *,'INVALID READ'
		CALL USRCLOS1(1)
	    ENDIF
	ENDIF
C
	TEMP = MOD(RECNR*LENRECORD,BLOCKSIZE)
	DO I=1,LENRECORD
	    WRITEBUFFER(I+TEMP) = RECORD(I)
	END DO
C
	CALL WRITEW(FDB,BLOCK_READ,WRITEBUFFER,ST)
	IF (ST.NE.0) THEN
	    TYPE *,'INVALID WRITE'
	    CALL USRCLOS1(1)
	ENDIF
C
	RETURN

	END
