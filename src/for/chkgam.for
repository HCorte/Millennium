C CHKGAM.FOR
C
C V13 24-APR-2017 MTK Skip results entry is sports draw cancelled
C V12 29-NOV-2000 UXN TOTOGOLA ADDED.
C V11 24-APR-2000 OXK SPTESD(GIND) also checked for OPTION 2
C V10 10-APR-2000 UXN SPTESD(GIND) changed to SPTDAT(CURDRW,GIND)
C V09 13-OCT-1999 RXK World Tour added.
C V08 13-MAY-1999 UXN SUPER TRIPLE ADDED.
C V07 10-NOV-1995 HXK Further changes for Double, Couple
C V06 15-OCT-1994 HXK Adding /developing Bingo (15.Oct.94)
C V05 13-JUL-1993 SXH Added new games for Finland (RAVI and SPEDEN)
C V04 09-FEB-1993 EBD Added logic to check that game type prior to performing 
C                     operations specific to a game.  Otherwise array bounds 
C                     problems occur.
C V03 21-JAN-1993 DAB Initial Release
C                     Based on Netherlands Bible, 12/92, and Comm 1/93 update
C                     DEC Baseline
C V02 12-AUG-92 GCAN FIXED TOTO SELECT DRAW DATE CHECK.
C V01 01-APR-92 GCAN INITIAL RELEASE FOR THE NETHERLANDS
C
C
C SUBROUTINE TO CHECK STATUS OF ALL GAMES AND TOTO SELECT ROWS AND
C RETURN BITMAP OF RESULT.
C
C
C OPT # BIT DESCRIPTION		           BIT DESCRIPTION
C ---------------------------------------------------------------------------
C   1   OFF NO WINSEL TODAY (GAMES/ROWS)   ON  WINSEL TODAY (GAMES/ROWS)
C   2   OFF VALUE NOT TRUE  (GAME/ROW STS) ON  VALUE TRUE   (GAME/ROW STS)
C   3   OFF FILE VALUE NOT TRUE (GAME STS) ON  FILE VALUE NOT TRUE (GAME STS)
C                                /ROW STS                           /ROW STS
C ---------------------------------------------------------------------------
C
C
C INPUT: 
C	  OPTION #	(1-3) SEE ABOVE.
C	  GAME STATUS	TO COMPAR FOR OPTION 2 & 3.
C			NOTE! IF CURRENT STATUS OF GAME/ROW IS
C			LESS OR EQUAL TO GAME STATUS THEN THE BIT
C			WILL BE TURNED ON IN THE BITMAP!
C
C OUTPUT:
C	  BITMAP	CORESPONDING GAME/ROW BITS SET OR CLEARED.
C			BITS ARE SET LEFT TO RIGHT (1 TO N)
C	  
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1999 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
        SUBROUTINE CHKGAM(OPTION,BITMAP,GAMSTS)
        IMPLICIT NONE
C
        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
        INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:WINCOM.DEF'
	INCLUDE 'INCLIB:LTOCOM.DEF'
	INCLUDE 'INCLIB:SPTCOM.DEF'
	INCLUDE 'INCLIB:TGLCOM.DEF'
	INCLUDE 'INCLIB:KIKCOM.DEF'
	INCLUDE 'INCLIB:NBRCOM.DEF'
	INCLUDE 'INCLIB:WITCOM.DEF'
	INCLUDE 'INCLIB:SCRCOM.DEF'
	INCLUDE 'INCLIB:TSLCOM.DEF'
        INCLUDE 'INCLIB:BNGCOM.DEF'
        INCLUDE 'INCLIB:DBLCOM.DEF'
        INCLUDE 'INCLIB:CPLCOM.DEF'
	INCLUDE 'INCLIB:DLTREC.DEF'
	INCLUDE 'INCLIB:DSPREC.DEF'
	INCLUDE 'INCLIB:DTGREC.DEF'
	INCLUDE 'INCLIB:DKKREC.DEF'
	INCLUDE 'INCLIB:DNBREC.DEF'
	INCLUDE 'INCLIB:DWIREC.DEF'
	INCLUDE 'INCLIB:DSCREC.DEF'
	INCLUDE 'INCLIB:DTSREC.DEF'
        INCLUDE 'INCLIB:DBNREC.DEF'
        INCLUDE 'INCLIB:DDBREC.DEF'
        INCLUDE 'INCLIB:DCPREC.DEF'
        INCLUDE 'INCLIB:DSSREC.DEF'
        INCLUDE 'INCLIB:DTRREC.DEF'
        INCLUDE 'INCLIB:SSCCOM.DEF'
        INCLUDE 'INCLIB:TRPCOM.DEF'
        INCLUDE 'INCLIB:DSTREC.DEF'
        INCLUDE 'INCLIB:STRCOM.DEF'

C
        ! parameters
	INTEGER*4   GAMLU, GAMBYT_CNT
	PARAMETER   (GAMLU=1)		    !Logical Unit for game Files.
	PARAMETER   (GAMBYT_CNT=MAXGAM + (MAXSRW+1)*NUMTSL) !Nuber of Bytes.

        ! arguments
	INTEGER*4   OPTION		    !Option to Performe.
	INTEGER*4   GAMSTS		    !Game Status to Check against.

	BYTE	    BITMAP(GAMBYT_CNT)	    !Bitmap to hold Result of check.

        ! variables

	INTEGER*4   FDB(7)		    !File Descriptor Block (All Files).
	INTEGER*4   GNUM		    !Game Number.
	INTEGER*4   GTYP		    !Game Type.
	INTEGER*4   GIND		    !Gmae Index.
	INTEGER*4   ROWOFF		    !Row Offset into Bitmap.
	INTEGER*4   ROW			    !Row Number (Loop Variable).
	INTEGER*4   DRAW		    !Draw to Read from Game file.
	INTEGER*4   ST			    !Status Returned from Soubroutines.
	INTEGER*4   I			    !Loop Variable(s).
C
	LOGICAL	    SETBIT	    	    !To SET or NOT to set?.
C
	EQUIVALENCE (DLTREC,DSPREC,DKKREC,DNBREC,DBNREC)
	EQUIVALENCE (DLTREC,DWIREC,DSCREC,DTSREC)
        EQUIVALENCE (DLTREC,DDBREC,DCPREC,DTGREC)
C
C SET / CLEAR VARIABLES
C
	DO I = 1, GAMBYT_CNT
	   BITMAP(I) = 0
        END DO
C
C BRANCH TO CORRECT OPTION
C
	GOTO (1000,2000,3000) OPTION
	RETURN
C
C CHECK TO SEE IF TODAY IS A WINSEL DAY OR NOT, AND RETURN BITMAP.
C 0 - NO WINSEL, 1 - WINSEL.
C
1000	CONTINUE
	DO 1100 GNUM = 1,MAXGAM
	   GTYP = GNTTAB(GAMTYP,GNUM)
	   GIND = GNTTAB(GAMIDX,GNUM)
	   IF(GTYP.LT.1.OR.GTYP.GT.MAXTYP) GOTO 1100
	   IF(GIND.LT.1.OR.GIND.GT.MAXIND) GOTO 1100
C
	   SETBIT = .FALSE.

	   IF (GTYP .EQ. TLTO) THEN
	     IF(LTODAT(CURDRW,GIND).EQ.DAYCDC) SETBIT = .TRUE.
           ENDIF

	   IF (GTYP .EQ. TSPT) THEN
	     IF(SPTDAT(CURDRW,GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TTGL) THEN
	     IF(TGLDAT(CURDRW,GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

           IF (GTYP .EQ. TBNG) THEN
             IF(BNGESD(GIND).EQ.DAYCDC) SETBIT = .TRUE.
           ENDIF

	   IF (GTYP .EQ. TKIK) THEN
	     IF(KIKESD(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TNBR) THEN
	     IF(NBRESD(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF
	   
	   IF (GTYP .EQ. TWIT ) THEN
	     IF(WITDAT(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TSCR) THEN	 
	     IF(SCRDAT(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TDBL ) THEN
	     IF(DBLDAT(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TCPL ) THEN
	     IF(CPLDAT(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TSSC) THEN	 
	     IF(SSCDAT(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TTRP) THEN	 
	     IF(TRPDAT(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TSTR) THEN	 
	     IF(STRDAT(GIND).EQ.DAYCDC) SETBIT = .TRUE.
	   ENDIF

	   IF(GTYP.EQ.TTSL) THEN
C
C IF TOTO SELECT CHECK DATES ON ROWS.
C
	      DO 1110 ROW = 1,MAXSRW
		 ROWOFF = MAXGAM + ((GIND-1)*MAXSRW) + ROW
		 IF(TSLDAT(ROW,GIND).EQ.DAYCDC) THEN
		    SETBIT = .TRUE.
		    CALL SETBIT_BSTRNG(BITMAP,ROWOFF)
		 ENDIF
1110	      CONTINUE
C
	   ELSE
C
	      IF(SETBIT) CALL SETBIT_BSTRNG(BITMAP,GNUM)
C
	   ENDIF
C
1100	CONTINUE

	RETURN
C
C CHECK TO SEE IF TODAY IS A CLOSE DAY AND THE GAME DID NOT CLOSE.
C 0 - GAME CLOSED OK OR WAS NOT SUPPOSE TO CLOSE.
C 1 - GAME WAS SUPPOSED TO CLOSE BUT DID NOT.
C
2000	CONTINUE
	DO 2100 GNUM = 1,MAXGAM
	   GTYP = GNTTAB(GAMTYP,GNUM)
	   GIND = GNTTAB(GAMIDX,GNUM)
	   IF(GTYP.LT.1.OR.GTYP.GT.MAXTYP) GOTO 2100
	   IF(GIND.LT.1.OR.GIND.GT.MAXIND) GOTO 2100
C
	   SETBIT = .FALSE.

           IF (GTYP .EQ. TLTO ) THEN
	    IF(LTODAT(CURDRW,GIND).EQ.DAYCDC.AND.
     *        LTOSTS(GIND).LT.GAMSTS)   SETBIT = .TRUE.
	    IF(LTOESD(GIND).EQ.DAYCDC.AND.
     *        LTOSTS(GIND).LT.GAMSTS)   SETBIT = .TRUE.
 	   ENDIF

	   IF (GTYP .EQ. TSPT ) THEN
            IF(SPTDCD(GIND).EQ.0) THEN                     !V13
	      IF(SPTDAT(CURDRW,GIND).EQ.DAYCDC.AND.
     *          SPTSTS(GIND).LT.GAMSTS)   SETBIT = .TRUE.
	      IF(SPTESD(GIND).EQ.DAYCDC.AND.
     *          SPTSTS(GIND).LT.GAMSTS)   SETBIT = .TRUE.
	     ENDIF
	   ENDIF
           
	   IF (GTYP .EQ. TTGL ) THEN
	    IF(TGLDAT(CURDRW,GIND).EQ.DAYCDC.AND.
     *        TGLSTS(GIND).LT.GAMSTS)   SETBIT = .TRUE.
	    IF(TGLESD(GIND).EQ.DAYCDC.AND.
     *        TGLSTS(GIND).LT.GAMSTS)   SETBIT = .TRUE.
	   ENDIF
           
           IF (GTYP .EQ. TBNG ) THEN
            IF(BNGESD(GIND).EQ.DAYCDC.AND.
     *        BNGSTS(GIND).LT.GAMSTS)   SETBIT = .TRUE.
           ENDIF
           
           IF (GTYP .EQ. TKIK ) THEN
	    IF(KIKESD(GIND).EQ.DAYCDC.AND.
     *	      KIKSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
           ENDIF

	   IF (GTYP .EQ. TNBR ) THEN
	    IF(NBRESD(GIND).EQ.DAYCDC.AND.
     *	      NBRSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
           ENDIF

	   IF (GTYP .EQ. TWIT ) THEN
	    IF(WITESD(GIND).EQ.DAYCDC.AND.
     *	      WITSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TSCR ) THEN
	    IF(SCRESD(GIND).EQ.DAYCDC.AND.
     *	      SCRSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TDBL ) THEN
	    IF(DBLESD(GIND).EQ.DAYCDC.AND.
     *	      DBLSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TCPL ) THEN
	    IF(CPLESD(GIND).EQ.DAYCDC.AND.
     *	      CPLSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TSSC ) THEN
	    IF(SSCESD(GIND).EQ.DAYCDC.AND.
     *	      SSCSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
	   ENDIF

	   IF (GTYP .EQ. TTRP ) THEN
	    IF(TRPESD(GIND).EQ.DAYCDC.AND.
     *	      TRPSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
	   ENDIF
C
	   IF (GTYP .EQ. TSTR ) THEN
	    IF(STRESD(GIND).EQ.DAYCDC.AND.
     *	       STRSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
	   ENDIF

	   IF(GTYP.EQ.TTSL) THEN

	    IF(TSLESD(GIND).EQ.DAYCDC.AND.
     *	      TSLSTS(GIND).LT.GAMSTS)	SETBIT = .TRUE.
C
C IF TOTO SELECT ALSO CHECK ROW STATUSES.
C
	      DO 2110 ROW = 1,MAXSRW
		 ROWOFF = MAXGAM + ((GIND-1)*MAXSRW) + ROW
		 IF(TSLDAT(ROW,GIND).EQ.DAYCDC.AND.
     *		    TSLSTA(ROW,GIND).LT.GAMSTS) 
     *		    CALL SETBIT_BSTRNG(BITMAP,ROWOFF)
2110	      CONTINUE
C
	   ENDIF      
C
	   IF(SETBIT) CALL SETBIT_BSTRNG(BITMAP,GNUM)
C
2100	CONTINUE
	RETURN
C
C READ GAME FILES AND DETERMINE IF VALUE FOR GAME STATUS IS TRUE.
C BUILD BITMAP AND RETURN.
C
3000	CONTINUE
	DO 3100 GNUM = 1,MAXGAM
	   GTYP = GNTTAB(GAMTYP,GNUM)
	   GIND = GNTTAB(GAMIDX,GNUM)
	   IF(GTYP.LT.1.OR.GTYP.GT.MAXTYP) GOTO 3100
	   IF(GIND.LT.1.OR.GIND.GT.MAXIND) GOTO 3100
C
	   DRAW = DAYDRW(GNUM)
	   IF(DRAW.LE.0) GOTO 3100
C
	   IF(GTYP.EQ.TLTO) THEN
	      IF(LTODAT(CURDRW,GIND).NE.DAYCDC) GOTO 3100
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DLTSEC*256)
	      CALL READW(FDB,DRAW,DLTREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DLTSTS.LT.GAMSTS.AND.LTDELAY(GIND).NE.2) 
     *           CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
	   IF(GTYP.EQ.TSPT) THEN
	      IF(SPTDAT(CURDRW,GIND).NE.DAYCDC) GOTO 3100
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DSPSEC*256)
	      CALL READW(FDB,DRAW,DSPREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DSPSTS.LT.GAMSTS.AND.SPDELAY(GIND).NE.2)
     *           CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
	   IF(GTYP.EQ.TTGL) THEN
	      IF(TGLDAT(CURDRW,GIND).NE.DAYCDC) GOTO 3100
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DTGSEC*256)
	      CALL READW(FDB,DRAW,DTGREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DTGSTS.LT.GAMSTS.AND.TGDELAY(GIND).NE.2)
     *           CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
           IF(GTYP.EQ.TBNG) THEN
              IF(BNGDAT(CURDRW,GIND).NE.DAYCDC) GOTO 3100
              CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
              IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
              CALL IOINIT(FDB,GAMLU,DBNSEC*256)
              CALL READW(FDB,DRAW,DBNREC,ST)
              IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
              IF(DBNSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
              CALL CLOSEFIL(FDB)
              GOTO 3100
           ENDIF
C
	   IF(GTYP.EQ.TKIK) THEN
	      IF(KIKDAT(CURDRW,GIND).NE.DAYCDC) GOTO 3100
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DKKSEC*256)
	      CALL READW(FDB,DRAW,DKKREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DKKSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
	   IF(GTYP.EQ.TNBR) THEN
	      IF(NBRDAT(CURDRW,GIND).NE.DAYCDC) GOTO 3100
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DNBSEC*256)
	      CALL READW(FDB,DRAW,DNBREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DNBSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
	   IF(GTYP.EQ.TWIT) THEN
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DWISEC*256)
	      CALL READW(FDB,DRAW,DWIREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DWIDAT.EQ.DAYCDC) THEN
		 IF(DWISTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      ENDIF
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
	   IF(GTYP.EQ.TSCR) THEN
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DSCSEC*256)
	      CALL READW(FDB,DRAW,DSCREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DSCDAT.EQ.DAYCDC) THEN
		 IF(DSCSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      ENDIF
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
	   IF(GTYP.EQ.TDBL) THEN
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DDBSEC*256)
	      CALL READW(FDB,DRAW,DDBREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DDBDAT.EQ.DAYCDC) THEN
		 IF(DDBSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      ENDIF
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
	   IF(GTYP.EQ.TCPL) THEN
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DCPSEC*256)
	      CALL READW(FDB,DRAW,DCPREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DCPDAT.EQ.DAYCDC) THEN
		 IF(DCPSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      ENDIF
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF

	   IF(GTYP.EQ.TSSC) THEN
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DSSSEC*256)
	      CALL READW(FDB,DRAW,DSSREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DSSDAT.EQ.DAYCDC) THEN
		 IF(DSSSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      ENDIF
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF

	   IF(GTYP.EQ.TTRP) THEN
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DTRSEC*256)
	      CALL READW(FDB,DRAW,DTRREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DTRDAT.EQ.DAYCDC) THEN
		 IF(DTRSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      ENDIF
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C

	   IF(GTYP.EQ.TSTR) THEN
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DSTSEC*256)
	      CALL READW(FDB,DRAW,DSTREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DSTDAT.EQ.DAYCDC) THEN
		 IF(DSTSTS.LT.GAMSTS) CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      ENDIF
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
	   IF(GTYP.EQ.TTSL) THEN
	      CALL OPENW(GAMLU,GFNAMES(1,GNUM),4,0,0,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),1,ST,0)
	      CALL IOINIT(FDB,GAMLU,DTSSEC*256)
	      CALL READW(FDB,DRAW,DTSREC,ST)
	      IF(ST.NE.0) CALL FILERR(GFNAMES(1,GNUM),2,ST,DRAW)
	      IF(DTSESD.EQ.DAYCDC.AND.DTSSTS.LT.GAMSTS) 
     *	         CALL SETBIT_BSTRNG(BITMAP,GNUM)
	      DO 3110 ROW = 1,MAXSRW
		 ROWOFF = MAXGAM + ((GIND-1)*MAXSRW) + ROW
		 IF(DTSSTA(ROW).LT.GAMSTS.AND.DTSDAT(ROW).EQ.DAYCDC)
     *		    CALL SETBIT_BSTRNG(BITMAP,ROWOFF)
3110	      CONTINUE		    
	      CALL CLOSEFIL(FDB)
	      GOTO 3100
	   ENDIF
C
3100	CONTINUE

	RETURN
C
	END
