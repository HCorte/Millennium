C
C SUBROUTINE FILBUF
C FILBUF.FOR
C
C V06 14-JUN-00 UXN CURSTN DEFINED LOCALLY.
C V05 02-APR-91 WS  REMOVED ENCQUE, ENCDONE QUEUE
C V04 25-MAR-91 KWP USE NEW VERSION OF X2XCOM.DEF
C V03 08-MAR-91 TKO CHANGED CALL TO GETLST_SIZE
C V02 23-JAN-91 KWP REMOVED LINCOM/TERCOM    USE X2X STUFF FOR COMM
C V01 01-AUG-90 XXX RELEASED FOR VAX
C
C V04 17-NOV-89 GCAN MODIFIED FOR FINLAND
C V03 13-SEP-89 DSL  MODIFIED FOR SPORTS
C V02 31-JUL-89 MRM  SEND VALIDATION AMOUNTS IN CENTS.
C V01 05-MAY-89 XXX  WISCONSIN RELEASE (COLORADO V02)
C
C SUBROUTINE TO FILL THE BUFFER WITH THE RIGHT MESSAGE
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE FILBUF(TYPE)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:AGTCOM.DEF'
	INCLUDE 'INCLIB:DESNET.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:QUECOM.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:X2XQUE.DEF'
	INCLUDE 'INCLIB:ENCCOM.DEF'
	INCLUDE 'INCLIB:PCCOM.DEF'
C
C
C
	INTEGER*4 BLRC, HOUR, GNUM, OFFSET, INDEX, LOGSIZ, ST, SIZE
	INTEGER*4 BLOCK, K, NTASK, CLU, SER, NENA, TRA
	INTEGER*4 CONTYP, CONN, SYS, HOWMANY, TOT, TYP, GAM, GCNT
	INTEGER*4 HWORDS, OPER, TER, CNT, COUNT, LOFF
	INTEGER*4 BYTES, THISMES, BEGSTN, OFF, LENGTH, TIME
	INTEGER*4 GAME, WAGERS, TYPE, TOFF
C
	INTEGER*4 TEMP
	INTEGER*2 TEMP2(2),HTEMP
C
	INTEGER*4 LOCBUF(480)
	INTEGER*2 LOCBUF2(960)
	BYTE	    B_LOCBUF(1920)
	CHARACTER*1920 CH1920
C
	EQUIVALENCE(CH1920,LOCBUF,LOCBUF2,B_LOCBUF)
	EQUIVALENCE(TEMP,TEMP2,HTEMP)
C
	INTEGER*4 CURSTN
	DATA CURSTN/1/
C
	LOCBUF(BSYNC)='16161616'X
C
	B_LOCBUF(BADDRESS)=0
	B_LOCBUF(BCONTROL)=0
	
C
	IF(TYPE.EQ.MSTATUS) THEN
	   TEMP=0
	   CALL NMOVBYT(TEMP,3,LOCBUF,BTYPE,2)	    !BYTES 9-10
	   CALL NMOVBYT(DAYCDC,3,LOCBUF,BSUBT,2)    !BYTES 11-12
C
	   WAGERS=0
	   DO 10 GAME=1,MAXGAM
	   WAGERS=DAYTYP(DOLAMT,TWAG,GAME)+WAGERS
 10	   CONTINUE
C
	   CALL GETTIM(TIME)
C
	   CALL NMOVBYT(TIME,1,LOCBUF,BDATA,4)		!BYTES 13-16
	   CALL NMOVBYT(P(SYSSTS),1,LOCBUF,BDATA+4,4)   !BYTES 17-20
	   CALL NMOVBYT(WAGERS,1,LOCBUF,BDATA+8,4)	!BYTES 21-24
	   CALL NMOVBYT(NXTSER,1,LOCBUF,BDATA+12,4)	!BYTES 25-28
C
	   LENGTH= 22
C
	ELSEIF(TYPE.EQ.MCOM) THEN
	   CALL FASTMOV(0,LOCBUF(3),100)
	   TEMP=1
	   CALL NMOVBYT(TEMP,3,LOCBUF,BTYPE,2)	    !BYTES 9-10
C
	   BEGSTN=CURSTN
	   THISMES=0
	   BYTES=0
	   LOFF=BDATA	    !START AT BYTE 13
30	   CONTINUE
	   IF(BX2XS_STATE(CURSTN).EQ.X2XS_NOT_ACTIVE) THEN
	      CURSTN=CURSTN+1
	      IF(CURSTN.GT.X2X_STATIONS) CURSTN=1
	      IF(CURSTN.EQ.BEGSTN) GOTO 40
	      GOTO 30
	   ENDIF
C
	   COUNT=X2XS_NUM_TERMS(X2X_MAXPORT,CURSTN)  !COUNT OF TERMS ON STN
	   IF(COUNT.EQ.0) GOTO 35
C
	   CALL NMOVBYT(CURSTN,3,LOCBUF,LOFF,2)
	   LOFF=LOFF+2
C
	   CALL NMOVBYT(COUNT,3,LOCBUF,LOFF,2)
	   LOFF=LOFF+2
C
	   OFF=0
	   TOFF=LOFF	!TEMP OFFSET
	   DO 20 CNT=1,X2X_MAXTERMS
	     TER=X2XS_TERMS(CNT,X2X_MAXPORT,CURSTN)
	     IF(TER.LE.0 .OR. TER.GT.X2X_TERMS) GOTO 20
C
	     CALL NMOVBYT(CNT-1,4,LOCBUF,TOFF,1) !1ST BYTE OF TERM STUFF
	     TOFF=TOFF+1
C
	     TEMP=0
	     CALL NBSET(TEMP,4)
	     IF(BX2XT_STATE(TER).NE.X2XTS_SLOW_POLL) THEN
	       CALL NBSET(TEMP,7)
	     ENDIF
	     OPER=AGTHTB(AOPSTS,TER)
	     IF(OPER.EQ.SIGNON) THEN
	       CALL NBSET(TEMP,6)
	     ENDIF
	     OFF=OFF+1
	     CALL NMOVBYT(TEMP,1,LOCBUF,TOFF,1)
	     TOFF=TOFF+1
20	   CONTINUE
C
	   IF(COUNT.NE.OFF) THEN
	     TYPE*,' TERMINAL COUNT INCONSISTENT ',CURSTN,COUNT,OFF
	     COUNT=MAX0(COUNT,OFF)
	   ENDIF
C
	   HWORDS=COUNT         !ONE HW PER TER
	   BYTES=BYTES+HWORDS*2+4      !TWO HWODRS BEFORE EACH LINE
	   LOFF=LOFF+HWORDS
	   THISMES=THISMES+1
C
35	   CONTINUE
	   CURSTN=CURSTN+1
	   IF(CURSTN.GT.X2X_STATIONS) CURSTN=1
	   IF(CURSTN.EQ.BEGSTN) GOTO 40
C
	   IF(THISMES.LT.MAXSTN) GOTO 30	!SEND THREE LINES OF INFO
C
40	   CONTINUE
	   IF(THISMES.EQ.0) THEN
	      IOLEN=0
	      RETURN
	   ENDIF
C
	   CALL NMOVBYT(THISMES,3,LOCBUF,BSUBT,2)
	   LENGTH=BYTES +6
	ELSEIF(TYPE.EQ.MSTYP) THEN
	   TEMP=2
	   CALL NMOVBYT(TEMP,3,LOCBUF,BTYPE,2)
	   CALL NMOVBYT(DAYCDC,3,LOCBUF,BSUBT,2)
	   CALL NMOVBYT(NUMTOT,1,LOCBUF,BDATA,4)	!BYTES 13-16
	   CALL NMOVBYT(NUMFIN,1,LOCBUF,BDATA+4,4)	!BYTES 17-20
C
	   GCNT=0
	   OFF=BDATA+12
	   DO 50 GAM=1,MAXGAM
	      IF(GNTTAB(GAMIDX,GAM).LE.0) GOTO 50
	      GCNT=GCNT+1
	      DO 55 TYP=1,NUMFIN
	      DO 55 TOT=1,NUMTOT
		CALL NMOVBYT(DAYTYP(TOT,TYP,GAM),1,LOCBUF,OFF,4)
	        OFF=OFF+4
55	      CONTINUE
50	   CONTINUE
	   LENGTH=(GCNT*NUMFIN*NUMTOT+3)*4+6
	   CALL NMOVBYT(GCNT,1,LOCBUF,BDATA+8,4)	!BYTES 21-24
C**   ELSEIF(TYPE.EQ.MSDRW) THEN
C**      LOCBUF2(BTYPE)=3
C**      LOCBUF2(BSUBT)=LT1DRW
C**      DAYS=0
CC**
C**      OFF=BDATA4+2
C**      DO 60 IND=LT1DAT(1)-DAYCDC+3,LTOENT
C**      IF(IND.GT.0.AND.IND.LE.LTOENT) THEN
C**         IF(LT1SAL(IND).GT.0) THEN
C**            LOCBUF(OFF)=DAYCDC-IND+3
C**            OFF=OFF+1
C**            LOCBUF(OFF)=LT1SAL(IND)
C**            OFF=OFF+1
C**            DAYS=DAYS+1
C**         ENDIF
C**      ENDIF
C**60    CONTINUE
CC**
C**      IF(LT1SAL(1).GT.0) THEN
C**         LOCBUF(OFF)=LT1SAL(1)
C**         OFF=OFF+1
C**         DAYS=DAYS+1
C**      ENDIF
CC**
C**      IF(DAYS.EQ.0) THEN
C**         LOCBUF(OFF)=DAYCDC
C**         OFF=OFF+1
C**         LOCBUF(OFF)=0
C**         OFF=OFF+1
C**         DAYS=1
C**      ENDIF
CC**
C**      LOCBUF(BDATA4)=DAYS
C**      LOCBUF(BDATA4+1)=DAYCDC
C**      LENGTH=(DAYS*2+1)*4 +6
C**   ELSEIF(TYPE.EQ.MSPOL) THEN
C**      LOCBUF2(BTYPE)=4
C**      OFF=BDATA4+1
C**      IF(NUMBERS.EQ.NUMBER3) THEN
C**        LOCBUF2(BSUBT)=NUMBER3
C**        LOCBUF2(BDATA2)=NUMPL3
C**        LOCBUF2(BDATA2+1)=NUMTOT
CC**
C**        DO 70 TOT=1,NUMTOT
C**        DO 70 PL=1,NUMPL3
C**        LOCBUF(OFF)=NB3POL(TOT,PL)
C**        OFF=OFF+1
C**70      CONTINUE
C**        NUMBERS=NUMBER4
C**        LENGTH=NUMTOT*NUMPL3*4 +6
C**      ELSE
C**        LOCBUF2(BSUBT)=NUMBER4
C**        LOCBUF2(BDATA2)=NUMPL4
C**        LOCBUF2(BDATA2+1)=NUMTOT
CC**
C**        DO 75 TOT=1,NUMTOT
C**        DO 75 PL=1,NUMPL4
C**        LOCBUF(OFF)=NB4POL(TOT,PL)
C**        OFF=OFF+1
C**75      CONTINUE
C**        NUMBERS=NUMBER3
C**        LENGTH=NUMTOT*NUMPL4*4 +6
C**      ENDIF
CC**
CC**
C**   ELSEIF(TYPE.EQ.MSFUT) THEN
C**      LOCBUF2(BTYPE)=5
C**      LOCBUF2(BSUBT)=FUTURE-1
CC**
C**      LOCBUF2(BDATA2)=1               ;TOTALS
C**      LOCBUF2(BDATA2+1)=DATLEN
CC**
C**      OFF=BDATA4+1
C**      DO 80 TOT=1,1
C**      DO 80 DAY=1,DATLEN
C**      LOCBUF(OFF)=0
C**C**   LOCBUF(OFF)=DAYSBD(DAY,FUTURE)
C**      OFF=OFF+1
C**80    CONTINUE
C**      LENGTH=4*DATLEN+4 +6
C**      FUTURE=MOD(FUTURE,NUMGAM)+1
CC**
CC**
	ELSEIF(TYPE.EQ.MCONF) THEN
	   TEMP=6
	   CALL NMOVBYT(TEMP,3,LOCBUF,BTYPE,2)	    !BYTES 9-10
C
	   IF(WAYINP.LE.0) THEN
	      IOLEN=0
	      RETURN
	   ENDIF
	   CALL NMOVBYT(NODEID,3,LOCBUF,BSUBT,2)    !BYTES 11-12
C
	   CALL NMOVBYT(NETMASTER,4,LOCBUF,BDATA,1)
C
	   CALL NMOVBYT(NETBACKUP,4,LOCBUF,BDATA+1,1)
C
	   OFF=BDATA+3
	   HOWMANY=0
	   DO 90 SYS=1,NETSYS
	   IF(SYS.EQ.NODEID) GOTO 90
	   IF(NETROUT(SYS,WAYINP).NE.ROUACT) GOTO 90
	   HOWMANY=HOWMANY+1
	   CONN=0
	   IF(NETROUT(SYS,WAYINP).EQ.ROUACT) CONN=1
	   CONTYP=0
	   IF(NETSTAT(SYS,WAYINP).EQ.NSTASEC) CONTYP=1
	   TRA=0
	   IF(NETMODE(SYS,WAYINP).EQ.FILMD) TRA=1
	   NENA=NETENA(SYS,WAYINP)
	   SER=0
	   IF(NETROUT(SYS,WAYINP).EQ.ROUACT)THEN
	      IF(NETSTAT(SYS,WAYINP).EQ.NSTASEC)THEN
	         SER=NXTSER
	      ELSEIF(NETSTAT(SYS,WAYINP).EQ.NSTAPRIM)THEN
	         IF(NETMODE(SYS,WAYINP).EQ.FILMD)THEN
	            SER=NETSER(SYS,WAYINP)
	         ELSE
	            SER=NETHSER(SYS,WAYINP)
	         ENDIF
	      ENDIF
	   ENDIF
	   SER=MOD(SER,SYSOFF)
	   CLU=NETOPN(SYS,WAYINP)
C
	   B_LOCBUF(OFF)=SYS
	   B_LOCBUF(OFF+1)=CONN
	   B_LOCBUF(OFF+2)=CONTYP
	   B_LOCBUF(OFF+3)=TRA
	   B_LOCBUF(OFF+4)=NENA
	   B_LOCBUF(OFF+5)=CLU
	   CALL NMOVBYT(SER,1,LOCBUF,OFF+6,4)
	   OFF=OFF+10
90	   CONTINUE
C
	   B_LOCBUF(BDATA+2)=HOWMANY+1
C
	   LENGTH=HOWMANY*10 + 3 + 6
C
	ELSEIF(TYPE.EQ.MQUE) THEN
	   NTASK=0
	   TEMP=7
	   CALL NMOVBYT(TEMP,3,LOCBUF,BTYPE,2)	    !BYTES 9-10
C
	   OFF=BDATA
C
	   CALL LISTSIZE(FREEQ,TEMP)
	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
	   CALL LISTSIZE(INQUE,TEMP)
	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
	   CALL LISTSIZE(X2X_OUTPUT,TEMP)
	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
	   TEMP=0				!WAS OUTQU1
	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
	   TEMP=0				!WAS OUTQU2
	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
	   CALL LISTSIZE(GAME_OUTQUE,TEMP)
	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
C****	   CALL LISTSIZE(DECDONE,TEMP)
C****	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   CALL NMOVBYT(0,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
	   CALL LISTSIZE(QUETAB(1,DIS),TEMP)
	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
C****	   CALL LISTSIZE(ENCQUE,TEMP)
C****	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   CALL NMOVBYT(0,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
C
	   DO 100 K=1,14
	   CALL LISTSIZE(QUETAB(1,K),TEMP)
	   CALL NMOVBYT(TEMP,3,LOCBUF,OFF,2)
	   OFF=OFF+2
	   NTASK=NTASK+1
100	   CONTINUE
C
	   CALL NMOVBYT(NTASK,3,LOCBUF,BSUBT,2)
C
	   BLOCK=0
	   SIZE=0
	   CALL OPENW(7,SFNAMES(1,PTMF),4,0,0,ST)
	   IF(ST.EQ.0) THEN
	      CALL GETSIZ_USED(7,LOGSIZ)
	      SIZE=LOGSIZ/32
	      CALL GETBI(NXTSER,BLOCK,INDEX,OFFSET)
	   ENDIF
	   CALL USRCLOS1(     7)
C
	   CALL NMOVBYT(SIZE,1,LOCBUF,OFF,4)
	   OFF=OFF+4
	   CALL NMOVBYT(BLOCK,1,LOCBUF,OFF,4)
	   OFF=OFF+4
C
	   LENGTH=(NTASK+5)*2 + 2*4 +6
	ELSEIF(TYPE.EQ.MHSAL) THEN
	   TEMP=9
	   CALL NMOVBYT(TEMP,3,LOCBUF,BTYPE,2)	    !BYTES 9-10
	   GCNT=0
	   OFF=BDATA+2
	   DO 200 GNUM=1,MAXGAM
	      IF(GNTTAB(GAMIDX,GNUM).LE.0) GOTO 200
	      GCNT=GCNT+1
	      DO 190 HOUR=1,24
	         CALL NMOVBYT(HOURSAL(GNUM,1,HOUR),1,LOCBUF2,OFF,4)
	         CALL NMOVBYT(HOURSAL(GNUM,2,HOUR),1,LOCBUF2,OFF+4,4)
	         OFF=OFF+8
190	      CONTINUE
200	   CONTINUE
	   CALL NMOVBYT(TEMP,3,LOCBUF,BSUBT,2)	    !BYTES 11-12
	   CALL NMOVBYT(GCNT,3,LOCBUF,BSUBT+2,2)    !BYTES 13-14
	   LENGTH=(8*24*GCNT)+8
	ELSE
	   IOLEN=0
	   RETURN
	ENDIF
C
	CALL NMOVBYT(LENGTH,3,LOCBUF,BLENGTH,2)	    !BYTES 5-6
	IOLEN=LENGTH+7
	CALL XORSUM(LOCBUF2(BHEADER),LENGTH,BLRC)
	B_LOCBUF(IOLEN)=BLRC
C
C
2222	CONTINUE
C
	DO 1000 K=1,(IOLEN+3)/4
	  BUFFER(K,WRITEPNT)=LOCBUF(K)
1000	CONTINUE
C
	RETURN
	END
