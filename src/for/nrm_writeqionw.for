C
C SUBROUTINE WRITEQIONW
C $Log:   GXAFXT:[GOLS]WRITEQIONW.FOV  $
C  
C     Rev 1.0   17 Apr 1996 16:04:12   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 18:08:28   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - nrm_diskqio.for **
C
C
C
C *** WRITEQIONW       <<<WRITE and NO wait for completion>>>
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE WRITEQIONW(FDB, BLOCK, BUFFER, NUMBYTES, STATUS)
	IMPLICIT NONE
C
	INCLUDE	'INCLIB:SYSPARAM.DEF'
	INCLUDE	'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:DISKQIO.DEF'
C
	INCLUDE '($SYSSRVNAM)'
	INCLUDE '($IODEF)'
C
	INTEGER*4   FDB(7)
	INTEGER*4   BLOCK
	INTEGER*4   BUFFER(*)
	INTEGER*4   NUMBYTES
	INTEGER*4   STATUS
C
	INTEGER*4   IOLEN
	INTEGER*4   CHAN
	INTEGER*4   BEGBLK
C
	INTEGER*4   I4TEMP
	INTEGER*2   I2TEMP(2)
	EQUIVALENCE (I4TEMP,I2TEMP)
	INTEGER*4   FLAG
C
	CALL LIB$GET_EF(FLAG)			    !GET AN EVENT FLAG TO USE
	IF(FLAG.EQ.-1)THEN
	  FDB(FDB_EVNT) = -1
	  STATUS = -99
	  GOTO 9000
	ENDIF
	FDB(FDB_EVNT) = FLAG
C
C
C
	BEGBLK= BLOCK + 1
	IOLEN = NUMBYTES
	CHAN  = FDB(FDB_CHAN)
C
C	*** DO A QIO WITH NO !!! WAIT
C
	STATUS=SYS$QIO (%VAL(FLAG), %VAL(CHAN), %VAL(IO$_WRITEVBLK),
     1		        FDB(FDB_IOSB),,,
     1	                BUFFER, %VAL(IOLEN), %VAL(BEGBLK),,,)
C
	IF(STATUS)THEN
	    STATUS = 0
	ENDIF
C
9000	CONTINUE
	RETURN
	END
