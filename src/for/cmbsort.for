C
C SUBROUTINE CMBSORT
C $Log:   GXAFXT:[GOLS]CMBSORT.FOV  $
C  
C     Rev 1.0   17 Apr 1996 12:37:46   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 15:55:22   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - poolshr.for **
C
C====================================================================
C    SUBROUTINE CMBSORT-GET THE NUMBER OF TIMES THAT COMBINATIONS
C                        WERE BET ON.
C
C   CALL SEQ:   CALL CMBSORT(FDB,TIMES,TIMES1,GAME)
C    IN-FDB=FILE DESCRIPTOR BLOCK
C    OUT-TIMES=THE NUMBER OF TIMES THAT NUMBER SEQUENCE WAS BET
C        TIMES1 = SAME FOR NEGATIVE OFFSETS IN SORTQ
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE CMBSORT(FDB,TIMES,TIMES1,GAME)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:POOLLTO.DEF'
	INCLUDE 'INCLIB:POOLSEE.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:LTOPOL.DEF'
C
	INTEGER*4 SUBTOT, POOL, OFFSET2, OFFSET1, PAGENO, SECOND
	INTEGER*4 OFFSET0, ST, OFFSET,BOTTOM, TAB_OFF, OFFSETS_IN_PAGE
	INTEGER*4 BASE_PAGE, INWORD, BIG_PAGE, LIMIT, GAME, TIMES1
	INTEGER*4 TIMES
	INTEGER*4 FDB(7)
	INTEGER*4 UPDTAB(0:7,3)
	DATA UPDTAB/Z10000000,Z01000000,Z00100000,Z00010000
     *	           ,Z00001000,Z00000100,Z00000010,Z00000001
     *	           ,Z01000000,Z00010000,Z00000100,Z00000001,4*0
     *	           ,Z00010000,Z00000001,6*0/
C
C     ANDTAB-WILL LEAVE ONLY BITS TO CORRSPONDING OFFSET(MOD8)
C
	INTEGER*4 ANDTAB(0:7,3)
	DATA ANDTAB/ZF0000000,Z0F000000,Z00F00000,Z000F0000
     *	           ,Z0000F000,Z00000F00,Z000000F0,Z0000000F
     *	           ,ZFF000000,Z00FF0000,Z0000FF00,Z000000FF,4*0
     *	           ,ZFFFF0000,Z0000FFFF,6*0/
C
	INTEGER*4   PAGEX, CURRENT_FILE	    ! V04
	COMMON /CURRFIL/ CURRENT_FILE	    ! V04
C
C
C
C     CALCULATE OFFSET IN THE TABLE AND GET TOTAL COUNT OF SHARES
C
	LIMIT=LTPOOL_GAMLIMIT(GAME)
	BIG_PAGE=LTPOOL_GAMPAG(GAME)
	INWORD=LTPOOL_INWORD(BIG_PAGE)
	BASE_PAGE=(BIG_PAGE-1)*(PAGESIZE/SEEPAGESIZE)+1
	OFFSETS_IN_PAGE=SEEPAGESIZE*INWORD
	TAB_OFF=1
	IF (INWORD.EQ.4) THEN
	   TAB_OFF=2
	ELSEIF (INWORD.EQ.2) THEN
	   TAB_OFF=3
	ENDIF
C
C
	BOTTOM=0
5	CONTINUE
	CALL RTL(OFFSET,SORTQ,ST)
	IF (ST.EQ.2) RETURN
	OFFSET0=OFFSET
	SECOND=0
	IF (OFFSET.LT.0) THEN
	   SECOND=-1
	   OFFSET=-OFFSET
	ENDIF
	OFFSET=OFFSET-1
	PAGENO=(OFFSET/OFFSETS_IN_PAGE)
	OFFSET=OFFSET-(OFFSETS_IN_PAGE*PAGENO)
	OFFSET1=OFFSET/INWORD
	OFFSET2=OFFSET-INWORD*OFFSET1    !BYTE OFFSET
	OFFSET1=OFFSET1+1
C--------------------------------------------------------------------
C   GET THE CORRECT PAGE INTO MEMORY THAT CORRESPONDS TO OFFSET.
C
	IF (PAGENO+BASE_PAGE.NE.SEECURPAG) THEN
	  IF (BOTTOM.EQ.OFFSET0) THEN    !REMOVED OFFSET+1
10	    CONTINUE
	    PAGEX = PAGENO+BASE_PAGE
	    IF(CURRENT_FILE .EQ. 1 .AND.	! V04
     1	      P(LTOPOL_RAM) .NE. LTOPOL_FIL_VALUE) THEN	      
		CALL FASTMOV(LTOPOL_SPACE((PAGEX-1)*SEEPAGESIZE+1),
     1		SEEPAGE, SEEPAGESIZE)		! V04
	    ELSE
		CALL READQW(FDB,PAGENO+BASE_PAGE,SEEPAGE,ST)
		IF (ST.NE.0) THEN
		    CALL FILERR(SFNAMES(1,LPR),2,ST,PAGENO+BASE_PAGE)
		    GOTO 10
		ENDIF
	    ENDIF
	    SEECURPAG=PAGENO+BASE_PAGE
	    BOTTOM=0
	    GOTO 20
	  ENDIF
	  IF (BOTTOM.EQ.0) BOTTOM=OFFSET0  !REMOVED OFFSET+1
	  CALL ABL(OFFSET0,SORTQ,ST)     !REMOVED OFFSET+1
	  GOTO 5
	ENDIF
C--------------------------------------------------------------------
C     GET TIMES BET
C
20	CONTINUE
	POOL=IAND(SEEPAGE(OFFSET1),ANDTAB(OFFSET2,TAB_OFF))
C
C     AND CALCULATE TIMES BET
C
	SUBTOT=IAND(LIMIT,POOL/UPDTAB(OFFSET2,TAB_OFF))
	IF (SECOND.EQ.0) THEN
	   TIMES=TIMES+SUBTOT
	ELSE
	   TIMES1=TIMES1+SUBTOT
	ENDIF
	GOTO 5
	END
