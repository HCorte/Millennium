C DLOAD.FOR
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]DLOAD.FOV                                    $
C  $Date::   17 Apr 1996 12:55:54                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C
C V23 03-JUN-2011 FRP OOB issue fixed
C X2X Upgrade: 22-FEB-96 wsm Replaced X2S w/ SPE for Finland.
C V21 30-MAY-01 KW  INCREMENT DLLREQ_BAD_SAME_SEG ONLY IF SAME APPLICATION
C                   NUMBER
C V20 26-JAN-00 KW  THE REQUESTED SEGMENT NUMBER SENT FROM TERMINAL IS 2 BYTE
C                   LONG WITH THE HIGHEST 4 BITS OF THAT 2 BYTE RESERVED FOR
C                   COMPRESSION BASED ON THE ASSUMPTION THAT THE SEGMENT NUMBER
C                   WILL ONLY USE UP TO 12 BITS, WHICH IS LESS THAN 4096
C                   SEGMENTS. BUT ALTURA TERMINAL CAN HAS UP TO 32767 SEGMENTS.
C                   ONLY THE UPPER BIT WILL BE CLEAR.  SO IF UPPER 4 BITS ARE
C                   SET, THE REQUEST IS FOR A NON-ALTURA COMPRESSED SEGMENT.
C                   ONLY THE LOWER 12 BITS WILL BE INTERPRETED AS THE SEGMENT
C                   NUMBER.  IF ANY OF THE 4 BITS ARE NOT SET, ALL BITS SHOULD
C                   BE INTERPRETED AS THE SEGMENT NUMBER.
C 
C V07 18-AUG-95 DAS INCORPORATED WALTER BACKGROUND/MULTILOAD CODE
C V06 02-AUG-95 DAS CHANGE LOOKUP FOR GVT SOFT AND APPLICATION LOADS
C V05 23-JUN-95 PJS RESET ROMID TO ZERO SO WE DON'T GET CONFUSED.
C V04 01-JUN-95 PJS MODIFIED TO HANDLE MULTIPLE GVT LOADS.
C V03 15-DEC-94 DAS MUST CALL MOVBYTN INSTEAD OF MOVBYT FOR ROMID (DEC)
C                   AND CHECK FOR WILDCARD
C V02 01-FEB-92 PJS MODIFIED TO HANDLE GVT DLLs & CLEANED UP
C V01 01-AUG-90 XXX RELEASED FOR VAX
C
C CALLING SEQUENCE:
C     CALL DLOAD(TRABUF,MESTAB,OUTLEN,MESNUM)
C INPUT
C     TRABUF - INTERNAL TRANSACTION FORMAT
C     MESTAB - TERMINAL INPUT MESSAGE
C OUTPUT
C     MESTAB - TERMINAL OUTPUT MESSAGE
C     OUTLEN - OUTPUT LENGTH
C     MESNUM - MESSAGE NUMBER
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE DLOAD(TRABUF, MESTAB, OUTLEN, MESNUM)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:MSGCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:PRMPRO.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:PRMDLL.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:PRMAGT.DEF'
	INCLUDE 'INCLIB:REQCOM.DEF'
C
	INTEGER*4   ONCE /0/
	INTEGER*4   TER, LAST_LODNUM, LAST_SEG, HIGH_LODNUM
	INTEGER*4   HIGH_SEG, TMP_VAL
	INTEGER*4   PREVIOUS_TERMINAL_TIME
	INTEGER*4   PREVIOUS_STATION_TIME
	INTEGER*4   LAST_OFFSET
	INTEGER*4   LOAD_ID
	INTEGER*4   APPLICATION_NO, LOAD_REV, LOAD_NAME
        INTEGER*4   HIGH_APPNUM, LAST_APPLICATION              ! V21 
	INTEGER*4   REQUEST_TYPE
	INTEGER*4   I, II,
     *		    LODNUM,
     *		    MESS(EDLEN),
     *		    ROMID,
     *		    SEG,
     *		    SUBTYP,
     *		    TERTIN,
     *		    TYPE
	INTEGER*4   CMP_MASK           !COMPRESSED SEGMENT MASK
	INTEGER*4   SEG_MASK           !SEGMENT MASK
        INTEGER*4   SEG_EXT_MASK       !V20--EXTENDED SEGMENT MASK
 	INTEGER*4   SEGPTR             !SEGMENT POINTER INTO MSGCOM
	INTEGER*4   BASE_SEGMENT
	INTEGER*4   LOAD_LENGTH
	INTEGER*4   TEMPTAB(30)
	INTEGER*4   I4TEMP, I4
	INTEGER*4   STATION, CLASS, SUBNETWORK
	INTEGER*4   DLL_REQ_LOAD_DELAY
	INTEGER*4   DLL_ENABLE
	INTEGER*4   DLL_BACKGROUND_FLAG
	INTEGER*4   MATCH_ANY /42/	   !IN ROMID THIS NO IS ANY MATCH
C jaga removed ORIG_LOAD bcoz not used anywherer below line 
 	INTEGER*4   ACTIVE, BACKG 
C	INTEGER*4   ORIG_LOAD, ACTIVE, BACKG ! jaga commented
C
	INTEGER*2   I2TEMP(2), I2(2)
	INTEGER*2   OUTLEN, MESNUM
	INTEGER*2   SAVE_OUTLEN
C
	LOGICAL	    ERROR /.FALSE./
	LOGICAL     CMPFLG             !REQUEST FOR COMPRESSED SEG FLAG
	LOGICAL	    USE_ENVELOPE
C
	BYTE	    MESTAB(*)
	BYTE	    BTEMPTAB(120)
	BYTE	    I1TEMP(4), I1(4)
	BYTE	    ENVELOPE_MASK(2) /'10'X,'57'X/
C
	EQUIVALENCE (TEMPTAB,BTEMPTAB)
	EQUIVALENCE (I4TEMP,I2TEMP,I1TEMP)
	EQUIVALENCE (I4,I2,I1)
C
	DATA        CMP_MASK/Z0000F000/
	DATA        SEG_MASK/Z00000FFF/
        DATA        SEG_EXT_MASK/Z0000FFFF/    !V20

C
        SAVE ONCE
C
C	ADD TO STATS LAST APPLICATION NO
C
	IF (ONCE.EQ.0) THEN    !IF 1-ST RUN INITIALIZE REQUEST COMMON
	   ONCE=-1
	   CALL FASTSET(0,DLLREQ_LAST,3*NUMAGT/2)
	   CALL FASTSET(0,DLLREQ_HIGH,3*NUMAGT/2)
	   CALL FASTSET(0,DLLREQ_TIME,NUMAGT)
	   CALL FASTSET(0,DLLREQ_BAD_ORDER,NUMAGT/2)
	   CALL FASTSET(0,DLLREQ_BAD_SAME,NUMAGT/2)
	   CALL FASTSET(0,DLLREQ_BAD_SAME_MCP,NUMAGT/2)
	   CALL FASTSET(0,DLLREQ_TOTAL,NUMAGT/2)
	   DLLREQ_MCP_RESET_ENABLE=3    !TELL ABOUT LOOP ON MCP
C                                        AFTER 3 SAME REQUESTS, RESET AFTER 5
	   DLLREQ_RESET_ENABLE=2      !TELL ABOUT LOOPING ON SAME SEGS
C                                      AFTER 3 SAME REQUESTS
	   DLLREQ_SAME_DIF_TIME=90   !SUBSEQUENT MCP SEG 0 REQUEST HAVE
C                                     TO BE WITHIN 90 SEC TO KICK RESET
	   CALL FASTSET(0,RE_LOADS_PER_INTERVAL,
     *				  2*MAXLOADS*MAXAPP*(RE_MAX_SUBNET+1))
	   CALL FASTSET(0,RE_LOADS_TOTAL,
     *				  MAXLOADS*MAXAPP*(RE_MAX_SUBNET+1))
	   CALL FASTSET(0,RE_SEG0_TOTAL,
     *				  MAXLOADS*MAXAPP*(RE_MAX_SUBNET+1))
	   CALL FASTSET(0,RE_TERMINALS_PER_INTERVAL,
     *				  2*MAXLOADS*MAXAPP*(RE_MAX_SUBNET+1))
	   CALL FASTSET(0,RE_STATIONS_PER_INTERVAL,
     *				  2*MAXLOADS*MAXAPP*(RE_MAX_SUBNET+1))
	   CALL FASTSET(TRABUF(TTIM),RE_LAST_REFRESH_TIME,RE_MAX_SUBNET+1)
	   CALL FASTSET(60,RE_TIME_INTERVAL,RE_MAX_SUBNET+1) !REQ STATS UPDATE
C							      INTERVAL
	   CALL FASTSET(0,RE_TOTAL_REQUESTS_GRAPH,(RE_MAX_TOT_GRAPH+1)*
     *					(RE_MAX_SUBNET+1))!
	   CALL FASTSET(0,RE_TOTAL_REQUESTS,RE_MAX_SUBNET+1)
	   CALL FASTSET(0,RE_LOAD_DONE_CNT,RE_MAX_SUBNET+1)
	ENDIF
C
C INITIALIZE SOME VARIABLES
C
	USE_ENVELOPE = .FALSE.
	SAVE_OUTLEN = OUTLEN
	LODNUM = 0
	OUTLEN = 0
	MESNUM=0
	SEG    = 0
	ERROR  = .FALSE.
	CMPFLG = .FALSE.
	TER=TRABUF(TTER)
        STATION=X2XT_STATION_NO(TER)
	CLASS=0
	SUBNETWORK=0
	IF (STATION.NE.0) CLASS=X2XS_STNCLS(STATION)
	IF (CLASS.NE.0)   SUBNETWORK=X2XC_SUBNETWORK(CLASS)
C
C       GET DOWNLOAD TYPE & SUBTYPE
C
	CALL ILBYTE(TYPE, MESTAB(1), 1)
	SUBTYP = IAND(TYPE, 15)
	TYPE   = ISHFT(TYPE, -4)
D       CALL OPS('TYPE : ',TYPE,0)
D       CALL OPS('SUBTYPE : ',SUBTYP,0)
C
C	CHECK FOR MCP LOOPBACK 
C
	IF(TYPE.EQ.DLL_TYPE_TERMINAL .AND.
     *	   SUBTYP.EQ.DLL_SUBTYP_LOOPBACK) THEN  ! LOOPBACK 
	    TRABUF(TSFUN)=TLBACK
	    CALL LOOPSUB(TRABUF,MESTAB,OUTLEN)
	    RETURN
	ENDIF
C
C       "END OF DOWNLOAD" MESSAGE.
C
	IF(TYPE.EQ.DLL_TYPE_TERMINAL .AND.
     *	  SUBTYP.EQ.DLL_SUBTYP_LOAD_DONE) THEN  !END OF DLL 
          DLLREQ_TIME(TER)=TRABUF(TTIM)
	  RE_LOAD_DONE_CNT(SUBNETWORK)=RE_LOAD_DONE_CNT(SUBNETWORK)+1
	  OUTLEN=3
	  RETURN
	ENDIF
C
C       IF TYPE = DLL_TYPE_GVT_SOFTL OR DLL_TYPE_GVT THEN THIS IS FOR A GVT
C
	CALL FASTMOV(MESTAB,TEMPTAB,30)
	IF (TYPE .EQ. DLL_TYPE_GVT_SOFTL) THEN
D         CALL OPS(' IN GVT SOFT',0,0)
          CALL MOVBYTN(MESTAB, 3, ROMID, 3, 2)          ! GVT ROM ID
          LODNUM = 1
          CALL MOVBYT(MESTAB, 5, SEG, 1, 2)
          DO 50 I = 1, MAXSFT
             IF (ROMID .EQ. SFTROM(I)) THEN
                APPLICATION_NO = SFT_APP_NO + SFT_LIST(I) - 1  
                GOTO 200
             ENDIF
50        CONTINUE
          CALL OPS('PRMDLL SFT load incorrectly configured',TER,ROMID)
          ERROR = .TRUE.
          GOTO 300
        ENDIF
C
        IF (TYPE .EQ. DLL_TYPE_GVT) THEN 
	  CMPFLG=.FALSE.
	  IF(SUBTYP.EQ.DLL_SUBTYP_GVT_COMPRESSED) CMPFLG=.TRUE.
          CALL MOVBYTN(MESTAB, 3, ROMID, 3, 2)          ! GVT ROM ID
          LODNUM = 1
          CALL MOVBYT(MESTAB, 5, SEG, 1, 2)
          DO 60 I = 1, MAXSFT
             IF (ROMID .EQ. SFTROM(I)) THEN
                APPLICATION_NO = GVT_APP_NO + GVT_LIST(I) -1
                GOTO 200
             ENDIF
60        CONTINUE
          CALL OPS('PRMDLL SFT load incorrectly configured',TER,ROMID)
          ERROR = .TRUE.
          GOTO 300
        ENDIF
C
C       IF SUBTYP = DLL_SUBTYP_MCP THEN SEND MCP FOR APPROPRIATE ROM TYPES
C
	IF (SUBTYP .EQ. DLL_SUBTYP_MCP) THEN
	  CALL MOVBYT(MESTAB, 3, ROMID, 1, 4)
	  CALL MOVBYTN(MESTAB, 7, SEG, 3, 2)
	  I4TEMP=ROMID
	  DO 150, I = 1, SFT_APP_NO-1
	    I2(1)=SMFDLTAB(MCP_LOAD_NO,DLL_ROMREV,I)
	    I2(2)=SMFDLTAB(MCP_LOAD_NO,DLL_ROMREV1,I)
	    DO II=1,4
		IF (I1(II).NE.I1TEMP(II) .AND.
     *		    I1(II).NE.MATCH_ANY) GOTO 150
	    ENDDO	    		
	    LODNUM = MCP_LOAD_NO
	    APPLICATION_NO=I
	    GOTO 200
150	  CONTINUE
C
C         IF NOT FOUND SEND FIRST MCP AS DEFAULT
C
D         CALL OPS('USING DEFAULT MCP ',0,0)
	  LODNUM = 1		
	  APPLICATION_NO=1
C
C        IF SUBTYP = DLL_SUBTYP_BGROUND_APP OR DLL_BGROUND_DRIVER
C	 THEN SEND APPLICATION LOAD (NEW FORMAT)
C
	ELSE IF (SUBTYP .EQ. DLL_SUBTYP_BGROUND_APP .OR. 
     *	         SUBTYP .EQ. DLL_SUBTYP_BGROUND_DRIVER)	  THEN
	  USE_ENVELOPE=.TRUE.
	  TERTIN = 0
	  CALL MOVBYTN(MESTAB, 3, LODNUM, 4, 1)
	  LODNUM = LODNUM + FCL_LOAD_NO
	  CALL MOVBYTN(MESTAB, 4, TERTIN, 4, 1)
	  CALL MOVBYTN(MESTAB, 5, SEG, 3, 2)
C
C	  MOVE LOAD NAME AND LOAD REV (LOAD_NAME, LOAD REV)
C
	  CALL MOVBYTN(MESTAB, 7, LOAD_REV, 3, 2)! LOAD REVISION
	  CALL MOVBYT(MESTAB, 9, LOAD_NAME, 1, 4)! LOAD NAME
          
C         
	  DO  I = 1, SFT_APP_NO-1
	      LOAD_ID = ZEXT(SMFDLTAB(LODNUM,TERMINAL_ID_NO,I))
  	      IF (IAND(TERTIN,LOAD_ID).EQ.TERTIN) THEN
                TMP_VAL = ZEXT(SMFDLTAB(LODNUM,LODREV,I))
		IF (SMFDLNAM(1,LODNUM,I).EQ.LOAD_NAME .AND.
     *		    TMP_VAL.EQ.LOAD_REV) THEN
			APPLICATION_NO=I
			GOTO 165
		ENDIF
	      ENDIF
	  END DO
C
C         DEFAULT TO THE FIRST ACL
C
D         CALL OPS(' USING DEFAULT ACL',0,0)  
	  LODNUM = ACL_LOAD_NO	
	  APPLICATION_NO = 1
	  SEG=0
165	  CONTINUE
C
C       IF SUBTYP = DLL_SUBTYP_OLD_APP OR DLL_SUBTYP_OLD_DRIVER
C       THEN SEND APPLICATION LOAD
C
	ELSE IF (SUBTYP .EQ. DLL_SUBTYP_OLD_APP .OR. 
     *		 SUBTYP .EQ. DLL_SUBTYP_OLD_DRIVER) THEN
	  USE_ENVELOPE=.FALSE.
	  TERTIN = 0
	  CALL MOVBYTN(MESTAB, 3, LODNUM, 4, 1)
	  CALL MOVBYTN(MESTAB, 4, TERTIN, 4, 1)
	  CALL MOVBYTN(MESTAB, 5, SEG, 3, 2)
C
	  LODNUM=LODNUM+FCL_LOAD_NO
	  DO I = 1, SFT_APP_NO-1
	      LOAD_ID=ZEXT(SMFDLTAB(LODNUM,TERMINAL_ID_NO,I))
  	      IF (IAND(TERTIN,LOAD_ID).EQ.TERTIN) THEN
			APPLICATION_NO=I
			GOTO 175
	      ENDIF
	  END DO
D         CALL OPS(' USING DEFAULT FCL',0,0)  
	  LODNUM=FCL_LOAD_NO	!DEFAULT TO THE FIRST FCL LOAD IF LOAD NOT FOUND

	  APPLICATION_NO=1
175	  CONTINUE
C
C
C
	ELSEIF (SUBTYP.EQ.DLL_SUBTYP_ACL) THEN   !ACL LOAD
C
C	  IF TERMINAL IN THE TEST MODE, KEEP TERMINAL LOAD
C
	  IF (CLASS.NE.0) THEN  !CHECK FOR VALID CLASS V23
	    IF (X2X_ENABLE_TEST_DLL.EQ.0 .AND. 
     *	        X2XC_ENABLE_TEST_DLL(CLASS).EQ.0) THEN
	        OUTLEN=SAVE_OUTLEN
	        RETURN
	    ENDIF
	  ENDIF
C
C	  FIND THE ACL ON THE BASIS OF TIN
C
	  CALL ILBYTE(REQUEST_TYPE,MESTAB,5-1)
	  IF (REQUEST_TYPE.NE.0) THEN
	      RE_LOAD_DONE_CNT(SUBNETWORK)=RE_LOAD_DONE_CNT(SUBNETWORK)+1
              ACTIVE=0
              BACKG =0
              CALL MOVBYTN(MESTAB, 8, ACTIVE, 3, 2)
              CALL MOVBYTN(MESTAB,14, BACKG , 3, 2)
	  ENDIF
	  TERTIN = 0
          CALL ILBYTE(TERTIN,MESTAB,6-1)
	  SEG=0
	  DO  I = 1, SFT_APP_NO-1
	      LODNUM=ACL_LOAD_NO
              TMP_VAL = ZEXT(SMFDLTAB(LODNUM,TERMINAL_ID_NO,I))
  	      IF ((IAND(TERTIN,TMP_VAL).EQ.TERTIN) .AND.
     *		  (SMFDLNAM(1,ACL_LOAD_NO,I).NE.0)) THEN
		APPLICATION_NO=I
		GOTO 180
	      ENDIF
	  END DO
	  LODNUM=ACL_LOAD_NO	!DEFAULT TO THE FIRST FCL LOAD IF LOAD NOT FOUND

	  APPLICATION_NO=1
180	  CONTINUE
C
C
C
	ELSE
	  ERROR=.TRUE.
	  GOTO 300
	ENDIF
C
C       CHECK IF REQUEST FOR A COMPRESSED SEGMENT, AND
C       MASK OFF COMPRESSED SEGMENT INDICATION NIBBLE.
C       GLOBAL COMPRESSED DLL FLAG, OVERRIDES REQUEST
C       FROM TERMINAL.
C
200	CONTINUE
	IF(LODNUM.LT.1.OR.LODNUM.GT.MAXLOADS) THEN
	  ERROR=.TRUE.
	  GOTO 300
	ENDIF
CV20        IF(IAND(SEG,CMP_MASK).NE.0) CMPFLG=.TRUE.
C...        IF(P(COMPRESSED_LOAD).NE.0) CMPFLG=.FALSE.
	IF (LODNUM .LE. FCL_LOAD_NO) CMPFLG=.FALSE.
CV20        SEG=IAND(SEG,SEG_MASK)

C       START OF V20--WE MAKE THE FOLLOWING ASSUMPTIONS HERE:  FOR ALTURA
C       TERMINAL TYPE, THE NUMBER OF SEGMENTS INSIDE EACH LOAD WILL NEVER EXCEED
C       32767, WHICH WILL ONLY USE THE LOWER 15 BITS OUT OF 16 BITS.  FOR ALL
C       THE OTHER TERMINAL TYPES THE NUMBER OF SEGMENTS INSIDE EACH LOAD WILL
C       NEVER EXCEED 4095, WHICH WILL ONLY USE THE LOWER 12 BITS.  IF UPPER 4
C       BITS OUT OF 16 BITS ARE SET, THE REQUEST IS FOR A NON-ALTURA
C       COMPRESSED SEGMENT.  THE LOWER 12 BITS WILL BE INTERPRETED AS THE
C       SEGMENT NUMBER.  IF ANY OF THE 4 BITS ARE NOT SET, ALL BITS SHOULD
C       BE INTERPRETED AS THE SEGMENT NUMBER.

        IF (IAND(SEG,CMP_MASK) .EQ. CMP_MASK) THEN
          CMPFLG=.TRUE.
          SEG=IAND(SEG,SEG_MASK)
        ELSE
          SEG=IAND(SEG,SEG_EXT_MASK)
        ENDIF

C       END OF V20
  

	IF(SMFDLTAB(LODNUM,C_NBRSEG, APPLICATION_NO).NE.0) THEN
	  SEGPTR=SEG*2
	ELSE
	  SEGPTR=SEG
	ENDIF
C
C IF COMPRESSED SEGMENT IS REQUESTED, CHECK IF WE HAVE IT
C
	IF(CMPFLG) THEN
	  IF(SMFDLTAB(LODNUM,C_NBRSEG, APPLICATION_NO).NE.0) THEN
	    SEGPTR=SEGPTR+1
	  ELSE
	    CMPFLG=.FALSE.
	  ENDIF
	ENDIF
	MESNUM=ZEXT(SMFDLTAB(LODNUM,LODADR, APPLICATION_NO))+SEGPTR
	IF (MESNUM.LE.0 .OR. MESNUM.GT.MSGS) THEN
	    ERROR=.TRUE.
	    GOTO 300
	ENDIF
	TRABUF(TSNEW) = LODNUM
	TRABUF(TSOLD) = SEG
	TRABUF(TSDT1) = APPLICATION_NO
	TRABUF(TSDT2) = 0
	IF(CMPFLG) TRABUF(TSDT2)=1
	TRABUF(TSDT3) = SEGPTR
C
C TELL GVT IF SEGMENT IS COMPRESSED ON NOT
C
	IF(TYPE.EQ.15) THEN
	  IF(CMPFLG) THEN
	    CALL ISBYTE('F2'X,MESTAB,1)
	  ELSE
	    CALL ISBYTE('F0'X,MESTAB,1)
	  ENDIF
	ENDIF
C
C IF MESNUM IS INVALID THEN REJECT
C
	BASE_SEGMENT=ZEXT(SMFDLTAB(LODNUM,LODADR, APPLICATION_NO))
	LOAD_LENGTH=ZEXT(SMFDLTAB(LODNUM,C_NBRSEG, APPLICATION_NO))*2-1
D       CALL OPS('BASE_SEGMENT: ',BASE_SEGMENT,0)
D       CALL OPS('LOAD_LENGTH: ',LOAD_LENGTH,0)
	IF(.NOT.CMPFLG) LOAD_LENGTH=
     *		  ZEXT(SMFDLTAB(LODNUM,NBRSEG, APPLICATION_NO))*2-1
	IF(SMFDLTAB(LODNUM,C_NBRSEG, APPLICATION_NO).EQ.0)
     *    LOAD_LENGTH=SMFDLTAB(LODNUM,NBRSEG, APPLICATION_NO)
	IF(MESNUM.LT.BASE_SEGMENT.OR.
     *     MESNUM.GT.BASE_SEGMENT+LOAD_LENGTH) ERROR=.TRUE.
C
C IF AN ERROR WAS FOUND THEN REJECT DOWNLOAD REQUEST AND LOG MESS.
C
300	CONTINUE
	IF (ERROR) THEN
	  MESS(1) = SPE
	  MESS(2) = TEGEN
	  MESS(3) = 17
	  MESS(4) = LODNUM
	  MESS(5) = SEG
	  CALL QUEMES(MESS)
C
	  MESNUM = HRESET			! SEND HARD RESET
	  TRABUF(TSTAT) = REJT
	  TRABUF(TERR)  = INVL
	ELSE
	   TER=TRABUF(TTER)
	   LAST_LODNUM=DLLREQ_LAST(LOADNBR,TER)
	   LAST_SEG=DLLREQ_LAST(SEGNBR,TER)
           LAST_APPLICATION=DLLREQ_LAST(APPLICATION_NBR,TER)   ! V21
	   IF (LAST_SEG.EQ.SEG .AND. LAST_LODNUM.EQ.LODNUM .AND.
     *	       LODNUM.LE.MCP_LOAD_NO			  .AND.
     *	   TRABUF(TTIM)-DLLREQ_SAME_DIF_TIME.LT.DLLREQ_TIME(TER)) THEN
	      DLLREQ_BAD_SAME_MCP(TER)=DLLREQ_BAD_SAME_MCP(TER)+1
	   ELSEIF (LAST_SEG.EQ.SEG .AND. LAST_LODNUM.EQ.LODNUM .AND.
     *	           LODNUM.GT.MCP_LOAD_NO .AND.                 ! V21
     *             APPLICATION_NO.EQ.LAST_APPLICATION) THEN    ! V21
	      DLLREQ_BAD_SAME(TER)=DLLREQ_BAD_SAME(TER)+1
	   ELSE
	      DLLREQ_BAD_SAME(TER)=0
	      DLLREQ_BAD_SAME_MCP(TER)=0
	   ENDIF
           DLLREQ_ACTIVE(TER) = ACTIVE
           DLLREQ_BACKGRND(TER) = BACKG 
	   DLLREQ_LAST(LOADNBR,TER)=LODNUM
	   DLLREQ_LAST(SEGNBR,TER)=SEG
	   DLLREQ_LAST(APPLICATION_NBR,TER)=APPLICATION_NO
	   PREVIOUS_TERMINAL_TIME=DLLREQ_TIME(TER)
	   DLLREQ_TIME(TER)=TRABUF(TTIM)
C
C        CHECK IF TERMINAL IS ASKING FOR PREVIOUS LOADS
C
           HIGH_APPNUM=DLLREQ_HIGH(APPLICATION_NBR,TER)    ! V21
	   HIGH_LODNUM=DLLREQ_HIGH(LOADNBR,TER)
	   HIGH_SEG=DLLREQ_HIGH(SEGNBR,TER)
	   
	   IF (SEG.NE.0 .AND. HIGH_LODNUM.GT.LODNUM .AND.
     *          HIGH_APPNUM.EQ.APPLICATION_NO) THEN        ! V21
	      DLLREQ_BAD_ORDER(TER)=DLLREQ_BAD_ORDER(TER)+1
	   ELSEIF (SEG.LT.HIGH_SEG .AND. HIGH_LODNUM.EQ.LODNUM .AND.
     *            HIGH_APPNUM.EQ.APPLICATION_NO) THEN      ! V21
	      DLLREQ_BAD_ORDER(TER)=DLLREQ_BAD_ORDER(TER)+1
	   ENDIF
	   IF (SEG.NE.0) THEN
	      DLLREQ_HIGH(LOADNBR,TER)=LODNUM
	      DLLREQ_HIGH(SEGNBR,TER)=SEG
              DLLREQ_HIGH(APPLICATION_NBR,TER) = APPLICATION_NO   ! V21
	   ENDIF
	   IF (DLLREQ_MCP_RESET_ENABLE.NE.0    .AND.
     *	      LODNUM.LE.MCP_LOAD_NO.AND. SEG.EQ.0 .AND.
     *	      DLLREQ_MCP_RESET_ENABLE.LT.DLLREQ_BAD_SAME_MCP(TER)) THEN
	      CALL OPS('Terminal asking for same segs ',TER,LODNUM)
	      CALL OPS('load in loop ',SEG,0)
	      IF(DLLREQ_MCP_RESET_ENABLE+2.LT.DLLREQ_BAD_SAME_MCP(TER))
     *	                                                      THEN
	         DLLREQ_BAD_SAME_MCP(TER)=0
	         IF (P(SUPMCP0).EQ.0) THEN
	            MESNUM=URESET          !SEND ULTIMATE RESET
	            TRABUF(TSTAT)=REJT
	            TRABUF(TERR)=INVL
	            CALL OPS('Sending ultimate RESET ',TER,LODNUM)
	         ENDIF
	      ENDIF
	   ENDIF
	   IF (DLLREQ_RESET_ENABLE.NE.0        .AND.
     *	       DLLREQ_RESET_ENABLE.LT.DLLREQ_BAD_ORDER(TER)) THEN
	      CALL OPS('Terminal asking for lower segs ',TER,LODNUM)
	      CALL OPS('load in loop ',SEG,1024)
	      DLLREQ_BAD_ORDER(TER)=0
	   ENDIF
	   IF (DLLREQ_RESET_ENABLE.NE.0        .AND.
     *	       DLLREQ_RESET_ENABLE.LT.DLLREQ_BAD_SAME(TER))  THEN
	      CALL OPS('Terminal asking for same segs ',TER,LODNUM)
	      CALL OPS('load in loop ',SEG,2048)
	      DLLREQ_BAD_SAME(TER)=0
	   ENDIF
C
C	UPDATE STATS FOR TERINAL AND FOR THE LOADS/SUBNETWORKS
C
	   DLLREQ_TOTAL(TER)=DLLREQ_TOTAL(TER)+1

C
C	UPDATE STATISTICS FOR THIS REQUEST
C jaga - 0 append at the end 
	  IF (STATION.GT.0 .AND. LODNUM.LE.MAXLOADS) THEN !SHOULD NEVER BE 0
	    IF (CLASS.NE.0) THEN	    !SHOULD NEVER BE 0
		IF (SUBNETWORK.GT.RE_MAX_SUBNET) SUBNETWORK=0
		RE_TOTAL_REQUESTS(SUBNETWORK)=
     *		      RE_TOTAL_REQUESTS(SUBNETWORK)+1
		RE_CURRENT_REQUESTS(SUBNETWORK)=
     *		      RE_CURRENT_REQUESTS(SUBNETWORK)+1	
		RE_LOADS_PER_INTERVAL(LODNUM,APPLICATION_NO,SUBNETWORK,2)=
     *		RE_LOADS_PER_INTERVAL(LODNUM,APPLICATION_NO,SUBNETWORK,2)+1
		RE_LOADS_TOTAL(LODNUM,APPLICATION_NO,SUBNETWORK)=
     *		      RE_LOADS_TOTAL(LODNUM,APPLICATION_NO,SUBNETWORK)+1
		IF (SEG.EQ.0)
     *		  RE_SEG0_TOTAL(LODNUM,APPLICATION_NO,SUBNETWORK)=
     *		      RE_SEG0_TOTAL(LODNUM,APPLICATION_NO,SUBNETWORK)+1
		IF (PREVIOUS_TERMINAL_TIME.LE.
     *				  RE_LAST_REFRESH_TIME(SUBNETWORK))
     *		      RE_TERMINALS_PER_INTERVAL(LODNUM,APPLICATION_NO,
     *			    SUBNETWORK,2) = RE_TERMINALS_PER_INTERVAL(
     *				  LODNUM,APPLICATION_NO,SUBNETWORK,2)+1
		PREVIOUS_STATION_TIME=DLLREQ_TIME_STATION(STATION)
		DLLREQ_TIME_STATION(STATION)=TRABUF(TTIM)
		IF (PREVIOUS_STATION_TIME.LE.
     *				  RE_LAST_REFRESH_TIME(SUBNETWORK))
     *                RE_STATIONS_PER_INTERVAL(LODNUM,APPLICATION_NO,
     *		        SUBNETWORK,2)=RE_STATIONS_PER_INTERVAL(LODNUM,
     *				  APPLICATION_NO,SUBNETWORK,2)+1

		IF 
     *		 (MOD(DLLREQ_TOTAL(TER),RE_TOTAL_REQUESTS_GRAPH_UNIT).EQ.1)
     *							      THEN
		 LAST_OFFSET=DLLREQ_TOTAL(TER)/
     *			  RE_TOTAL_REQUESTS_GRAPH_UNIT
		 IF (LAST_OFFSET.LT.RE_MAX_TOT_GRAPH) THEN
		   RE_TOTAL_REQUESTS_GRAPH(LAST_OFFSET,SUBNETWORK)=
     *		    RE_TOTAL_REQUESTS_GRAPH(LAST_OFFSET,SUBNETWORK)-1   
		   RE_TOTAL_REQUESTS_GRAPH(LAST_OFFSET+1,SUBNETWORK)=
     *		    RE_TOTAL_REQUESTS_GRAPH(LAST_OFFSET+1,SUBNETWORK)+1   
		 ENDIF
	        ENDIF
	    ENDIF
	   ENDIF
C
	ENDIF
C
C
C
	IF (SUBNETWORK.GE.0) THEN
	  IF (TRABUF(TTIM).LT.RE_LAST_REFRESH_TIME(SUBNETWORK))
     *	       RE_LAST_REFRESH_TIME(SUBNETWORK)=TRABUF(TTIM)  !MIDNITE ADJ
     	  IF (TRABUF(TTIM).GT. RE_LAST_REFRESH_TIME(SUBNETWORK)+
     *				  RE_TIME_INTERVAL(SUBNETWORK)) THEN
C
C	UPDATE REQUEST STATISTICS IF INTERVAL EXPIRED
C
	    IF (RE_TIME_INTERVAL(SUBNETWORK).LE.0)
     *		  RE_TIME_INTERVAL(SUBNETWORK)=60
	    CALL FASTMOV(RE_LOADS_PER_INTERVAL(1,1,SUBNETWORK,2),
     *		RE_LOADS_PER_INTERVAL(1,1,SUBNETWORK,1),MAXLOADS*MAXAPP)
	    CALL FASTMOV(RE_TERMINALS_PER_INTERVAL(1,1,SUBNETWORK,2),
     *		RE_TERMINALS_PER_INTERVAL(1,1,SUBNETWORK,1),MAXLOADS*MAXAPP)
	    CALL FASTMOV(RE_STATIONS_PER_INTERVAL(1,1,SUBNETWORK,2),
     *          RE_STATIONS_PER_INTERVAL(1,1,SUBNETWORK,1),
     *			  MAXLOADS*MAXAPP)
	    CALL FASTSET(0,RE_LOADS_PER_INTERVAL(1,1,SUBNETWORK,2),
     *						MAXLOADS*MAXAPP)
	    CALL FASTSET(0,RE_TERMINALS_PER_INTERVAL(1,1,SUBNETWORK,2),
     *						MAXLOADS*MAXAPP)
	    CALL FASTSET(0,RE_STATIONS_PER_INTERVAL(1,1,SUBNETWORK,2),
     *						MAXLOADS*MAXAPP)

	    RE_LAST_REFRESH_TIME(SUBNETWORK)=TRABUF(TTIM)

	  ENDIF
	ENDIF
	TRABUF(TSDT3)=X2XT_NETWORK_DELAY(TRABUF(TTER))
C
C	PUT DOWNLOAD ENVELOPE IF NEEDED

	IF (CLASS.NE.0) THEN
	  IF (USE_ENVELOPE .AND. X2X_DLL_USE_ENVELOPE.EQ.0 .AND. 
     *		  X2XC_DLL_USE_ENVELOPE(CLASS).EQ.0) THEN
	    DLL_BACKGROUND_FLAG=X2XC_DLL_BACKGROUND_FLAG(CLASS)
	    IF (X2X_DLL_BACKGROUND_FLAG.NE.0)
     *		  DLL_BACKGROUND_FLAG=X2X_DLL_BACKGROUND_FLAG
C
C
C
	    IF (SMFDLTAB(LODNUM,FOREGROUND_FLAG,APPLICATION_NO).EQ.
     *		  FOREGROUND_LOAD) THEN
		DLL_ENABLE=X2XC_DLL_ENABLE_FORGROUND(CLASS)
		IF (X2X_DLL_ENABLE_FORGROUND.NE.0)
     *		  DLL_ENABLE=X2X_DLL_ENABLE_FORGROUND
		DLL_REQ_LOAD_DELAY=X2XC_REQ_FORGROUND_DELAY(CLASS)
		IF (X2X_REQ_FORGROUND_DELAY.NE.0)
     *		  DLL_REQ_LOAD_DELAY=X2X_REQ_FORGROUND_DELAY
	    ELSE
		DLL_ENABLE=X2XC_DLL_ENABLE_BACKGROUND(CLASS)
		IF (X2X_DLL_ENABLE_BACKGROUND.NE.0)
     *		  DLL_ENABLE=X2X_DLL_ENABLE_BACKGROUND
		DLL_REQ_LOAD_DELAY=X2XC_REQ_BACKGROUND_DELAY(CLASS)
		IF (X2X_REQ_BACKGROUND_DELAY.NE.0)
     *		  DLL_REQ_LOAD_DELAY=X2X_REQ_BACKGROUND_DELAY
	    ENDIF

	    MESTAB(1)=ENVELOPE_MASK(1)	    
	    MESTAB(2)=ENVELOPE_MASK(2)	    
	    I2TEMP(1)=DLL_REQ_LOAD_DELAY
	    MESTAB(3)=I1TEMP(2)
	    MESTAB(4)=I1TEMP(1)
	    MESTAB(5)=DLL_ENABLE
	    MESTAB(6)=DLL_BACKGROUND_FLAG
	    OUTLEN=6		
	  ENDIF
	ENDIF
	RETURN
	END
C MONICAT TEST DLETED 
C MONICA::TEST> 
