C
C SUBROUTINE PTLSNP
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFIP:[GOLS]PTLSNP.FOV                                   $
C  $Date::   18 Mar 1997 15:27:30                                         $
C  $Revision::   1.1                                                      $
C  $Author::   RXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C
C ** Source - vis_ptlsnp.for **
C
C PTLSNP.FOR
C
C
C X2X Upgrade: 22-FEB-96 wsm Added PRMAGT.DEF, AGTINF.DEF for Finland.
C
C V07 07-AUG-95 SCD CHANGES TO DISPLAY EXTENDED ADDRESSING IN PORT CONF.
C V06 07-JUL-95 SCD FIXED SPELLING ERROR (acknowlegement VS. acknowledgement)
C V05 24-JAN-95 GS  FIXED GENERAL STATION CONFIG DECODE TO ONLY DISPLAY
C		    ALTERNATE OUTCALL ADDRESS IF COUNT > 0
C V04 29-SEP-94 GPR ONLY DISPLAY DIALUP AND X32 IF PRESENT
C V03 18-AUG-94 GPR HANDLE 12 CHAR ADR FOR UK
C V02 16-AUG-94 GPR USE X2FROPEN AND X2RCLOSE
C V01 01-DEC-91 DAS RELEASED FOR VAX (NETHERLANDS)
C
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE PTLSNP(IDX,CMDLIN)
	IMPLICIT NONE 
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:PRMAGT.DEF'
	INCLUDE 'INCLIB:AGTINF.DEF'
	INCLUDE 'INCLIB:VISCOM.DEF'
	INCLUDE 'INCLIB:X2VIS.DEF'				    !V03
	INCLUDE 'INCLIB:LANCOM.DEF'
	INCLUDE 'INCLIB:X2FCOM.DEF'
	INCLUDE 'INCLIB:X2PTLMES.DEF'
	INCLUDE 'INCLIB:X2FEMES.DEF'
	INCLUDE 'INCLIB:X2STMES.DEF'
C
	INTEGER*2    LENGTH
        INTEGER*4    K, PTLCODE, I, PNT, CHKVAL, OFFMES, S, M, H, PTR
        INTEGER*4    OFFSET, XCODE, XLAYER, MSG_NO, SERIAL_NO, LEN
        INTEGER*4    DIR, STATUS, KEYNUM, POS, BACKLINK, IDX, PTM
        INTEGER*4    DISP_LEN, OFF, HDLC_LINE, FE_ID, CON_START, DURTIM
        INTEGER*4    H_DURTIM, M_DURTIM, S_DURTIM, EST_TIME, TER_CODE
        INTEGER*4    DIAG_CODE, NET_ERR, ADR_LEN, STN_NO, SRCSTAT, OFF2
        INTEGER*4    OFF1, MSG_SENT, MSG_RCV, BITOFF, MOFF, BINDX
        INTEGER*4    CINDX, SINDX
C
        INTEGER*4 X32LEN
        INTEGER*4 CONTYPE
        INTEGER*4 CONTYPE_OFFSET
        INTEGER*4 VSLEN_OFFSET
        INTEGER*4 VS_OFFSET
        INTEGER*4 EVSNLEN
        INTEGER*4 EVSNNUM(X2X_EVSN_MAXLEN)
C
	INTEGER*4    BUFFER(X2FRSIZ)
	INTEGER*4    MESSAGE(60)
	INTEGER*4    CMDLIN(20)                  !Input command line
	INTEGER*4    HEXORDFLG, MESSOFFSET, ERR, SYSTMFLD, TEMP
	INTEGER*4    MESSAGEDEC(40)
	INTEGER*4    BAUDARRAY(0:8) /1800, 300,1200,1800,
     *	                             2400,3600,4800,9600,19200/
C
	PARAMETER (MOFF=10)       !LENGTH OF CONTROL HEADER
	CHARACTER*10 ALAY(0:4)
	CHARACTER*10 ADIR(0:1)
        CHARACTER*3  ONOFF(0:1)
        DATA ONOFF/'Off',' On'/
        CHARACTER*8 CLKTYP(0:1)
        DATA CLKTYP/'Internal','External'/
        CHARACTER*5 SYNTYP(0:1)
        DATA SYNTYP/'Async',' Sync'/
	CHARACTER*1  ASCADDRESS(20)
	INTEGER*4 STNADD(2)
	CHARACTER*1  BLANKS(DADRL)				    !V03
	CHARACTER    LINBUF(80)*1  /80*' '/
	REAL*8       CMDOPT(3)                  !Command line options
	DATA         CMDOPT      /'BAck    ','HEx     ','MOre    '/
	DATA ADIR /' inbound  ',' outbound '/
	DATA ALAY /'   illegal',
     *	           '       gtp',
     *	           '        fe',
     *	           '   station',
     *	           '    global'/
	DATA BLANKS /DADRL*' '/					    !V03
	DATA BACKLINK / 0 /
	CHARACTER*1 HEX_TAB(64)
	LOGICAL CMD_RESPONSE, MORE, OLDP
C
C CHECK FOR INPUT COMMAND LINE.
C
	MORE = .FALSE.
	SMODE=.TRUE.
	POS=1
	HEXORDFLG = 0
	DO 30 K = 1, 24
	  WRITE(XNEW(  K),900)
30	CONTINUE
	CALL KEY(CMDLIN,CMDOPT,3,POS,KEYNUM)
	IF(KEYNUM.EQ.0) GOTO 100
C
	GOTO (50,70,90) KEYNUM
	WRITE(CLIN24,902)
902	FORMAT('Invalid input ')
	GOTO 100
C
C LINK BACKWARD.
C
50	CONTINUE
	IDX=BACKLINK
	HEXORDFLG = 1
	GOTO 100
C HEX MODE
70	CONTINUE
	HEXORDFLG = 1
	GO TO 100
C
C MORE TO DECODE ON NEXT PAGE
90	CONTINUE
	MORE = .TRUE.
	GO TO 100
C
C DISPLAY SCREEN.
C
100	CONTINUE
	IF(IDX.LE.0) IDX=P(X2XIDX)
	IF(IDX.LE.0) IDX=1
	WRITE(CLIN1,901) IDX,P(X2XIDX)
901	FORMAT('PTL transaction ',I8,'[',I8,']')
C
C OPEN THE FILE AND READ THE BUFFER.
C
        CALL X2FROPEN					   !V02
        CALL X2FREAD(BUFFER,IDX,STATUS)
	IF(STATUS.NE.0) THEN
	   WRITE(CLIN23,990) IDX,STATUS,P(X2XIDX)
990	   FORMAT('X2X file read error ',I9,' error code ',Z8,
     *	          ' x2xidx ',I9)
	   CALL X2FRCLOSE				   !V02
	   RETURN
	ENDIF
C
C CONVERT TO TRABUF FORMAT.
C
	CALL XTOBUF(TRABUF,MESSAGE,BUFFER,DIR,LENGTH)
	H=TRABUF(TTIM)/3600
	M=(TRABUF(TTIM)-H*3600)/60
	S=TRABUF(TTIM)-(H*3600+M*60)
	IF (HEXORDFLG .EQ. 1) GO TO 111
	GO TO 310
C
C NOW DISPLAY INFORMATION IN HEX.
C
111	CONTINUE
	WRITE(CLIN2,900)
900	FORMAT(80(' '))
C
C IF A TRACE TERMINAL TRANSACTION EXTRACT THE
C TERMINAL NUMBER AND LENGTH.
C
	LEN=0
	SERIAL_NO=0
	MSG_NO=0
	CALL ILBYTE(XLAYER,MESSAGE,X2PRO_TRATYP-1) !3RD BYTE
	CALL ILBYTE(XCODE,MESSAGE,X2PRO_STATUS-1)  !6TH BYTE
	CALL ILBYTE(OFFSET,MESSAGE,X2PRO_OFFSET-1)
	PTR=(OFFSET*2)+(OFFSET/4)-1
C
	IF(XLAYER.EQ.X2X_TRATYP_GLO .AND.
     *	  (XCODE.EQ.X2ERR_GLO_TRACE_TER_INP .OR.
     *	   XCODE.EQ.X2ERR_GLO_TRACE_TER_OUT)) THEN
	  CALL MOV2TOI4(LEN,MESSAGE,X2PRO_MSGLEN-1)
	  CALL MOV4TOI4(SERIAL_NO,MESSAGE,X2PRO_SERIAL-1)
	  CALL MOV2TOI2(MSG_NO,MESSAGE,X2PRO_MSGNUM-1)
	  LINBUF(PTR)='+'
	  PTM = (X2PRO_TRACE_MSG*2) + (X2PRO_TRACE_MSG/4) - 1
	  LINBUF(PTM) = '*'
	ENDIF
C
	IF(SERIAL_NO.EQ.0) THEN
	  WRITE(CLIN3,903) TRABUF(TXIDX),TRABUF(TSER)
903	  FORMAT('Index     ',I10,2X,'Cross ser ',I10,22(' '))
	ELSE
	  WRITE(CLIN3,9031) TRABUF(TXIDX),TRABUF(TSER),SERIAL_NO
9031	  FORMAT('Index     ',I10,2X,'Cross ser ',I10,2X,
     *	         'Serial    ',I10)
	ENDIF
C
	BACKLINK=TRABUF(TXBAK)
C
	IF(LEN.EQ.0) THEN
	  WRITE(CLIN4,904) TRABUF(TCDC),H,M,S
904	  FORMAT('CDC       ',I10,2X,'Time        ',I2.2,':',I2.2,
     *	         ':',I2.2,22(' '))
	ELSE
	  WRITE(CLIN4,9041) TRABUF(TCDC),H,M,S,LEN
9041	  FORMAT('CDC       ',I10,2X,'Time        ',I2.2,':',I2.2,
     *	         ':',I2.2,2X,'Mes len   ',I10)
	ENDIF
C
	IF(MSG_NO.EQ.0) THEN
	  WRITE(CLIN5,905) TRABUF(TXSTN),TRABUF(TTER)
905	  FORMAT('Station   ',I10,2X,'Terminal  ',I10,22(' '))
	ELSE
	  WRITE(CLIN5,9051) TRABUF(TXSTN),TRABUF(TTER),MSG_NO
9051	  FORMAT('Station   ',I10,2X,'Terminal  ',I10,2X,
     *	         'Mess num  ',I10)
	ENDIF
C
	WRITE(CLIN6,906) TRABUF(TXSAP),ALAY(TRABUF(TXLAY)),ADIR(DIR)
906	FORMAT('SAP       ',I10,2X,'Layer     ',A10,5X,A10,'message')
	WRITE(CLIN7,907) TRABUF(TXPTL), TRABUF(TXBAK)
907	FORMAT('PTL code  ',I10,2X,'Back link ',I10)
C
	WRITE(CLIN8,900)
C
C SET DIRECTION POINTER.
C
	LEN=0
	OFFMES=0
	IF(DIR.EQ.XLOG_DIR_IN) THEN
	   CALL ILBYTE(OFFMES,MESSAGE,X2PRO_OFFSET-1)
           IF(OFFMES.LT.11 .OR. OFFMES.GT.90) THEN
	      WRITE(CLIN23,991) IDX,TRABUF(TSER),OFFMES
991	      FORMAT('X2X record invalid ',I9,1X,I9,1X,Z8)
	      PNT=10
	      GOTO 800
	   ENDIF
	   LEN=BUFFER(XLOG_MLEN)
	   LINBUF(PTR)='+'
	ELSEIF(DIR.EQ.XLOG_DIR_OUT) THEN
	   LEN=BUFFER(XLOG_MLEN)
	   OFFMES=1
	ENDIF
C
C DISPLAY MESSAGE LENGTH.
C
	WRITE(CLIN9,909) LEN,OFFMES
909	FORMAT('Message (in HEX) of length ',I5,3X,'data offset =',I5)
C
C DISPLAY POINTER SHOWING WHERE ACTUAL MESSAGE BUFFER
C STARTS.
C
	WRITE(CLIN10,910) (LINBUF(I),I=1,80)
910	FORMAT(80A)
C
C DISPLAY MESSAGE IN HEX.
C
	PNT=11
	DO 890 I=PNT,22
	  WRITE(XNEW(  I),9200)
9200	  FORMAT(80(' '))
890	CONTINUE
C
C DISPLAY MESSAGE LINE 2.
C
800	CONTINUE
	DISP_LEN=LEN*2
	IF(LEN.GT.0) THEN
	   CALL I4TOHEX(MESSAGE(1),HEX_TAB,64)
	   WRITE(CLIN11,911) (HEX_TAB(I),I=1,MIN0(64,DISP_LEN))
911	   FORMAT(8(8A1,1X))
	   PNT=12
	ENDIF
C
C DISPLAY MESSAGE LINE 3.
C
	IF(LEN.GT.32) THEN
	   CALL I4TOHEX(MESSAGE(9),HEX_TAB,64)
	   DISP_LEN=DISP_LEN-64
	   WRITE(CLIN12,911) (HEX_TAB(I),I=1,MIN0(64,DISP_LEN))
	   PNT=13
	   IF(LEN.GT.64) THEN
	      CALL I4TOHEX(MESSAGE(17),HEX_TAB,64)
	      DISP_LEN=DISP_LEN-64
	      WRITE(CLIN13,911) (HEX_TAB(I),I=1,MIN0(64,DISP_LEN))
	      PNT=14
	   ENDIF
	   IF(LEN.GT.96) THEN
	      CALL I4TOHEX(MESSAGE(25),HEX_TAB,64)
	      DISP_LEN=DISP_LEN-64
	      WRITE(CLIN14,911) (HEX_TAB(I),I=1,MIN0(64,DISP_LEN))
	      PNT=15
	   ENDIF
	   IF(LEN.GT.128) THEN
	      CALL I4TOHEX(MESSAGE(33),HEX_TAB,64)
	      DISP_LEN=DISP_LEN-64
	      WRITE(CLIN15,911) (HEX_TAB(I),I=1,MIN0(64,DISP_LEN))
	      PNT=16
	   ENDIF
	   IF(LEN.GT.160) THEN
	      CALL I4TOHEX(MESSAGE(41),HEX_TAB,64)
	      DISP_LEN=DISP_LEN-64
	      WRITE(CLIN16,911) (HEX_TAB(I),I=1,MIN0(64,DISP_LEN))
	      PNT=17
	   ENDIF
	   IF(LEN.GT.192) THEN
	      CALL I4TOHEX(MESSAGE(49),HEX_TAB,64)
	      DISP_LEN=DISP_LEN-64
	      WRITE(CLIN17,911) (HEX_TAB(I),I=1,MIN0(64,DISP_LEN))
	      PNT=18
	   ENDIF
	ENDIF
C
	WRITE(XNEW(  PNT),900)
	PNT=PNT+1
C
C DISPLAY MESSAGE DESCRIPTOR.
C
	PTLCODE=TRABUF(TXPTL)
	IF(PTLCODE.GE.0.AND.PTLCODE.LE.256) THEN
	   WRITE(XNEW(  PNT),912) X2X_PTLMES(PTLCODE)
912	   FORMAT('Message descriptor: <',A40,'>')
	   PNT=PNT+1
	ENDIF
      IF (DIR.EQ.XLOG_DIR_IN .AND. TRABUF(TXPTL).EQ.X2ERR_BADADR) THEN
C****	  CALL ILBYTE(MESSAGEDEC(9),MESSAGE,X2FEMES_ADRLEN+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(9),MESSAGE,X2PRO_ADR_LEN-1)
	  IF (MESSAGEDEC(9) .GT. 0) THEN
   	    CALL MOVBYT(MESSAGE,X2PRO_ADR,MESSAGEDEC(10),1,
     *	                   (MESSAGEDEC(9) + 1)/2)
	    CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(9),MESSAGEDEC(10),ERR)
	    IF (MESSAGEDEC(9).GT.DADRL) MESSAGEDEC(9)=DADRL
	    WRITE(XNEW(  PNT),9866) (BLANKS(I), I=1,
     *        DADRL-MIN0(MESSAGEDEC(9),DADRL)),				  !V03
     *	      (ASCADDRESS(I), I = MAX0(MESSAGEDEC(9)-DADRL+1,1),	  !V03
     *				  MESSAGEDEC(9))			  !V03
C***     *	      (ASCADDRESS(I), I = MAX0(MESSAGEDEC(9)-DADRL+1,1),	  !V03
C***     *				  MESSAGEDEC(9))			  !V03
	    PNT = PNT + 1
	  ENDIF
	ENDIF
      IF (DIR.EQ.XLOG_DIR_OUT .AND. TRABUF(TXPTL).EQ.X2ERR_BADADR) THEN
	  CALL ILBYTE(MESSAGEDEC(9),MESSAGE,X2FEMES_ADRLEN-1)
	  IF (MESSAGEDEC(9) .GT. 0) THEN
   	    CALL MOVBYT(MESSAGE,X2FEMES_ADR,MESSAGEDEC(10),1,
     *	                   (MESSAGEDEC(9) + 1)/2)
	    CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(9),MESSAGEDEC(10),ERR)
	    IF (MESSAGEDEC(9).GT.DADRL) MESSAGEDEC(9)=DADRL
	    WRITE(XNEW(  PNT),9866) (BLANKS(I), I=1,
     *        DADRL-MIN0(MESSAGEDEC(9),DADRL)),				  !V03
     *	      (ASCADDRESS(I), I = MAX0(MESSAGEDEC(9)-DADRL+1,1),	  !V03
     *				  MESSAGEDEC(9))			  !V03
C***     *	      (ASCADDRESS(I), I = MAX0(MESSAGEDEC(9)-DADRL+1,1),	  !V03
C***     *				  MESSAGEDEC(9))			  !V03
	    PNT = PNT + 1
	  ENDIF
	ENDIF
C
C BLANK OUT REMAINING LINES.
C
	DO 300 K=PNT,22
	  WRITE(XNEW(  K),900)
300	CONTINUE
	HEXORDFLG = 0
	GO TO 500
310	CONTINUE
	IF (TRABUF(TXPTL) .EQ.X2ERR_FE_CMD) THEN !IF DISCONNECT MESSAGE
	   WRITE(CLIN3,9205) TRABUF(TCDC),H,M,S,TRABUF(TSER)
	   CMD_RESPONSE = .FALSE.
	   CALL ILBYTE(OFF,MESSAGE,X2PRO_OFFSET-1)
	   OFF=OFF-1
	   CALL ILBYTE(HDLC_LINE,MESSAGE,X2FEMES_CONSTS_LINE+OFF-1)
	   CALL MOV4TOI4(FE_ID,MESSAGE,X2FEMES_CONSTS_CONID+OFF-1)
	   FE_ID=IAND(FE_ID,'00FFFFFF'X)
	   CALL MOV4TOI4(CON_START,MESSAGE,X2FEMES_CONSTS_ABSTIM+OFF-1)
	   H=CON_START/3600
	   M=(CON_START-H*3600)/60
	   S=CON_START-(H*3600+M*60)
	   CALL MOV4TOI4(DURTIM,MESSAGE,X2FEMES_CONSTS_DURTIM+OFF-1)
	   H_DURTIM=DURTIM/3600
	   M_DURTIM=(DURTIM-H_DURTIM*3600)/60
	   S_DURTIM=MOD(DURTIM,60)
	   CALL MOV2TOI4(EST_TIME,MESSAGE,X2FEMES_CONSTS_ESTTIM+OFF-1)
	   CALL ILBYTE(TER_CODE,MESSAGE,X2FEMES_CONSTS_TERCOD+OFF-1)
	   TER_CODE = IAND(TER_CODE,X2FEMES_CONSTS_TERCOD_UP)
	   CALL ILBYTE(DIAG_CODE,MESSAGE,X2FEMES_CONSTS_DIACOD+OFF-1)
	   CALL ILBYTE(NET_ERR,MESSAGE,X2FEMES_CONSTS_NETERR+OFF-1)
	   CALL ILBYTE(ADR_LEN,MESSAGE,X2FEMES_CONSTS_ADRLEN+OFF-1)
	   CALL MOV4TOI4(STNADD(1),MESSAGE,X2FEMES_CONSTS_STNADD+OFF-1)
	   CALL MOV4TOI4(STNADD(2),MESSAGE,X2FEMES_CONSTS_STNADD+OFF+3)
           CALL X2QSHFT(STNADD,-(64-ADR_LEN*4))
	   CALL HTOA(ASCADDRESS,1,ADR_LEN,STNADD,ERR)
C
C BINARY SEARCH THE SORTED ADDRESS TABLE TO OBTAIN THE STATION
C NUMBER.  IF IT IS NOT FOUND, OR THE COMMON IS LOCKED,
C SEQUENTIALY SEARCH FOR IT.
C
	   STN_NO = -1
	   CALL X2BINSRC(ADR_LEN,STNADD,STN_NO,SRCSTAT)
	   IF (SRCSTAT.EQ.0) GO TO 327
           DO 322 OFF2=1,X2X_STATIONS
	      IF(ADR_LEN.NE.X2XS_ADRESS_LEN(OFF2)) GOTO 322
	      IF(X2XS_ADRESS(1,OFF2).EQ.0 .AND.
     *	         X2XS_ADRESS(2,OFF2).EQ.0) GOTO 322
	      DO 317 OFF1=1,X2X_ADRESS_MAXLEN
	         IF(X2XS_ADRESS(OFF1,OFF2).NE.STNADD(OFF1))GO TO 322
317	      CONTINUE
	      STN_NO=OFF2
	      GO TO 327
322	   CONTINUE
C
C          STATION NUMBER NOT FOUND YET , SEARCH FOR VERIFICATION NUMBER
C          IF CONNECTION TYPE IS GTECH_DIAL OR X28PAD
C
           CALL ILBYTE(X32LEN,MESSAGE,X2FEMES_CONSTS_X32ADRLEN+OFF-1)
           CONTYPE_OFFSET = X2FEMES_CONSTS_X32ADRLEN + X32LEN + 1
           VSLEN_OFFSET   = CONTYPE_OFFSET + X2FEMES_CONSTS_CONTYPE
           VS_OFFSET      = VSLEN_OFFSET   + X2FEMES_CONSTS_EVS
C
           CALL ILBYTE (CONTYPE, MESSAGE, CONTYPE_OFFSET+OFF-1)
           CALL ILBYTE (EVSNLEN, MESSAGE, VSLEN_OFFSET+OFF-1)
C

           IF((CONTYPE .EQ. X2XSCT_GTECH_DIAL .OR.
     *         CONTYPE .EQ. X2XSCT_X28PAD)    .AND.
     *         EVSNLEN .GT. 0) THEN
               EVSNNUM(1) = 0
               EVSNNUM(2) = 0
               CALL FASTBYT(MESSAGE, VS_OFFSET+OFF, EVSNNUM, 1,
     *                      EVSNLEN)
               CALL X2QSHFT(EVSNNUM,-(64-EVSNLEN*4*2))
               CALL X2BINVSN(EVSNLEN*2, EVSNNUM, STN_NO, SRCSTAT)
           ENDIF
C
327	   CONTINUE
	   CALL MOV2TOI4(MSG_SENT,MESSAGE,X2FEMES_CONSTS_MSGSND+OFF-1)
	   CALL MOV2TOI4(MSG_RCV,MESSAGE,X2FEMES_CONSTS_MSGRCV+OFF-1)
C
	   WRITE (CLIN2,9102) STN_NO
	   WRITE (CLIN4,9104) HDLC_LINE,TRABUF(TXSAP)
	   WRITE (CLIN5,9105) H,M,S,  H_DURTIM,M_DURTIM,S_DURTIM
	   WRITE (CLIN6,9106) DIAG_CODE,NET_ERR
	   WRITE (CLIN7,9107)					      !V03
     *	     (BLANKS(I), I = 1, DADRL-MIN0(ADR_LEN,DADRL)),	      !V03
     *	     (ASCADDRESS(I), I = MAX0(ADR_LEN-DADRL+1,1),ADR_LEN)     !V03
	   WRITE (CLIN8,9108) MSG_SENT,MSG_RCV
	   IF (.NOT. CMD_RESPONSE) THEN
	     IF (TER_CODE .EQ. 0) THEN
	       WRITE(CLIN10, 9110)
	     ELSE
	       WRITE(CLIN10, 9112)
	     ENDIF
	   ELSE
	     IF (CON_START .EQ. 0 .AND. DURTIM .EQ. 0) THEN
	       WRITE(CLIN10, 9110)
	     ELSE
	       WRITE(CLIN10,9112)
	     ENDIF
	   ENDIF
C
	   CALL ILBYTE(ADR_LEN,MESSAGE,X2FEMES_CONSTS_X32ADRLEN+OFF-1)
	   IF(CHKVAL(ADR_LEN,0,15,' X.32 BCD ADR LEN ').EQ.0) THEN
           CALL MOV4TOI4(STNADD(1),MESSAGE,X2FEMES_CONSTS_X32ADDR+OFF-1)
           CALL MOV4TOI4(STNADD(2),MESSAGE,X2FEMES_CONSTS_X32ADDR+OFF+3)
	     CALL HTOA(ASCADDRESS,1,ADR_LEN,STNADD,ERR)
	   ELSE
	     ADR_LEN=0
	   ENDIF
	   WRITE (CLIN7,9113)						!V03 
     *	     (BLANKS(I), I = 1, DADRL-MIN0(ADR_LEN,DADRL)),	        !V03
     *	     (ASCADDRESS(I), I = MAX0(ADR_LEN-DADRL+1,1),ADR_LEN)	!V03
           IF(EVSNLEN.GT.0) THEN
             CALL HTOA(ASCADDRESS,1,EVSNLEN*2,EVSNNUM(1),ERR)
             WRITE(CLIN10,9114)(BLANKS(I),I = 1,10 - (EVSNLEN*2)),
     *                         (ASCADDRESS(I),I = 1, (EVSNLEN*2))
           ENDIF   
C
9102	   FORMAT(' decoded connection data for station ',I6)
9104	   FORMAT(' line used      ',I10,T41,
     *	          ' on SAP         ',I9)
9105	   FORMAT(' connection time  ',I8.8,':',I2.2,':',I2.2,T41,
     *	          ' duration        ',I2,':',I2.2,':',I2.2)
9106	   FORMAT(' clearing cause   ',Z8,T41,
     *	          ' diagnostic cause',Z8)
9107	   FORMAT(' station adr    ',<DADRL>A1)				!V03
9108	   FORMAT(' message sent    ',I9,T41,
     *	          ' messages received',I7)
9110	   FORMAT(10X,'station is disconnected')
9112	   FORMAT(10X,'station is connected')
9113	   FORMAT(' X.32 address   ',<DADRL>A1)				!V03
9114       FORMAT(' GVT serial #   ',12A1)
	   GO TO 500
	ENDIF
	  IF (TRABUF(TXPTL) .EQ. X2ERR_RELAY_CONF .AND.
     *	      DIR .EQ. XLOG_DIR_OUT) THEN
C
C DECODE RELAY CONFIGURATION MESSAGE
C
	  CALL ILBYTE(MESSAGEDEC(1),MESSAGE,X2STMES_RELAY_CNTNO+MOFF-1)
	  CALL MOV2TOI4(MESSAGEDEC(2),MESSAGE,X2STMES_RELAY_STNO
     *	  +MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(3),MESSAGE,X2STMES_RELAY_CMD_ADRLEN
     *	  +MOFF-1)
	  CALL MOVBYT(MESSAGE,X2STMES_RELAY_CMD_ADR+MOFF,MESSAGEDEC(4),
     *	  1,(MESSAGEDEC(3)+1)/2)
CPXN	  CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(3),MESSAGEDEC(4),ERR)
	  CALL BCDASC(ASCADDRESS,1,MESSAGEDEC(3),MESSAGEDEC(4),ERR)
	  IF (ERR .LT. 0) THEN
	    TYPE *, 'error in NHTOA subroutine  ERR = ', ERR
	  ENDIF
	  CALL ILBYTE(MESSAGEDEC(4),MESSAGE,X2STMES_RELAY_MAX_SEG
     *	  +MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(5),MESSAGE,X2STMES_RELAY_RETRY_CNT
     *	  +MOFF-1)
	  CALL MOV2TOI4(MESSAGEDEC(6),MESSAGE,X2STMES_RELAY_RETRY_INT
     *	  +MOFF-1)
	  CALL MOV2TOI4(MESSAGEDEC(7),MESSAGE,X2STMES_RELAY_ACK_TIME
     *	  +MOFF-1)
	  CALL MOV2TOI4(MESSAGEDEC(8),MESSAGE,X2STMES_RELAY_FWD_TIME
     *	  +MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(9),MESSAGE,X2STMES_RELAY_FREE
     *	  +MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(10),MESSAGE,X2STMES_RELAY_ADR_CNT
     *	  +MOFF-1)
	  WRITE(CLIN2,9710)
	  WRITE(CLIN3,9205) TRABUF(TCDC),H,M,S,TRABUF(TSER)
	  WRITE(CLIN4,9720) MESSAGEDEC(1)
	  WRITE(CLIN5,9725) MESSAGEDEC(2)
	  WRITE(CLIN6,9730) MESSAGEDEC(3)
	  WRITE(CLIN7,9735) (BLANKS(M), M = 1, 16 - MESSAGEDEC(3)),
     *	                    (ASCADDRESS(M), M = 1, MESSAGEDEC(3))
	  WRITE(CLIN8,9740) MESSAGEDEC(4)
	  WRITE(CLIN9,9745) MESSAGEDEC(5)
	  WRITE(CLIN10,9750) MESSAGEDEC(6)
	  WRITE(CLIN11,9755) MESSAGEDEC(7)
	  WRITE(CLIN12,9760) MESSAGEDEC(8)
	  WRITE(CLIN13,9765) MESSAGEDEC(10)
	  PNT = 14
	  MESSOFFSET = 23 + MOFF
CPXN	  IF (MESSAGEDEC(10) .GT. 0.AND.MESSAGEDEC(11).GT.0) THEN
	  IF (MESSAGEDEC(10) .GT. 0) THEN
	    DO 330 K = 1, MESSAGEDEC(10)
	      CALL ILBYTE(MESSAGEDEC(11), MESSAGE, MESSOFFSET)
	      MESSOFFSET = MESSOFFSET + 1
	      CALL MOVBYT(MESSAGE,MESSOFFSET+1,MESSAGEDEC(12),1,
     *	      (MESSAGEDEC(11) + 1)/2)
	      MESSOFFSET = MESSOFFSET + (MESSAGEDEC(11) + 1)/2
CPXN	      CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(11),MESSAGEDEC(12),
CPXN *	      ERR)
	      CALL BCDASC(ASCADDRESS,1,MESSAGEDEC(11),MESSAGEDEC(12),ERR)
	      WRITE(XNEW(  PNT),9770) (BLANKS(M),  M = 1, 16 -
     *	      MESSAGEDEC(11)), (ASCADDRESS(M), M = 1, MESSAGEDEC(11))
	      PNT = PNT + 1
	      IF (PNT .GE. 22) GO TO 500
330	    CONTINUE
	  ENDIF
	  GO TO 500
	ENDIF
C
C DECODE UPLINE DELIVERY ACKNOWLEGEMENT
C
	IF (TRABUF(TXPTL) .EQ.X2ERR_ACK) THEN
	  CALL MOV2TOI4(MESSAGEDEC(1),MESSAGE,X2FEMES_MESLEN+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(2),MESSAGE,X2FEMES_PROTID+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(3),MESSAGE,X2FEMES_HOST_ID+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(4),MESSAGE,X2FEMES_MESTYP+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(5),MESSAGE,X2FEMES_HEADLEN+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(6),MESSAGE,X2FEMES_FLAGS+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(7),MESSAGE,X2FEMES_CONNCTL+MOFF-1)
	  CALL MOV4TOI4(MESSAGEDEC(8),MESSAGE,X2FEMES_CONN_ID+MOFF-1)
          MESSAGEDEC(8) = ISHFT(MESSAGEDEC(8),-8)
	  CALL ILBYTE(MESSAGEDEC(9),MESSAGE,X2FEMES_ADRLEN+MOFF-1)
	  WRITE(CLIN2,9830)
	  WRITE(CLIN3,9205) TRABUF(TCDC), H, M, S, TRABUF(TSER)
	  WRITE(CLIN4,9832) MESSAGEDEC(1)
	  WRITE(CLIN5,9834) MESSAGEDEC(2)
	  WRITE(CLIN6,9836) MESSAGEDEC(3)
	  WRITE(CLIN7,9838) MESSAGEDEC(4)
	  WRITE(CLIN8,9840) MESSAGEDEC(5)
	  WRITE(CLIN9,9842)
	  MESSAGEDEC(20) = 0
	  MESSAGEDEC(21) = 0
	  MESSAGEDEC(22) = 0
	  MESSAGEDEC(23) = 0
	  IF (NTSBIT(MESSAGEDEC(6), 24)) MESSAGEDEC(20) = 1
	  IF (NTSBIT(MESSAGEDEC(6), 25)) MESSAGEDEC(21) = 1
	  IF (NTSBIT(MESSAGEDEC(6), 26)) MESSAGEDEC(22) = 1
	  IF (NTSBIT(MESSAGEDEC(6), 27)) MESSAGEDEC(23) = 1
	  WRITE(CLIN10,9844) (MESSAGEDEC(I), I = 20, 23)
	  MESSAGEDEC(24) = ISHFT(MESSAGEDEC(7), -4)
	  TEMP = ISHFT(MESSAGEDEC(7), 4)
	  CALL ILBYTE(MESSAGEDEC(25),TEMP,2)
	  WRITE(CLIN11,9846) MESSAGEDEC(24)
	  WRITE(CLIN12,9848) MESSAGEDEC(25)
	  WRITE(CLIN13,9850) MESSAGEDEC(8)
	  WRITE(CLIN14,9852) MESSAGEDEC(9)
	  IF (MESSAGEDEC(9) .GT. 0) THEN
	    CALL MOVBYT(MESSAGE,X2FEMES_ADR+MOFF,MESSAGEDEC(10),1,
     *	                   (MESSAGEDEC(9) + 1)/2)
	    CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(9),MESSAGEDEC(10),ERR)
	    WRITE(CLIN15,9854) (BLANKS(I), I = 1, 16 - MESSAGEDEC(9)),
     *	                       (ASCADDRESS(I), I = 1, MESSAGEDEC(9))
	    MESSOFFSET = MOFF + MESSAGEDEC(5)
	    CALL ILBYTE(MESSAGEDEC(15),MESSAGE,X2STMES_DATATYPE
     *	                + MESSOFFSET - 1)
	    CALL MOV2TOI4(MESSAGEDEC(16),MESSAGE,X2STMES_STATION_NO
     *	                  + MESSOFFSET - 1)
	    WRITE(CLIN16,9856) MESSAGEDEC(15)
	    WRITE(CLIN17,9858) MESSAGEDEC(16)
	    IF (MESSAGEDEC(15) .EQ. X2STMES_DATATYPE_DOWN) THEN
	      CALL ILBYTE(MESSAGEDEC(17),MESSAGE,X2STMES_PORTID
     *	                  + MESSOFFSET - 1)
	      CALL ILBYTE(MESSAGEDEC(18),MESSAGE,X2STMES_TERMID
     *	                  + MESSOFFSET - 1)
	      MESSAGEDEC(17) = IAND(MESSAGEDEC(17), '0000007F'X)
C
              IF((MESSAGEDEC(18).GE.0 .AND.
     *                      MESSAGEDEC(18).LE.X2X_MAXTERMS) .AND.
     *           (MESSAGEDEC(19).GE.0 .AND.
     *                      MESSAGEDEC(17).LE.X2X_MAXPORT) .AND.
     *           (MESSAGEDEC(16).GE.1 .AND.
     *                       MESSAGEDEC(16).LE.X2X_STATIONS)) THEN
         	          MESSAGEDEC(19) = X2XS_TERMS(MESSAGEDEC(18) + 1,
     *	                           MESSAGEDEC(17) + 1,MESSAGEDEC(16))
              ELSE
                  MESSAGEDEC(19) = -1
              ENDIF
	      WRITE(CLIN18,9868) MESSAGEDEC(19)
	    ENDIF
	  ENDIF
	  GO TO 500
	ENDIF
C
C DECODE DELIVERY ERROR
C
	IF (TRABUF(TXPTL) .EQ.X2ERR_ERR) THEN
	  CALL MOV2TOI4(MESSAGEDEC(1),MESSAGE,X2FEMES_MESLEN+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(2),MESSAGE,X2FEMES_PROTID+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(3),MESSAGE,X2FEMES_HOST_ID+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(4),MESSAGE,X2FEMES_MESTYP+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(5),MESSAGE,X2FEMES_HEADLEN+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(6),MESSAGE,X2FEMES_DELIVERY+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(7),MESSAGE,X2FEMES_CONNCTL+MOFF-1)
	  CALL MOV4TOI4(MESSAGEDEC(8),MESSAGE,X2FEMES_CONN_ID+MOFF-1)
          MESSAGEDEC(8) = ISHFT(MESSAGEDEC(8),-8)
	  CALL ILBYTE(MESSAGEDEC(9),MESSAGE,X2FEMES_ADRLEN+MOFF-1)
	  WRITE(CLIN2,9860)
	  WRITE(CLIN3,9205) TRABUF(TCDC), H, M, S, TRABUF(TSER)
	  WRITE(CLIN4,9832) MESSAGEDEC(1)
	  WRITE(CLIN5,9834) MESSAGEDEC(2)
	  WRITE(CLIN6,9836) MESSAGEDEC(3)
	  WRITE(CLIN7,9838) MESSAGEDEC(4)
	  WRITE(CLIN8,9840) MESSAGEDEC(5)
	  WRITE(CLIN9,9862) MESSAGEDEC(6)
	  MESSAGEDEC(24) = ISHFT(MESSAGEDEC(7), -4)
	  TEMP = ISHFT(MESSAGEDEC(7), 4)
	  CALL ILBYTE(MESSAGEDEC(25),TEMP,2)
	  WRITE(CLIN10,9846) MESSAGEDEC(24)
	  WRITE(CLIN11,9848) MESSAGEDEC(25)
	  MESSAGEDEC(8) = ISHFT(MESSAGEDEC(8), -8)
	  WRITE(CLIN12,9850) MESSAGEDEC(8)
	  WRITE(CLIN13,9852) MESSAGEDEC(9)
	  IF (MESSAGEDEC(9) .GT. 0) THEN
	    CALL MOVBYT(MESSAGE,X2FEMES_ADR+MOFF,MESSAGEDEC(10),1,
     *	                   (MESSAGEDEC(9) + 1)/2)
	    CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(9),MESSAGEDEC(10),ERR)
	    WRITE(CLIN14,9854) (BLANKS(I), I = 1, 16 - MESSAGEDEC(9)),
     *	                       (ASCADDRESS(I), I = 1, MESSAGEDEC(9))
	    MESSOFFSET = MOFF + MESSAGEDEC(5)
	    CALL ILBYTE(MESSAGEDEC(15),MESSAGE,X2STMES_DATATYPE
     *	                + MESSOFFSET - 1)
	    CALL MOV2TOI4(MESSAGEDEC(16),MESSAGE,X2STMES_STATION_NO
     *	                  + MESSOFFSET - 1)
	    WRITE(CLIN15,9856) MESSAGEDEC(15)
	    WRITE(CLIN16,9858) MESSAGEDEC(16)
	    IF (MESSAGEDEC(6) .EQ.X2FEMES_DELIVERY_ESCAPE) THEN
	      MESSOFFSET = X2FEMES_ADR+(MESSAGEDEC(9)+1)/2+MOFF-1
	      CALL MOV4TOI4(MESSAGEDEC(17),MESSAGE,MESSOFFSET)
	      MESSAGEDEC(17) = ISHFT(MESSAGEDEC(17),-8)
              WRITE(CLIN17,9864) MESSAGEDEC(17)
	      MESSOFFSET=MESSOFFSET+4
	    ENDIF
	  ENDIF
	  GO TO 500
	ENDIF
C
C DECODE PORT CONFIGURATION COMMAND DATA
C
	IF (TRABUF(TXPTL) .EQ. X2ERR_PORTREQ .AND.
     *	    DIR .EQ. XLOG_DIR_OUT) THEN
	  CALL ILBYTE(MESSAGEDEC(1),MESSAGE,X2STMES_PORT_CNTNO+MOFF-1)
	  CALL MOV2TOI4(MESSAGEDEC(2),MESSAGE,X2STMES_PORT_STNO+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(3),MESSAGE,X2STMES_PORT_NUM+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(4),MESSAGE,X2STMES_PORT_MAXTER+MOFF-1)
	  CALL MOV2TOI4(MESSAGEDEC(5),MESSAGE,X2STMES_PORT_POLTIM
     *	                + MOFF - 1)
	  CALL ILBYTE(MESSAGEDEC(6),MESSAGE,X2STMES_PORT_FLAGS+MOFF-1)
	  TEMP = IAND(MESSAGEDEC(6),'80'X)
          IF(TEMP.GT.0) TEMP = 1  
	  CALL ILBYTE(MESSAGEDEC(7),MESSAGE,X2STMES_PORT_BAUD+MOFF-1)
	  CALL ILBYTE(MESSAGEDEC(8),MESSAGE,X2STMES_PORT_BAUD+MOFF-1)
          BINDX = IAND(MESSAGEDEC(7),'0F'X)
          CINDX = IAND(MESSAGEDEC(8),'80'X)
          IF(CINDX.GT.0) CINDX = 1
          SINDX = IAND(MESSAGEDEC(8),'40'X)
          IF(SINDX.GT.0) SINDX = 1
	  WRITE(CLIN2,9810)
	  WRITE(CLIN3,9205) TRABUF(TCDC),H,M,S,TRABUF(TSER)
	  WRITE(CLIN4,9812) MESSAGEDEC(1)
	  WRITE(CLIN5,9814) MESSAGEDEC(2)
	  WRITE(CLIN6,9816) MESSAGEDEC(3)
	  WRITE(CLIN7,9818) MESSAGEDEC(4)
	  WRITE(CLIN8,9820) MESSAGEDEC(5)
	  WRITE(CLIN9,9822) ONOFF(TEMP)
	  WRITE(CLIN10,9824) BAUDARRAY(BINDX)
          WRITE(CLIN11,9825) CLKTYP(CINDX)
          WRITE(CLIN12,9827) SYNTYP(SINDX)
	  K = 0
	  MESSOFFSET = X2STMES_PORT_DROPS + MOFF - 1
	  DO 339 I = 0, MESSAGEDEC(4)-1
	    CALL ILBYTE(MESSAGEDEC(9 + K),MESSAGE,MESSOFFSET + I)
	    IF (MESSAGEDEC(9 + K) .EQ. 0) GO TO 339
	    K = K + 1
339	  CONTINUE
	  WRITE(CLIN14,9826) K
	  IF (K .GT. 0) WRITE(CLIN16,9828)
     *	                (MESSAGEDEC(9+I), I = 0, MIN0(19,K-1))
          IF (K .GT. 20) WRITE(CLIN17,9828)
     *                  (MESSAGEDEC(9+I), I = 20,MIN0(39,K-1))
          IF (K .GT. 40) WRITE(CLIN18,9828)
     *                  (MESSAGEDEC(9+I), I = 40,MIN0(59,K-1))
          IF (K .GT. 60) WRITE(CLIN19,9828)
     *                  (MESSAGEDEC(9+I), I = 60,MIN0(79,K-1))
          IF (K .GT. 80) WRITE(CLIN20,9828)
     *                  (MESSAGEDEC(9+I), I = 80,MIN0(99,K-1))
          IF (K .GT.100) WRITE(CLIN21,9828)
     *                  (MESSAGEDEC(9+I), I = 100,MIN0(119,K-1))
          IF (K .GT.120) WRITE(CLIN22,9828)
     *                  (MESSAGEDEC(9+I), I = 120,MIN0(139,K-1))
          IF (K .GT.140.AND.K.LE.157) WRITE(CLIN23,9828)
     *                  (MESSAGEDEC(9+I), I = 140,MIN0(157,K-1))
	  GO TO 500
	ENDIF
C
C
C DECODE GENERAL STATION CONFIGURATION DATA
C
	IF (TRABUF(TXPTL) .NE. X2ERR_RESET) THEN
	    WRITE(CLIN23,9360)
	    HEXORDFLG = 1
	    GO TO 500
	ENDIF
C CONVERT OUTBOUND MESSAGE TO DECIMAL REPRESENTATION
	IF (DIR.NE.XLOG_DIR_OUT) GO TO 400! UPLINE HELP REQUEST MESSAGE
	CALL ILBYTE(MESSAGEDEC(1),MESSAGE,X2STMES_CMD+MOFF-1)
C
C     DEFAULT CONFIGURATION
C
	IF(MESSAGEDEC(1) .EQ. X2STMES_DEF_CONF) THEN
	  WRITE(CLIN23,9360)
	  HEXORDFLG = 1
	  GOTO 500
	ENDIF
	CALL ILBYTE(MESSAGEDEC(2),MESSAGE,X2STMES_CONF_CNTNO+MOFF-1)
	CALL MOV2TOI4(MESSAGEDEC(3),MESSAGE,X2STMES_CONF_STNO+MOFF-1)
	CALL MOV2TOI4(MESSAGEDEC(4),MESSAGE,X2STMES_CONF_INTIM+MOFF-1)
	CALL MOV2TOI4(MESSAGEDEC(5),MESSAGE,X2STMES_CONF_OUTTIM+MOFF-1)
	CALL MOV2TOI4(MESSAGEDEC(6),MESSAGE,X2STMES_CONF_REPTIM+MOFF-1)
	CALL MOV2TOI4(MESSAGEDEC(7),MESSAGE,X2STMES_CONF_TRATIM+MOFF-1)
	CALL MOV2TOI4(MESSAGEDEC(8),MESSAGE,X2STMES_CONF_STATIM+MOFF-1)
	CALL MOV4TOI4(SYSTMFLD,MESSAGE,X2STMES_CONF_SYSTIM+MOFF-1)
	H=SYSTMFLD/3600
	M=(SYSTMFLD-H*3600)/60
	S=SYSTMFLD-(H*3600+M*60)
	CALL ILBYTE(TEMP, MESSAGE, X2STMES_CONF_MSTENA+MOFF-1)
	BITOFF  = 24
	MESSAGEDEC(9) = 0
	IF (NTSBIT(TEMP, BITOFF)) MESSAGEDEC(9) = 1
	MESSAGEDEC(10) = 0
	IF (NTSBIT(TEMP, BITOFF + 1)) MESSAGEDEC(10) = 1
	CALL ILBYTE(MESSAGEDEC(11),MESSAGE,X2STMES_CONF_STNRET+MOFF-1)
	CALL ILBYTE(MESSAGEDEC(12),MESSAGE,X2STMES_CONF_OUTOFF+MOFF-1)
	CALL ILBYTE(MESSAGEDEC(13),MESSAGE,X2STMES_CONF_OUTCNT+MOFF-1)
	CALL ILBYTE(MESSAGEDEC(14),MESSAGE,X2STMES_CONF_DIALOFF+MOFF-1)
	CALL ILBYTE(MESSAGEDEC(15),MESSAGE,X2STMES_CONF_DIALCNT+MOFF-1)
	CALL ILBYTE(MESSAGEDEC(16),MESSAGE,X2STMES_CONF_X32OFF+MOFF-1)
	CALL ILBYTE(MESSAGEDEC(17),MESSAGE,X2STMES_CONF_X32CNT+MOFF-1)
	OLDP = .FALSE.
	IF(MESSAGEDEC(16).EQ.0 .AND. MESSAGEDEC(17).EQ.0) OLDP = .TRUE.
	IF(.NOT. OLDP) THEN
        CALL ILBYTE(MESSAGEDEC(22),MESSAGE,X2STMES_CONF_UIDOFF+MOFF-1)
        CALL ILBYTE(MESSAGEDEC(23),MESSAGE,X2STMES_CONF_UIDLEN+MOFF-1)
	CALL MOV2TOI4(MESSAGEDEC(24),MESSAGE,
     *	                X2STMES_CONF_SLPTIME+MOFF-1)
        CALL ILBYTE(MESSAGEDEC(25),MESSAGE,X2STMES_CONF_AFTMAX+MOFF-1)
        CALL ILBYTE(MESSAGEDEC(26),MESSAGE,X2STMES_CONF_FACLTY+MOFF-1)
        CALL ILBYTE(MESSAGEDEC(27),MESSAGE,X2STMES_CONF_AUXFAC+MOFF-1)
        CALL MOV2TOI4(MESSAGEDEC(28),MESSAGE,X2STMES_CONF_ABSTIM+MOFF-1)
	ENDIF
C
C	V05 - ONLY DECODE X25 PORTION OF MESSAGE IF OUTCALL ADDRESS
C	COUNT > 0
C	
	IF( MESSAGEDEC(13). GT. 0 ) THEN
C
C     	  X25 FLAGS AND RETRY COUNT
C
	    MESSOFFSET = MESSAGEDEC(12) + MOFF
	    CALL MOV2TOI4(MESSAGEDEC(18),MESSAGE,MESSOFFSET)
C
C     	  X25 RETRY INTERVAL
C
	    MESSOFFSET = MESSOFFSET + 2
	    CALL MOV2TOI4(MESSAGEDEC(19),MESSAGE,MESSOFFSET)
C
C     	  X25 ADDRESS LENGTH
C
	    MESSOFFSET = MESSOFFSET + 2
	    CALL ILBYTE(MESSAGEDEC(30),MESSAGE,MESSOFFSET)
C
C     	  X25 PRIMARY ADDRESS
C
	    MESSOFFSET = MESSOFFSET + 1
	    CALL MOVBYT(MESSAGE, MESSOFFSET + 1, MESSAGEDEC(31), 1,
     *	            (MESSAGEDEC(30) + 1)/2)
	    MESSOFFSET = MESSOFFSET + 8
      	    CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(30),MESSAGEDEC(31),ERR)
	    TEMP = ISHFT(MESSAGEDEC(18),20)
	    K = ISHFT(TEMP,-28)
	ENDIF !V05
C
C
C
	WRITE(CLIN2, 9210)
	WRITE(CLIN3,9205) TRABUF(TCDC),H,M,S,TRABUF(TSER)
	WRITE(CLIN4, 9230) MESSAGEDEC(1), MESSAGEDEC(2)
	IF (.NOT. MORE) THEN
	   WRITE(CLIN5, 9240) MESSAGEDEC(3), MESSAGEDEC(4)
	   WRITE(CLIN6, 9250) MESSAGEDEC(5), MESSAGEDEC(6)
	   WRITE(CLIN7, 9260) MESSAGEDEC(7), MESSAGEDEC(8)
	   WRITE(CLIN8, 9270) H, M, S, MESSAGEDEC(9)
	   WRITE(CLIN9, 9280) MESSAGEDEC(10), MESSAGEDEC(11)
	   WRITE(CLIN10, 9290) MESSAGEDEC(12), MESSAGEDEC(13)
	   WRITE(CLIN11, 9300) MESSAGEDEC(14), MESSAGEDEC(15)
	   WRITE(CLIN12, 9310) MESSAGEDEC(16), MESSAGEDEC(17)
	   IF(.NOT. OLDP) THEN
	     WRITE(CLIN13, 9311) MESSAGEDEC(22), MESSAGEDEC(23)
	     WRITE(CLIN14, 9312) MESSAGEDEC(24), MESSAGEDEC(25)
	     WRITE(CLIN15, 9313) MESSAGEDEC(26), MESSAGEDEC(27)
	     WRITE(CLIN16, 9314) MESSAGEDEC(28)
	   ENDIF
	   WRITE(CLIN18,9315)
	ELSEIF( MESSAGEDEC(13). GT. 0 ) THEN	    !V05 
C
C     X25 ALTERNATE LENGTH AND ADDRESS
C
	   WRITE(CLIN5, 9320) MESSAGEDEC(18), K
	   WRITE(CLIN6, 9330) MESSAGEDEC(19)
	   WRITE(CLIN7, 9340) MESSAGEDEC(30),
     *	   (BLANKS(K), K = 1, DADRL-MIN0(MESSAGEDEC(30),DADRL)),	  !V03
     *	   (ASCADDRESS(K), K = MAX0(MESSAGEDEC(30)-DADRL+1,1),		  !V03
     *			       MESSAGEDEC(30))				  !V03
	   PNT = 8
	   IF (MESSAGEDEC(13) .GT. 1) THEN
	    DO 350 K = 2, MESSAGEDEC(13)
	      CALL ILBYTE(MESSAGEDEC(30),MESSAGE,MESSOFFSET)
	      MESSOFFSET = MESSOFFSET + 1
	      CALL MOVBYT(MESSAGE, MESSOFFSET + 1, MESSAGEDEC(31), 1,
     *	                (MESSAGEDEC(30) + 1)/2)
	      MESSOFFSET = MESSOFFSET + (MESSAGEDEC(30) + 1)/2
           CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(30),MESSAGEDEC(31),ERR)
	      IF (ERR .LT. 0) THEN
	        TYPE *, 'error in NHTOA subroutine  ERR = ',ERR
	      ENDIF
	      WRITE(XNEW(  PNT), 9350) MESSAGEDEC(30),(BLANKS(M),
     *      M=1,10-MESSAGEDEC(30)), (ASCADDRESS(M),M=1,MESSAGEDEC(30))
	      PNT = PNT + 1
	      IF (PNT .GE. 22) GO TO 500
350	    CONTINUE
	   ENDIF
C
C	   ***** Start V04 Changes *****
C
	   IF (MESSAGEDEC(15) .GT. 0) THEN
C
C             DIALUP FLAGS AND RETRY COUNT
C
	      MESSOFFSET = MESSAGEDEC(14) + MOFF
	      CALL MOV2TOI4(MESSAGEDEC(18),MESSAGE,MESSOFFSET)
C
C             DIALUP RETRY INTERVAL
C
	      MESSOFFSET = MESSOFFSET + 2
	      CALL MOV2TOI4(MESSAGEDEC(19),MESSAGE,MESSOFFSET)
C
C             DIALUP ADDRESS LENGTH
C
	      MESSOFFSET = MESSOFFSET + 2
	      TEMP = ISHFT(MESSAGEDEC(18),20)
	      K = ISHFT(TEMP,-28)
C
	   ELSE
C
C	      CLEAR THE FLAGS AND RETRY INTERVAL 
C	      IF ZERO DIAL COUNT
C
	      MESSAGEDEC(18) = 0
	      MESSAGEDEC(19) = 0
	      K = 0
	   ENDIF
C
C	   ***** End V04 Changes *****
C
	   WRITE(XNEW(  PNT), 9420) MESSAGEDEC(18), K
	   PNT = PNT + 1
	   IF (PNT .GE. 22) GO TO 500
	   WRITE(XNEW(  PNT), 9430) MESSAGEDEC(19)
	   PNT = PNT +1
	   IF (PNT .GE. 22) GO TO 500
	   IF (MESSAGEDEC(15) .GT. 0) THEN
	      DO 380 K = 1, MESSAGEDEC(15)
	         CALL ILBYTE(MESSAGEDEC(30),MESSAGE,MESSOFFSET)
	         MESSOFFSET = MESSOFFSET + 1
	         CALL MOVBYT(MESSAGE, MESSOFFSET + 1, MESSAGEDEC(31),
     *			     1, (MESSAGEDEC(30) + 1)/2)
	         MESSOFFSET = MESSOFFSET + (MESSAGEDEC(30) + 1)/2
	         CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(30),
     *			    MESSAGEDEC(31),ERR)
	         IF (ERR .LT. 0) THEN
		    TYPE *, 'error in NHTOA subroutine  ERR = ',ERR
	         ENDIF
	         WRITE(XNEW(  PNT), 9450) MESSAGEDEC(30),		  !V03
     *		  (BLANKS(M), M = 1, DADRL-MIN0(MESSAGEDEC(30),DADRL)),	  !V03
     *		  (ASCADDRESS(M),M=MAX0(MESSAGEDEC(30)-DADRL+1,1),	  !V03
     *				   MESSAGEDEC(30))			  !V03
	         PNT = PNT + 1
	         IF (PNT .GE. 22) GO TO 500
380	      CONTINUE
	   ENDIF
	   IF (OLDP) GO TO 500
C
C	   ***** Start V04 Changes *****
C
	   IF (MESSAGEDEC(17) .GT. 0) THEN
C
C	      X32.25 FLAGS AND RETRY COUNT
C
	      MESSOFFSET = MESSAGEDEC(16) + MOFF
	      CALL MOV2TOI4(MESSAGEDEC(18),MESSAGE,MESSOFFSET)
C
C     	      X32.25 RETRY INTERVAL
C
	      MESSOFFSET = MESSOFFSET + 2
	      CALL MOV2TOI4(MESSAGEDEC(19),MESSAGE,MESSOFFSET)
C
C     	      X32.25 ADDRESS LENGTH
C
	      MESSOFFSET = MESSOFFSET + 2
	      CALL ILBYTE(MESSAGEDEC(30),MESSAGE,MESSOFFSET)
C
C	      X32.25 PRIMARY ADDRESS
C
	      MESSOFFSET = MESSOFFSET + 1
	      CALL MOVBYT(MESSAGE, MESSOFFSET + 1, MESSAGEDEC(31), 1,
     *			 (MESSAGEDEC(30) + 1)/2)
	      MESSOFFSET = MESSOFFSET + 8
	      CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(30),MESSAGEDEC(31),ERR)
	      TEMP = ISHFT(MESSAGEDEC(18),20)
	      K = ISHFT(TEMP,-28)
C
	   ELSE
C
C	      CLEAR THE FLAGS, RETRY INTERVAL, ADDRESS
C	      IF ZERO X32 COUNT
C
	      MESSAGEDEC(18) = 0
	      MESSAGEDEC(19) = 0
	      MESSAGEDEC(30) = 0
	      ASCADDRESS(1) = ' '
	      K = 0
	   ENDIF
C
C	   ***** End V04 Changes *****
C
	   WRITE(XNEW(  PNT), 9320) MESSAGEDEC(18), K
	   PNT = PNT + 1
	   IF (PNT .GE. 22) GO TO 500
	   WRITE(XNEW(  PNT), 9330) MESSAGEDEC(19)
	   PNT = PNT + 1
	   IF (PNT .GE. 22) GO TO 500
	   WRITE(XNEW(  PNT), 9341) MESSAGEDEC(30),			!V03
     *	    (BLANKS(K), K = 1, DADRL-MIN0(MESSAGEDEC(30),DADRL)),	!V03
     *	    (ASCADDRESS(K), K = MAX0(MESSAGEDEC(30)-DADRL+1,1),		!V03
     *			        MESSAGEDEC(30))		  		!V03
	   PNT = PNT + 1
	   IF (PNT .GE. 22) GO TO 500
C
C	   X32.25 ALTERNATE LENGTH AND ADDRESS
C
	   IF (MESSAGEDEC(17) .GT. 0) THEN				!V04
	      DO 390 K = 2, MESSAGEDEC(17)
		 CALL ILBYTE(MESSAGEDEC(30),MESSAGE,MESSOFFSET)
		 MESSOFFSET = MESSOFFSET + 1
		 CALL MOVBYT(MESSAGE, MESSOFFSET + 1, MESSAGEDEC(31),
     *			     1, (MESSAGEDEC(30) + 1)/2)
		 MESSOFFSET = MESSOFFSET + (MESSAGEDEC(30) + 1)/2
		 CALL NHTOA(ASCADDRESS,1,MESSAGEDEC(30),
     *			    MESSAGEDEC(31),ERR)
		 IF (ERR .LT. 0) THEN
		    TYPE *, 'error in NHTOA subroutine  ERR = ',ERR
		 ENDIF
		 WRITE(XNEW(  PNT), 9350) MESSAGEDEC(30),			  !V03
     *		  (BLANKS(M), M = 1, DADRL-MIN0(MESSAGEDEC(30),DADRL)), !V03
     *		  (ASCADDRESS(M),M=MAX0(MESSAGEDEC(30)-DADRL+1,1),	  !V03
     *				   MESSAGEDEC(30))			  !V03
		 PNT = PNT + 1
		 IF (PNT .GE. 22) GO TO 500
390	      CONTINUE
	   ENDIF
	ENDIF
	GO TO 500
C
C CONVERTING UPLINE HELP REQUST MESSAGE TO DECIMAL REPRESENTATION
C
400	CONTINUE
C
C CONVERT INBOUND MESSAGE TO DECIMAL REPRESENTATION
C DECODE UPLINE HELP REQUEST FOR STATION CONFIGURATION
C
	CALL ILBYTE(MESSOFFSET,MESSAGE,X2PRO_OFFSET-1)
	MESSOFFSET = MESSOFFSET - 1
	CALL ILBYTE(MESSAGEDEC(1),MESSAGE,MESSOFFSET+X2STMES_PROTID-1)
	CALL ILBYTE(MESSAGEDEC(2),MESSAGE,MESSOFFSET+X2STMES_DATATYPE
     *	            - 1)
	CALL ILBYTE(MESSAGEDEC(3),MESSAGE,MESSOFFSET+X2STMES_STYPE-1)
	CALL ILBYTE(MESSAGEDEC(4),MESSAGE,MESSOFFSET+X2STMES_COUNT-1)
	CALL MOV4TOI4(MESSAGEDEC(5), MESSAGE, MESSOFFSET
     *	              + X2STMES_PHYSID - 1)
	CALL MOV2TOI4(MESSAGEDEC(6), MESSAGE, MESSOFFSET
     *	              + X2STMES_REVISION - 1)
	CALL MOV2TOI4(MESSAGEDEC(7), MESSAGE, MESSOFFSET
     *	              + X2STMES_TTN1CHK - 1)
	CALL MOV2TOI4(MESSAGEDEC(8), MESSAGE, MESSOFFSET
     *	              + X2STMES_TTN2CHK - 1)
	CALL MOV2TOI4(MESSAGEDEC(9), MESSAGE, MESSOFFSET
     *	              + X2STMES_STNCHK - 1)
	CALL MOV2TOI4(MESSAGEDEC(10), MESSAGE, MESSOFFSET
     *	              + X2STMES_CALLCHK - 1)
	WRITE(CLIN2,9530)
	WRITE(CLIN3,9205) TRABUF(TCDC),H,M,S,TRABUF(TSER)
	WRITE(CLIN5,9550)   MESSAGEDEC(1)
	WRITE(CLIN6,9560)   MESSAGEDEC(2)
	WRITE(CLIN7,9570)   MESSAGEDEC(3)
	WRITE(CLIN8,9580)   MESSAGEDEC(4)
	WRITE(CLIN9,9590)   MESSAGEDEC(5)
	WRITE(CLIN10,9600)  MESSAGEDEC(6)
	WRITE(CLIN11,9610)  MESSAGEDEC(7)
	WRITE(CLIN12,9620)  MESSAGEDEC(8)
	WRITE(CLIN13,9630)  MESSAGEDEC(9)
	WRITE(CLIN14,9640)  MESSAGEDEC(10)
	GO TO 500
9205	FORMAT('   CDC   ',I10,2X,'Time      ',I2.2,':',I2.2,':',
     *	       I2.2,10X,'Cross ser',I10)
9210	FORMAT(15X,'decoded general station configuration data')
9230	FORMAT('command code ',T32,I8,T40,'   configuration control ',
     *	       'number',T73,I8)
9240	FORMAT('station number ',T32,I8,T40,'   incall duration timer',
     *	       '(sec)   ',T73,I8)
9250	FORMAT('outcall duration timer  (sec)   ',T32,I8,T40,
     *	       '   response timer  (sec)   ',T73,I8)
9260	FORMAT('inter-transaction timer (sec)',T32,I8,T40,
     *	       '   statistic interval  (sec)   ',T73,I8)
9270	FORMAT( 'system time   ', T32,I2.2,':',I2.2,':',I2.2,T40,
     *	       '   master enable flag ',T73,I8)
9280	FORMAT('dial enable flag ',T32,I8,T40,
     *	       '   station retry limit',T73,I8)
9290	FORMAT('outcall parameter offset   ',T32,I8,T40,
     *	       '   outcall address count   ',T73,I8)
9300	FORMAT('dial-up parameter offset   ',T32,I8,T40,
     *	       '   dial-up address count   ',T73,I8)
9310	FORMAT('X32  parameter offset',T32,I8,T40,
     *	       '   X32 count ',T73,I8)
9311	FORMAT('UID  parameter offset',T32,I8,T40,
     *	       '   UID length',T73,I8)
9312	FORMAT('Sleep time           ',T32,I8,T40,
     *	       '   After Hours Counter',T73,I8)
9313	FORMAT('Facilities           ',T32,I8,T40,
     *	       '   Auxiliary Facilities',T73,I8)
9314	FORMAT('Absolute disc. time  ',T32,I8)
9315	FORMAT(T60,'( MOre... )')
9320	FORMAT('flags & retry count (in HEX)  ',T36,Z4,T40,
     *	       '   default disconnect mode   ',T73,I8)
9330	FORMAT('outcall retry interval   ',T32,I8)
9340	FORMAT('address length   ',T32,I8,T40,
     *	       '   primary X.25 outcall addr',T69,<DADRL>A1)		  !V03
9341	FORMAT('address length   ',T32,I8,T40,
     *	       '   primary X.32 outcall addr',T69,<DADRL>A1)		  !V03
9350	FORMAT('address length   ',T32,I8,T40,
     *	       '   alternate outcall addr',T69,<DADRL>A1)		  !V03
9360	FORMAT('   decode is not available')
9420	FORMAT('flags & retry count (HEX) dial-up',T36,Z4,T40,
     *	       '   default disconnect mode ',T73,I8)
9430	FORMAT('outcall retry interval dial-up  ',T32,I8)
9450	FORMAT('address length for dial-up',T32,I8,T40,
     *	       '   alternate dial-up addr ',T69,<DADRL>A1)		  !V03
9530	FORMAT(13X,'decoded upline help request for station',
     *	           ' configuration')
9550	FORMAT('protocol identifier',T40,I8)
9560	FORMAT('station data unit type',T40,I8)
9570	FORMAT('station type',T40,I8)
9580	FORMAT('port / virtual circuit count',T40,I8)
9590	FORMAT('station physical identifier',T40,Z8)
9600	FORMAT('software revision number',T40,Z8)
9610	FORMAT('TITN parameter 1 checksum',T40,Z8)
9620	FORMAT('TITN parameter 2 checksum',T40,Z8)
9630	FORMAT('station parameters checksum',T40,Z8)
9640	FORMAT('initial call parameters checksum',T40,Z8)
9710	FORMAT(15X, 'decoded relay configuration data')
9720	FORMAT('configuration control number',T40,I8)
9725	FORMAT('station number',T40,I8)
9730	FORMAT('station address length',T40,I8)
9735	FORMAT('station address',T32,16A1)
9740	FORMAT('maximal # of segments per call',T40,I8)
9745	FORMAT('call retry count',T40,I8)
9750	FORMAT('call retry interval  (msec)',T40,I8)
9755	FORMAT('acknowledge timeout',T40,I8)
9760	FORMAT('forward timeout',T40,I8)
9765	FORMAT('address count',T40,I8)
9770	FORMAT('relay address',T32,16A1)
9810	FORMAT(15X,'decoded port configuration command data')
9812	FORMAT('configuration control number',T40,I8)
9814	FORMAT('station number',T40,I8)
9816	FORMAT('port number',T40,I8)
9818	FORMAT('maximum terminals to poll',T40,I8)
9820	FORMAT('poll timeout',T40,I8)
9822	FORMAT('auto update poll statistics flag',T45,A3)
9824	FORMAT('communication speed  (in BAUD )',T40,I8)
9825    FORMAT('clock type                     ',T40,A8)
9826	FORMAT('number of defined terminals',T40,I8)
9827    FORMAT('communication type         ',T43,A5)
9828	FORMAT( 32(Z2,','))
9830	FORMAT(15X,'decoded upline delivery acknowledgement')		!V06
9832	FORMAT('message length',T40,I8)
9834	FORMAT('protocol identifier',T40,I8)
9836	FORMAT('host transaction identifier',T40,I8)
9838	FORMAT('message type',T40,I8)
9840	FORMAT('header length',T40,I8)
9842	FORMAT(15X,'delivery flags')
9844  FORMAT('    ND - ',I1,'    ER - ',I1,'    DA - ',I1,'    RC - ',
     *	                   I1)
9846	FORMAT('connect control',T44,I4)
9848	FORMAT('disconnect control',T44,I4)
9850	FORMAT('front end connection identifier',T40,Z8)
9852	FORMAT('destination address length',T40,I8)
9854	FORMAT('destination address',T32,16A1)
9856	FORMAT('station unit data type',T40,I8)
9858	FORMAT('station number',T40,I8)
9860	FORMAT(15X,'decoded delivery error')
9862	FORMAT('delivery error code for error message',T40,Z8)
9864	FORMAT('new error code',T40,Z8)
9866	FORMAT('source address',T32,<DADRL>A1)				!V03
9868	FORMAT('terminal number',T40,I8)
500	CONTINUE
	IF (HEXORDFLG .EQ. 1) GO TO 111
	CALL X2FRCLOSE					    !V02
	RETURN
	END
