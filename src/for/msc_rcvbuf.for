C
C *** SUBROUTINE MSC_RCVBUF ***
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]MSC_RCVBUF.FOV                               $
C  $Date::   17 Apr 1996 14:08:00                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C  
C *** Pre-Baseline Source - msc_rcvbuf.for ***
C
C V05 31-JAN-94 PJS TRI-STATE RFSS # 3.
C                   SET STATE BACK TO MSC_REQ_ONLINE ON ANY ERROR &
C                   CLEAR THE TYPEAHEAD BUFFER WHEN IN THAT STATE.
C                   THIS SHOULD ALLOW RESYNCHRONIZATION TO PROCEED WITH THE
C                   MINIMUM OF EFFORT.
C V04 16-JAN-94 PJS REPORT WHEN SWITCH_STATE IS UNEXPECTED. ALSO CLEANED UP.
C V03 11-JAN-94 PJS MODIFIED TO REQUEST CONFIG DATA FROM NEWLY
C                   SELECTED SWITCH FOR MULTIPLE SWITCHES.
C V02 07-JAN-93 RRB NO MORE MSCPRO EXECUTABLE. NOW PART OF MSCMGR.
C                   VALIDATE CURRENT CONNECTION STATE.
C V01 29-JAN-91 RRB RELEASED FOR VAX
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode Island,
C and contains confidential and trade secret information. It may not be
C transferred from the custody or control of GTECH except as authorized in
C writing by an officer of GTECH. Neither this item nor the information it
C contains may be used, transferred, reproduced, published, or disclosed,
C in whole or in part, and directly or indirectly, except as expressly
C authorized by an officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose:
C	THIS PROGRAM WILL DECODE BUFFERS RECEIVED FROM THE TELENEX
C	MATRIX SWITCH CONTROLLER AND DETERMINE APPROPRIATE ACTION.
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE MSC_RCVBUF(BUF)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
C
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:MSCCOM.DEF'
	INCLUDE 'INCLIB:MSCALRMS.DEF'
	INCLUDE 'INCLIB:MSCCMDS.DEF'
	INCLUDE 'INCLIB:MSCEVN.DEF'
	INCLUDE 'INCLIB:MSCMSGS.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
C
C LOCAL DECLARATIONS
C
	INTEGER*4	ACTION,			! WHAT TO DO (MSCALRMS.DEF)
     *			ALARM,
     *			BADPORT,
     *			BEG_IND,
     *			BUF,			! BUFFER NUMBER
     *			CBUF(CDLEN),		! COMMAND BUFFER
     *			DIG,
     *			END_IND,
     *			FREEPORT,		! PORT FOR REASSIGN
     *			I,
     *			IMSCCMD(20),
     *			IND,
     *			LOCAL_PORT,		! FAULTY LOCAL PORT
     *			MESSAGE(MSCBLEN),
     *			MSGNUM,
     *			MSCPARMS(MSC_MAX_PARMS),! COMMAND PARAMETERS
     *			MSCPORT,		! MSC PORT INDEX
     *			NET_PORT,		! NETWORK PORT # FROM MESSAGE
     *			ST,
     *			STATUS,
     *			SWITCH_STATE
C
	LOGICAL*4	CMDOK			! COMMAND VALID ?
C
	BYTE		BLANK		/' '/
C
	CHARACTER*(MSCBYTLEN)	CHAR_MESSAGE	! OPERATOR MESSAGE
C
	CHARACTER*80	MSCCMD
C
	CHARACTER*30	OPSMESS
C
	CHARACTER*1	CR		/Z0D/
C
	EQUIVALENCE	(MESSAGE, CHAR_MESSAGE)
	EQUIVALENCE	(IMSCCMD, MSCCMD)
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C CLEAR COMMAND PARAMETER TABLE.
C
	CALL FASTSET(0, MSCPARMS, MSC_MAX_PARMS)
C
C CLEAR COMMAND BUFFER.
C
	CALL FASTSET(0, CBUF, CDLEN)
C
	CBUF(3) = TCMSC
	CBUF(6) = 'MSCM'
C
        CALL FASTSET(0, MESSAGE, MSCBLEN)
C
        CALL FASTMOV(MSCBUF(1, BUF), MESSAGE, MSCBLEN)
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C CHECK FOR STATUS RESPONSE
C
	IF (BMSCBUF(RESP_TYPE, BUF) .EQ. STATUS_RESP) THEN
C
C CHECK CURRENT CONNECTION STATUS AND DETERMINE IF WE NEED TO ISSUE OR
C REISSUE A NEW SETUP COMMAND.
C
	  MSCCMD = ' '
	  IF (MSCSTS .GT. MSC_DOWN) THEN
C
C IF WE BELEIVE MSC SHOULD BE ON-LINE BUT SWITCH SAYS OTHERWISE, 
C RESET OUR CONNECTION STATE TO RESTART LOGON PROCESS.
C
	    IF (MSCSTS .GT. MSC_REQ_ONLINE .AND.
     *          BMSCBUF(MSC_STATUS, BUF) .NE. MSC_ON) THEN
	      SWITCH_STATE = ZEXT(BMSCBUF(MSC_STATUS, BUF))
	      CALL OPS('*** MSC_RCVBUF - ' //
     *                 'LOST SWITCH CONNECTION, STATE = ',
     *                 SWITCH_STATE, SWITCH_STATE)
	      CALL OPS('*** MSC_RCVBUF - ' //
     *                 'RE-SYNC HOST<->PC CONNECTION ***',
     *                 MSC_REQ_ONLINE, MSCSTS)
	      MSCSTS = MSC_REQ_ONLINE
	    ENDIF
C
C IF STATUS IS REQ_ONLINE THEN CHECK SETUP COUNTER AND DETERMINE 
C IF A RETRY OF GO ONLINE COMMAND IS NECESSARY.
C
	    IF (MSCSTS .EQ. MSC_REQ_ONLINE) THEN
	      IF (MSC_SETUP_REQ_CNT .GT. MSC_SETUP_REQ_LIMIT) THEN
	        CALL MSC_CLRTYPAHD			! CLEAR TYPEAHEAD BUF.
		MSCCMD = GO_ONLINE // CR
		MSC_SETUP_REQ_CNT = 0
	      ELSE
		MSC_SETUP_REQ_CNT = MSC_SETUP_REQ_CNT + 1
	      ENDIF
C
C IF ONLINE THEN ISSUE LOGON COMMAND AND SET LOCAL STATUS TO REQ_LOGON.
C
	    ELSEIF (MSCSTS .EQ. MSC_ONLINE) THEN
	      MSCSTS = MSC_REQ_LOGON
	      MSCCMD = LOGON //
     *                 CMSC_CONF_INFO(USER_ID) //
     *                 CMSC_CONF_INFO(PASSWORD) // CR
	      MSC_SETUP_REQ_CNT = 0
C
C IF STATUS IS REQ_LOGON THEN INCREMENT SETUP COUNTER, AND DETERMINE 
C IF A RETRY OF LOGON COMMAND IS NECESSARY.
C
	    ELSEIF (MSCSTS .EQ. MSC_REQ_LOGON) THEN
	      IF (MSC_SETUP_REQ_CNT .GT. MSC_SETUP_REQ_LIMIT) THEN
		MSCSTS = MSC_REQ_ONLINE
	      ELSE
		MSC_SETUP_REQ_CNT = MSC_SETUP_REQ_CNT + 1
	      ENDIF
C
C IF STATUS IS LOGGED ON THEN ISSUE COMMAND TO SET PAGE LENGTH.
C
	    ELSEIF (MSCSTS .EQ. MSC_LOGGED_ON) THEN
	      MSCSTS = MSC_REQ_PAGE_SET
	      MSCCMD = SET_PAGE_LENGTH //
     *                 CMSC_CONF_INFO(PAGE_LENGTH) // CR
	      MSC_SETUP_REQ_CNT = 0
C
C IF STATUS IS REQ_PAGE_SET THEN INCREMENT SETUP COUNTER AND DETERMINE 
C IF A RETRY OF SET PAGE COMMAND IS NECESSARY.
C
	    ELSEIF (MSCSTS .EQ. MSC_REQ_PAGE_SET) THEN
	      IF (MSC_SETUP_REQ_CNT .GT. MSC_SETUP_REQ_LIMIT) THEN
		MSCSTS = MSC_REQ_ONLINE		    
	      ELSE
		MSC_SETUP_REQ_CNT = MSC_SETUP_REQ_CNT + 1
	      ENDIF
C
C IF STATUS IS PAGE LENGTH SET THEN ISSUE SELECT SWITCH COMMAND.
C
	    ELSEIF (MSCSTS .EQ. MSC_PAGE_SET) THEN
	      MSCSTS = MSC_REQ_SWITCH
	      MSCCMD = SELECT //
     *                 CMSC_CONF_INFO(SWITCH_NAME) // CR
	      MSC_SETUP_REQ_CNT = 0
C
C IF STATUS IS REQ_SWITCH INCREMENT SETUP COUNTER, AND DETERMINE 
C IF A RETRY OF SELECT SWITCH COMMAND IS NECESSARY.
C
	    ELSEIF (MSCSTS .EQ. MSC_REQ_SWITCH) THEN
	      IF (MSC_SETUP_REQ_CNT .GT. MSC_SETUP_REQ_LIMIT) THEN
		MSCSTS = MSC_REQ_ONLINE
	      ELSE
		MSC_SETUP_REQ_CNT = MSC_SETUP_REQ_CNT + 1
	      ENDIF
C
C IF SWITCH IS SELECTED THEN START SWITCH.
C
	    ELSEIF (MSCSTS .EQ. MSC_SWITCH_SELECTED) THEN
	      MSCSTS = MSC_REQ_STARTUP
	      MSCCMD = START //
     *                 CMSC_CONF_INFO(SWITCH_NAME) // CR
	      MSC_SETUP_REQ_CNT = 0
C
C IF STATUS IS REQ_STARTUP INCREMENT SETUP COUNTER AND DETERMINE 
C IF A RETRY OF START SWITCH COMMAND IS NECESSARY.
C
	    ELSEIF (MSCSTS .EQ. MSC_REQ_STARTUP) THEN
	      IF (MSC_SETUP_REQ_CNT .GT. MSC_SETUP_REQ_LIMIT) THEN
		MSCSTS = MSC_REQ_ONLINE
	      ELSE
		MSC_SETUP_REQ_CNT = MSC_SETUP_REQ_CNT + 1
	      ENDIF
C
C IF NONE OF THE ABOVE AND SWTICH IS NOT ALREADY ACTIVE 
C THEN SOMETHING IS WRONG.
C
	    ELSEIF (MSCSTS .NE. MSC_ACTIVE) THEN
	      CALL OPS('*** MSC_RCVBUF - INVALID MSC STATUS ***',
     *                 MSCSTS, 0)
	      MSCSTS = MSC_REQ_ONLINE
	      MSC_SETUP_REQ_CNT = MSC_SETUP_REQ_LIMIT + 1
	    ENDIF
C
C IF MSC IS SUPPOSED TO BE OFFLINE BUT ISN'T THEN LET IT KNOW.
C
	  ELSE
	    IF (BMSCBUF(MSC_STATUS, BUF) .NE. MSC_OFF)
     *        MSCCMD = GO_OFFLINE // CR
	    MSCSTS = MSC_DOWN
	  ENDIF
C
C IF STATUS CHANGE NECESSARY, QUEUE COMMAND.
C
	  IF (MSCCMD.NE.' ') THEN
	    CALL MSC_QUECMD(IMSCCMD)
	  ENDIF
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C DETERMINE IF MESSAGE IS AN ALARM.
C
	ELSEIF (BMSCBUF(RESP_TYPE, BUF) .EQ. ALARM_RESP .AND.
     *          MSCSTS .EQ. MSC_ACTIVE) THEN		! ALARM RESPONSE
	  ALARM = 0
	  DO 200 I = ALARM_NUM, ALARM_NUM + 2		! GET ALARM #
	    IF (BMSCBUF(I, BUF) .EQ. BLANK) GOTO 200
	    CALL ASCBIN(BMSCBUF(1, BUF), I, 1, DIG, ST)
	    IF (ST .NE. 0) GOTO 210
	    ALARM = ALARM * 10 + DIG
200	  CONTINUE
C
210	  CONTINUE
	  IF (ALARM .LT. MSC_SYS_ALARMS .OR.
     *        ALARM .GT. MSC_MAX_ALARM) THEN
	    CALL OPS('*** MSC_RCVBUF - INVALID ALARM FROM MSC ***',
     *               ALARM, ALARM)
	    GOTO 9999
	  ENDIF
	  ACTION = MSC_ALARM_ACTION(ALARM)
C
C NOTIFY OPS IF ALARM REQUIRES SOME KIND OF ACTION.
C
	  IF (ACTION .GT. MSC_NO_ACTION) THEN
	    IF (ALARM .LT. MSC_PORT_ALARMS) THEN
	      BEG_IND = 28
	      END_IND = INDEX(CHAR_MESSAGE, CR)
	    ELSE
	      BEG_IND = INDEX(CHAR_MESSAGE, CR) + 2
	      END_IND = INDEX(CHAR_MESSAGE(BEG_IND:), CR) + BEG_IND - 1
	    ENDIF
C
	    IF (BEG_IND .LT. 28) BEG_IND = 28
C
	    IF (END_IND - BEG_IND .LE. 0 .OR.
     *          END_IND - BEG_IND .GT. 40) END_IND = BEG_IND + 40
C
	    CALL OPS(CHAR_MESSAGE(BEG_IND:END_IND-1), 0, 0)
	  ENDIF
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C AUTOMATIC SWITCHING OF LINES CURRENTLY DISABLED!!! (05-MAY-91 RRB).
C
	  IF (MSC_AUTO_SWITCH .EQ. AUTO_SWITCH_DISABLED) GOTO 9999
C
C IF FATAL ERROR THEN PLACE MSC OFFLINE.
C
	  IF (ACTION .EQ. MSC_FATAL) THEN
	    MSCSTS = MSC_DOWN				! GO OFFLINE
C
C IF SWITCH REQUIRED, GET NETWORK PORT NUMBER FROM 2ND LINE OF MESSAGE.
C
	  ELSEIF (ACTION .EQ. MSC_SWITCH) THEN
	    NET_PORT = 0
	    IND      = INDEX(CHAR_MESSAGE, CR)
C
	    IF (IND .NE. 0) THEN
	      CALL GETPARM(CHAR_MESSAGE(IND+1:), 
     *                     CMSC_CONF_INFO(NET_PORT_ID), NET_PORT)
	    ENDIF
C
	    IF (NET_PORT .LE. 0) GOTO 9999
C
C VERIFY PORT IS ASSIGNED.
C
	    BADPORT = X2XPN_NETWORK_TO_LOCAL(NET_PORT)
	    IF (BADPORT .LE. 0 .OR.
     *          BADPORT .GT. X2X_LOCAL_PORTS) GOTO 9999
C
C DO NOT SWITCH PORTS FOR THIS NETPORT MORE THAN MSC_SWITCH_LIMIT.
C
	    IF (MSC_PORT_SWITCH_STATE(NET_PORT) .NE.
     *          PORT_SWITCH_ENABLED) GOTO 9999
C
	    IF (MSC_SWITCH_CNT(NET_PORT) .GE. MSC_SWITCH_LIMIT) THEN
	      CALL OPS('*** MSC_RCVBUF - ' //
     *                 'SWITCH LIMIT EXCEEDED FOR NET PORT ***', 
     *                 NET_PORT, NET_PORT)
	      MSC_PORT_SWITCH_STATE(NET_PORT) = PORT_SWITCH_DISABLED
	      GOTO 9999
	    ENDIF
C
C FIND AVAILABLE LOCAL PORT TO ASSIGN.
C
	    CALL GETFREE(BADPORT, FREEPORT)
	    IF (FREEPORT .LE. 0 .OR.
     *          FREEPORT .GT. X2X_LOCAL_PORTS) THEN
	      CALL OPS('*** MSC_RCVBUF - ' //
     *                 'UNABLE TO REASSIGN LOCAL PORT ***',
     *                 BADPORT, BADPORT)
	      CALL OPS('*** MSC_RCVBUF - NO FREE PORTS AVAILABLE ***',
     *                 0, 0)
	      MSC_PORT_SWITCH_STATE(NET_PORT) = PORT_SWITCH_DISABLED
	      GOTO 9999
	    ENDIF
C
C QUE SWITCH COMMAND TO CMDPRO.
C CHANGE NEW PORT STATE TO 'SWITCH IN PROGRESS'
C SO WE DON'T MISTAKENLY ASSIGN IT AGAIN.
C
	    X2XPL_STATE(FREEPORT) = X2XPS_SWITCH_IN_PROG
	    CBUF(1) = CONNECT_PORT
	    CBUF(4) = NET_PORT
	    CBUF(8) = BADPORT
	    CBUF(9) = FREEPORT
	    CALL QUECMD(CBUF, ST)
	    IF (ST .NE. 0)
     *        CALL OPS('*** MSC_RCVBUF - ' //
     *                 'QUEUE COMMAND ERROR ***',
     *                 ST, ST)
C
C IF ACTION REQUIRES RECONNECT THEN GET NETWORK PORT NUMBER FROM MESSAGE, 
C DETERMINE LOCAL PORT NUMBER AND QUEUE SWITCH COMMAND TO MSCMGR WITHOUT
C GOING THRU CMDPRO UNLESS WE'VE EXHAUSTED THE RECONNECT LIMIT AND NEED
C TO SWITCH.
C
	  ELSEIF (ACTION .EQ. MSC_RECONNECT) THEN
D	    TYPE *, IAM(), 'ISSUING RECONNECT'
	    NET_PORT = 0
	    IND      = INDEX(CHAR_MESSAGE, CR)
C
	    IF (IND .NE. 0) THEN
	      CALL GETPARM(CHAR_MESSAGE(IND+1:), 
     *                     CMSC_CONF_INFO(NET_PORT_ID), NET_PORT)
	    ENDIF
C
	    IF (NET_PORT .LE. 0) GOTO 9999
C
C VERIFY PORT IS ASSIGNED.
C
	    LOCAL_PORT = X2XPN_NETWORK_TO_LOCAL(NET_PORT)
	    IF (LOCAL_PORT .LE. 0 .OR.
     *          LOCAL_PORT .GT. X2X_LOCAL_PORTS)
     *        GOTO 9999
C
C IF WE'VE EXHAUSTED THE RECONNECT LIMIT FOR THIS NETWORK PORT THEN
C TRY TO SWITCH.
C
	    IF (MSC_RECONNECT_CNT(NET_PORT) .GE.
     *          MSC_RECONNECT_LIMIT) THEN
C
	      IF (MSC_PORT_SWITCH_STATE(NET_PORT) .NE.
     *            PORT_SWITCH_ENABLED) GOTO 9999
C
	      IF (MSC_SWITCH_CNT(NET_PORT) .GE. MSC_SWITCH_LIMIT) THEN
		CALL OPS('*** MSC_RCVBUF - ' //
     *                   'SWITCH LIMIT EXCEEDED FOR NET PORT ***', 
     *                   NET_PORT, NET_PORT)
		MSC_PORT_SWITCH_STATE(NET_PORT) = PORT_SWITCH_DISABLED
		GOTO 9999
	      ENDIF
C
C FIND AVAILABLE LOCAL PORT TO ASSIGN.
C
	      CALL GETFREE(LOCAL_PORT, FREEPORT)
	      IF (FREEPORT .LE. 0 .OR.
     *            FREEPORT .GT. X2X_LOCAL_PORTS) THEN
		CALL OPS('*** MSC_RCVBUF - ' //
     *                   'UNABLE TO REASSIGN LOCAL PORT ***',
     *                   LOCAL_PORT, LOCAL_PORT)
		CALL OPS('*** MSC_RCVBUF - NO FREE PORTS AVAILABLE ***',
     *                   0, 0)
		MSC_PORT_SWITCH_STATE(NET_PORT) = PORT_SWITCH_DISABLED
		GOTO 9999
	      ENDIF
C
C QUE SWITCH COMMAND TO CMDPRO.
C CHANGE NEW PORT STATE TO 'SWITCH IN PROGRESS'
C SO WE DON'T MISTAKENLY ASSIGN IT AGAIN.
C
	      X2XPL_STATE(FREEPORT) = X2XPS_SWITCH_IN_PROG
	      CBUF(1) = CONNECT_PORT
	      CBUF(4) = NET_PORT
	      CBUF(8) = LOCAL_PORT
	      CBUF(9) = FREEPORT
	      CALL QUECMD(CBUF, ST)
	      IF (ST .NE. 0)
     *          CALL OPS('*** MSC_RCVBUF - ' //
     *                   'QUEUE COMMAND ERROR ***',
     *                   ST, ST)
C
C RESET RECONNECT COUNTER IF SWITCHING.
C
	      MSC_RECONNECT_CNT(NET_PORT) = 0
C
C RECONNECT ONLY.
C
C BUILD CONNECT COMMAND AND QUEUE TO MSCMGR.
C
	    ELSE
	      MSCPARMS(1) = NET_PORT
	      MSCPARMS(2) = LOCAL_PORT
	      CALL BLDCMD(CONNECT_PORT, MSCPARMS, 0)
	      MSC_RECONNECT_CNT(NET_PORT) =
     *        MSC_RECONNECT_CNT(NET_PORT) + 1
	    ENDIF
	  ELSE
	    GOTO 9999
	  ENDIF
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C IF NOT AN ALARM OR STATUS CHECK,
C THEN MUST BE A RESPONSE TO A PREVIOUS COMMAND.
C DETERMINE RESPONSE TYPE AND ACT ACCORDINGLY.
C
	ELSE
	  CALL CHKREPLY(CHAR_MESSAGE, MSGNUM, STATUS)
C
C CHECK IF RESPONSE TO SETUP COMMAND.
C
	  IF (MSGNUM .GE. 1 .AND. MSGNUM .LE. MSC_NUM_MSGS) THEN
	    IF (MSGNUM .LE. MSC_START_RESP) THEN
	      IF (MSGNUM .EQ. MSC_ONLINE_RESP) THEN
		IF (MSCSTS .NE. MSC_REQ_ONLINE) THEN
		  CALL OPS('*** MSC_RCVBUF - INVL_STATE - ' //
     *                     'RE-SYNC HOST<->PC CONNECTION ***',
     *                     MSGNUM, MSCSTS)
 		  MSCSTS = MSC_REQ_ONLINE
		ELSE
		  MSCSTS = MSC_ONLINE
		ENDIF
C
	      ELSEIF (MSGNUM .EQ. MSC_LOGON_RESP) THEN
		IF (MSCSTS .NE. MSC_REQ_LOGON) THEN
		  CALL OPS('*** MSC_RCVBUF - INVL_STATE - ' //
     *                     'RE-SYNC HOST<->PC CONNECTION ***',
     *                     MSGNUM, MSCSTS)
 		  MSCSTS = MSC_REQ_ONLINE
		ELSE
		  MSCSTS = MSC_LOGGED_ON
		ENDIF
C
	      ELSEIF (MSGNUM .EQ. MSC_SETP_RESP) THEN
		IF (MSCSTS .NE. MSC_REQ_PAGE_SET) THEN
		  CALL OPS('*** MSC_RCVBUF - INVL_STATE - ' //
     *                     'RE-SYNC HOST<->PC CONNECTION ***',
     *                     MSGNUM, MSCSTS)
 		  MSCSTS = MSC_REQ_ONLINE
		ELSE
		  MSCSTS = MSC_PAGE_SET
		ENDIF
C
	      ELSEIF (MSGNUM .EQ. MSC_SELECT_RESP) THEN
		IF (MSCSTS .EQ. MSC_ACTIVE .AND.
     *              MSC_CONF_FLAG .EQ. CONF_REC_IN_PROG) THEN
		  MSCCMD = GET_CONFIG // CR
		  CALL MSC_QUECMD(IMSCCMD)
		ELSE
		  IF (MSCSTS .NE. MSC_REQ_SWITCH) THEN
		    CALL OPS('*** MSC_RCVBUF - INVL_STATE - ' //
     *                       'RE-SYNC HOST<->PC CONNECTION ***',
     *                       MSGNUM, MSCSTS)
 		    MSCSTS = MSC_REQ_ONLINE
		  ELSE
		    MSCSTS = MSC_SWITCH_SELECTED
		  ENDIF
		ENDIF
C
	      ELSEIF (MSGNUM .EQ. MSC_START_RESP) THEN
		IF (MSCSTS .NE. MSC_REQ_STARTUP) THEN
		  CALL OPS('*** MSC_RCVBUF - INVL_STATE - ' //
     *                     'RE-SYNC HOST<->PC CONNECTION ***',
     *                     MSGNUM, MSCSTS)
 		  MSCSTS = MSC_REQ_ONLINE
		ELSE
		  MSCSTS = MSC_ACTIVE
		ENDIF
	      ENDIF
C
C IF RESPONSE IS OTHER THAN SETUP RESPONSE THEN MAKE SURE MSC IS ACTIVE.
C IF NOT, RESET LOCAL STATUS (MSCSTS) TO RESTART LOGON PROCESS.
C
	    ELSEIF (MSGNUM .GT. MSC_START_RESP.AND.
     *              MSGNUM .LE. MSC_OFFLINE_RESP) THEN
	      IF (MSCSTS .NE. MSC_ACTIVE) THEN
		IF (MSCSTS .NE. MSC_DOWN) THEN
 		  MSCSTS = MSC_REQ_ONLINE
		  GOTO 9999
		ENDIF
	      ENDIF
C
	      IF (MSGNUM .EQ. MSC_CONNECT_RESP) THEN
D		TYPE *, IAM(), 'CONNECTION SUCCESSFUL'
C
	      ELSEIF (MSGNUM .EQ. MSC_DISP_RESP) THEN
		CALL BLDCONF(CHAR_MESSAGE)
C
	      ELSEIF (MSGNUM.EQ.MSC_ARM_RESP) THEN
		CALL GETPARM(CHAR_MESSAGE, 
     *                       CMSC_CONF_INFO(NET_PORT_ID), NET_PORT)
		MSCPORT = MSC_NETWORK_TO_LOCAL(NET_PORT)
		IF (MSCPORT .GE. 1 .AND.
     *              MSCPORT .LT. MSC_MAX_PORTS) THEN
		  MSC_ALARM_STATUS(MSCPORT) = MSCPA_ENABLED
		ENDIF
C
	      ELSEIF (MSGNUM .EQ. MSC_LOGOFF_RESP .OR.
     *                MSGNUM .EQ. MSC_OFFLINE_RESP) THEN
D		TYPE *, IAM(), 'MSC NOW OFFLINE'
	      ENDIF
C
C ERROR RESPONSE! DUMP ERROR MESSAGE.
C
	    ELSE
	      I = INDEX(CHAR_MESSAGE(10:), CR)
	      IF (I .LE. 0 .OR. I .GT. LEN(OPSMESS) + 10)
     *          I = LEN(OPSMESS) - 10
	      OPSMESS = CHAR_MESSAGE( 2:7) // ' ' //
     *                  CHAR_MESSAGE(10:I+9)
	      CALL OPS(OPSMESS, 0, 0)
	      CALL OPS('*** MSC_RCVBUF - ERROR_RESP -' //
     *                 'RE-SYNC HOST<->PC CONNECTION ***',
     *                 MSGNUM, MSCSTS)
 	      MSCSTS = MSC_REQ_ONLINE
	    ENDIF
C
	    MSC_RESPONSES(MSGNUM) = MSC_RESPONSES(MSGNUM) + 1
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C UNEXPECTED MESSAGE RECEIVED.
C
	  ELSE
D	    TYPE *, IAM(), 'UNEXPECTED MESSAGE FROM MSC:'
D	    TYPE *, IAM(), CHAR_MESSAGE(1:80)
	    CALL OPS('*** MSC_RCVBUF - UNEXPECTED - ' //
     *               'RE-SYNC HOST<->PC CONNECTION ***',
     *               MSGNUM, MSCSTS)
 	    MSCSTS = MSC_REQ_ONLINE
	    MSC_RESPONSES(0) = MSC_RESPONSES(0) + 1
	  ENDIF
	ENDIF
C
C MSC MAY SEND SUBSEQUENT PACKETS WITH AN ALARM OR
C COMMAND RESPONSE TO FURTHER DESCRIBE THE ERROR OR COMMAND CONDITION.
C GENERALLY, WE ONLY USE THE FIRST PACKET. IF IT WAS NOT AN ALARM OR
C RECOGNIZED RESPONSE, WE WILL FALL THRU THE ABOVE CODE,
C RELEASE THE BUFFER, AND CONTINUE EXECUTION.
C
9999    CONTINUE
	CALL MSCRELB(BUF)
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C RETURN & END.
C
	RETURN
	END
