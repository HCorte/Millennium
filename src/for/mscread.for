C *** SUBROUTINE MSCREAD ***
C
C V07 13-JUN-2000 OXK MSC_PACKET_TYPE & BYTE_CNT from MSCCOM.DEF to here 
C			(not used elsewhere)
C V06 09-MAR-1995 PJS MOVE CODE TO DUMP BUFFER TO STANDARD OUTPUT.
C V05 15-FEB-1994 PJS TRI-STATE RFSS # 3.
C                       MODIFIED TO HANDLE TIMEOUTS, INVALID PACKET LENGTH, AND
C                       BAD LRCs, BETTER. ALSO, CLEANED UP A BIT.
C V04 14-DEC-1993 RRB/PJS ADDED CALL TO MSC_CLRTYPAHD WHEN OUT OF SYNC.
C V03 09-DEC-1993 RRB NO LONGER AN AST ROUTINE. READ AFTER WRITE IN SNDBUF. 
C V02 07-JAN-1993 RRB ADD BUFFERS TO EXEC QUEUE
C V01 29-JAN-1991 RRB RELEASED FOR VAX
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode Island,
C and contains confidential and trade secret information. It may not be
C transferred from the custody or control of GTECH except as authorized in
C writing by an officer of GTECH. Neither this item nor the information it
C contains may be used, transferred, reproduced, published, or disclosed,
C in whole or in part, and directly or indirectly, except as expressly
C authorized by an officer of GTECH, pursuant to written agreement.
C
C Copyright 2000 GTECH Corporation. All rights reserved.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose:
C	THIS SUBROUTINE WILL INTERCEPT AND SERVICE ALL READS
C	FROM A DEVICE CONNECTED TO THE TELENEX MATRIX SWITCH CONTROLLER.
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	SUBROUTINE MSCREAD
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
C
	INCLUDE 'INCLIB:MSCCOM.DEF'
	INCLUDE 'INCLIB:MSCEVN.DEF'
C
        INCLUDE '($SSDEF)'
        INCLUDE '($SYSSRVNAM)'
C
C LOCAL DECLARATIONS
C
	INTEGER*4	BUF,				! BUFFER NUMBER.
     *			I,
     *			J,
     *			MSCLRC,				! LRC FROM DATA PACKET.
     *			MSC_RETRY,			! RETRY COUNTER.
     *			MSC_RETRY_MAX	/3/,		! RETRY MAXIMUM.
     *			MYLRC,				! CALCULATED LRC.
     *			I4LEN,				! DATA PACKET LENGTH.
     *			ST,
     *			STATUS
C
	INTEGER*2	I2LEN				! DATA PACKET LENGTH.
C
	BYTE		BLEN(2),			! DATA PACKET LENGTH.
     *			LRCBUF(MSCBYTLEN + 2),
     *			MSC_READ_BUFFER(MSCBYTLEN)	! MSC DATA
C
CV07 Previously in MSCCOM.DEF
	INTEGER*4       MSC_PACKET_TYPE                 ! PACKET TYPE
	BYTE            BYTE_CNT(2)                     ! # OF DATA BYTES
C
	EQUIVALENCE	(I2LEN, BLEN(1))
	EQUIVALENCE	(LRCBUF(1), BYTE_CNT)
	EQUIVALENCE	(LRCBUF(3), MSC_READ_BUFFER)
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C INITIALIZE RETRY COUNTER.
C
	MSC_RETRY = 0
C
C SET READ IN PROGRESS & INCREMENT COUNTERS.
C
100	CONTINUE
	MSC_READ_IN_PROG = .TRUE.
	MSC_READCNT      = MSC_READCNT + 1
	MSC_RETRY        = MSC_RETRY + 1
C
C INIT BUFFER.
C
	CALL FASTSET(0, MSC_READ_BUFFER, MSCBYTLEN / 4)
C
C START READ FOR FIRST BYTE WHICH IS PACKET TYPE INDICATOR.
C NOT VERY EFFICIENT BUT TELENEX DOES NOT PROVIDE EOT INDICATOR, SO ...
C WE HAVE TO PERFORM MULTIPLE READS FOR WHAT SHOULD BE A SINGLE READ OPERATION.
C
	CALL MSCREADW(MSC_PACKET_TYPE, 1, STATUS)
C
C CHECK I/O STATUS BLOCK FROM INITIAL READ.
C
	IF (MSC_READIOSB.STAT .NE. SS$_NORMAL) THEN
	  IF (MSC_READIOSB.STAT .EQ. SS$_TIMEOUT) THEN
	    ST = SYS$SETEF(%VAL(MSC_TOUT_FLAG))
	    IF (.NOT. ST) CALL LIB$SIGNAL(%VAL(ST))
	    CALL MSC_CLRTYPAHD				! FLUSH THE TYPEAHEAD.
	    GOTO 9999					! ABORT THE READ.
C
	  ELSE IF (MSC_READIOSB.STAT .EQ. SS$_HANGUP) THEN
	    CALL OPS('SERVER CONNECTION LOST ', SS$_HANGUP, SS$_HANGUP)
	    MSC_CONNECT_FLAG = MSC_CLOSED
	    CALL MSC_CLRTYPAHD				! FLUSH THE TYPEAHEAD.
	    GOTO 9999					! ABORT THE READ.
C
	  ELSE IF (MSC_READIOSB.STAT .EQ. SS$_ABORT) THEN
	    CALL OPS('SERVER CONNECTION LOST ', SS$_ABORT, SS$_ABORT)
	    MSC_CONNECT_FLAG = MSC_CLOSED
	    CALL MSC_CLRTYPAHD				! FLUSH THE TYPEAHEAD.
	    GOTO 9999					! ABORT THE READ.
C
	  ELSE
	    CALL LIB$SIGNAL(%VAL(MSC_READIOSB.STAT))
	  ENDIF
	ENDIF
C
C UPDATE LAST RECV TIME.
C
	CALL GETTIM(MSC_LAST_RECV_TIME)
C
C DETERMINE MESSAGE TYPE.
C IF START OF DATA PACKET, READ THE NEXT TWO BYTES CONTAINING BYTE_CNT.
C
	IF (MSC_PACKET_TYPE .EQ. SOH) THEN
	  CALL MSCREADW(BYTE_CNT, 2, STATUS)
C
	  IF (MSC_READIOSB.STAT .NE. SS$_NORMAL) THEN
	    IF (MSC_READIOSB.STAT .EQ. SS$_TIMEOUT) THEN
	      ST = SYS$SETEF(%VAL(MSC_TOUT_FLAG))
	      IF (.NOT. ST) CALL LIB$SIGNAL(%VAL(ST))
	      CALL MSC_CLRTYPAHD			! FLUSH THE TYPEAHEAD.
	      GOTO 9999					! ABORT THE READ.
C
	    ELSE IF (MSC_READIOSB.STAT .EQ. SS$_HANGUP) THEN
	      CALL OPS('SERVER CONNECTION LOST ',SS$_HANGUP,SS$_HANGUP)
	      MSC_CONNECT_FLAG = MSC_CLOSED
	      CALL MSC_CLRTYPAHD			! FLUSH THE TYPEAHEAD.
	      GOTO 9999					! ABORT THE READ.
C
	    ELSE IF (MSC_READIOSB.STAT .EQ. SS$_ABORT) THEN
	      CALL OPS('SERVER CONNECTION LOST ', SS$_ABORT, SS$_ABORT)
	      MSC_CONNECT_FLAG = MSC_CLOSED
	      CALL MSC_CLRTYPAHD			! FLUSH THE TYPEAHEAD.
	      GOTO 9999					! ABORT THE READ.
C
	    ELSE
	      CALL LIB$SIGNAL(%VAL(MSC_READIOSB.STAT))
	    ENDIF
	  ENDIF
C
C DETERMINE LENGTH OF DATA TO READ AND COMPLETE READ OPERATION.
C (BYTE COUNT PLUS ONE BYTE FOR BLOCK TYPE AND ONE BYTE FOR LRC CHECKSUM)
C
	  BLEN(1) = BYTE_CNT(2)
	  BLEN(2) = BYTE_CNT(1)
	  I4LEN   = I2LEN + 2
C
	  IF (I4LEN .GT. MSCBYTLEN) THEN
	    CALL OPS('INVALID PACKET LENGTH RECEIVED FROM MSC ',
     *               I4LEN, I4LEN)
	    CALL MSC_CLRTYPAHD				! FLUSH THE TYPEAHEAD.
	    IF (MSC_RETRY .LT. MSC_RETRY_MAX) THEN
	      CALL MSCWRITEW(NAK, 1, ST)		! REPLY WITH A 'NAK'.
	      GOTO 100					! RE-ISSUE THE READ.
	    ENDIF
	    GOTO 9999					! ABORT THE READ.
	  ENDIF
C
	  CALL MSCREADW(MSC_READ_BUFFER, I4LEN, STATUS)
C
	  IF (MSC_READIOSB.STAT .NE. SS$_NORMAL) THEN
	    IF (MSC_READIOSB.STAT .EQ. SS$_TIMEOUT) THEN
	      CALL MSC_CLRTYPAHD			! FLUSH THE TYPEAHEAD.
	      IF (MSC_RETRY .LT. MSC_RETRY_MAX) THEN
		CALL MSCWRITEW(NAK, 1, ST)		! REPLY WITH A 'NAK'.
		GOTO 100				! RE-ISSUE THE READ.
	      ELSE
		ST = SYS$SETEF(%VAL(MSC_TOUT_FLAG))
		IF (.NOT. ST) CALL LIB$SIGNAL(%VAL(ST))
	        GOTO 9999				! ABORT THE READ.
	      ENDIF
C
	    ELSE IF (MSC_READIOSB.STAT .EQ. SS$_HANGUP) THEN
	      CALL OPS('SERVER CONNECTION LOST ', 0, 0)
	      MSC_CONNECT_FLAG = MSC_CLOSED
	      CALL MSC_CLRTYPAHD			! FLUSH THE TYPEAHEAD.
	      GOTO 9999					! ABORT THE READ.
C
	    ELSE IF(MSC_READIOSB.STAT.EQ.SS$_ABORT) THEN
	      CALL OPS('SERVER CONNECTION LOST ',0,0)
	      MSC_CONNECT_FLAG = MSC_CLOSED
	      CALL MSC_CLRTYPAHD			! FLUSH THE TYPEAHEAD.
	      GOTO 9999					! ABORT THE READ.
C
	    ELSE
	      CALL LIB$SIGNAL(%VAL(MSC_READIOSB.STAT))
	    ENDIF
	  ENDIF

C SET TEST FLAG TO DUMP BUFFER TO STANDARD OUTPUT.
C
	  IF (MSC_TEST .NE. 0) THEN
	    TYPE *, IAM(), 'READ BUFFER LEN=',I4LEN,':'
	    DO 200 I = 1, (I4LEN + 39) / 40
	      WRITE(5, 9000) (MSC_READ_BUFFER(J), J = 40*I-39, I*40)
200	    CONTINUE
	  ENDIF
C
C CALCULATE LRC AND COMPARE TO THE ONE RECEIVED
C
	  MSCLRC = ZEXT(MSC_READ_BUFFER(I4LEN))		! LAST BYTE IS LRC.
	  CALL GETLRC(LRCBUF, 1, I4LEN + 1, MYLRC)
C
C CHECK LRC, IF BAD, NAK MESSAGE.
C
	  IF (MYLRC .NE. MSCLRC) THEN
	    CALL OPS('INVALID PACKET LRC RECEIVED FROM MSC ',
     *               MYLRC, MSCLRC)
	    CALL MSC_CLRTYPAHD				! FLUSH THE TYPEAHEAD.
	    IF (MSC_RETRY .LT. MSC_RETRY_MAX) THEN
	      CALL MSCWRITEW(NAK, 1, ST)		! REPLY WITH A 'NAK'.
	      GOTO 100					! RE-ISSUE THE READ.
	    ENDIF
	    GOTO 9999					! ABORT THE READ.
	  ENDIF
C
C ALL IS WELL ... ACK THE MESSAGE.
C
	  CALL MSCWRITEW(ACK, 1, ST)
C
C THE MSC ONLY ACKNOWLEDGES APPLICATION COMMANDS BUT SENDS AN IMMEDIATE
C RESPONSE TO A POLL COMMAND. MSCMGR WILL WAIT FOR A RESPONSE FOR EITHER.
C
	  IF (MSC_WRITE_IN_PROG) THEN
	    ST = SYS$SETEF(%VAL(MSC_ACK_FLAG))
	    IF (.NOT. ST) CALL LIB$SIGNAL(%VAL(ST))
	  ENDIF
C
C PLACE BUFFER ON EXEC QUE  
C
	  CALL MSCGETB(BUF,ST)
	  IF (ST .NE. GLIST_STAT_EMPTY) THEN
	    CALL FASTMOV(MSC_READ_BUFFER, MSCBUF(1,BUF), (I4LEN+3)/4)
	    MSCBUF(MSCBLEN, BUF) = MSCBTYPIN
	    CALL ABL(BUF, MSCEXEC, STATUS)
	  ENDIF
C
	  STATUS = SYS$SETEF(%VAL(MSC_EXEC_FLAG))
	  IF (.NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
C
C
C  IF ACK, SET ACKNOWLEDGEMENT FLAG (VERIFY WRITE IN PROGRESS).
C
	ELSEIF (MSC_PACKET_TYPE .EQ. ACK) THEN
	  IF (MSC_WRITE_IN_PROG) THEN
	    ST = SYS$SETEF(%VAL(MSC_ACK_FLAG))
	    IF (.NOT. ST) CALL LIB$SIGNAL(%VAL(ST))
	  ENDIF
C
C IF NAK, SET NAK EVENT FLAG TO CAUSE MSCSNDBUF TO RE-ISSUE WRITE.
C
	ELSE IF (MSC_PACKET_TYPE .EQ. NAK) THEN
	  IF (MSC_WRITE_IN_PROG) THEN
	    ST = SYS$SETEF(%VAL(MSC_NAK_FLAG))
	    IF (.NOT. ST) CALL LIB$SIGNAL(%VAL(ST))
	  ENDIF
C
C ERROR ... UNKNOWN PACKET TYPE.
C
	ELSE
	  CALL OPS('UNKNOWN PACKET RECEIVED FROM MSC ',
     *             MSC_PACKET_TYPE, MSC_PACKET_TYPE)
	  CALL MSC_CLRTYPAHD				! FLUSH THE TYPEAHEAD.
	  GOTO 9999					! ABORT THE READ.
	ENDIF
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C FORMAT STATEMENTS.
C
9000	FORMAT(X, 40(Z2.2))
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C RETURN & END.
C
9999	CONTINUE
	MSC_READ_IN_PROG = .FALSE.
C
	RETURN
	END
