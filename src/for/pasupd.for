C
C PASUPD.FOR
C
C V01 05-JAN-01 ANG INITIAL RELEASE FOR PORTUGAL
C
C PROGRAM WILL UPDATE PASSIVE LOTTERY CLOSING DATES/TIMES
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode Island,
C and contains confidential and trade secret information. It may not be
C transferred from the custody or control of GTECH except as authorized in
C writing by an officer of GTECH. Neither this item nor the information it
C contains may be used, transferred, reproduced, published, or disclosed,
C in whole or in part, and directly or indirectly, except as expressly
C authorized by an officer of GTECH, pursuant to written agreement.
C
C Copyright 1993 GTECH Corporation. All rights reserved.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
      PROGRAM PASUPD
      IMPLICIT NONE

      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:GTECHSMG.DEF'
C
C LOCAL VARIABLES
C
      CHARACTER*29    MYMENU(4) /'[   ALTERAR DATA/HORARIO    ]',
     *                           '[ ATUALIZAR SOMENTE HORARIO ]',
     *                           '[      ADIAR EXTRACAO       ]',
     *                           '[           SAIR            ]'/

      CHARACTER*78  cMSG

      INTEGER PB,			      ! PASTEBOARD
     *        KEYB,			      ! VIRTUAL KEYBOARD
     *        DISP1,			      ! header frame window
     *        DISP2,			      ! output data frame window
     *        DISP3,			      ! message frame window
     *	      DISPMENU			      ! INITIAL MENU

	INTEGER DEFAULT/1/
	INTEGER*4 ST,MENUOPT

C
C CREATES SCREEN HEADER - DISP1
C
      ST = SMG$CREATE_VIRTUAL_DISPLAY( 1, 78, DISP1, SMG$M_BORDER)
      ST = SMG$LABEL_BORDER (DISP1,' SCML ',
     *			     SMG$K_TOP, 70,
     *                       SMG$M_BLINK, SMG$M_BOLD)

      cMSG = '     DATAS/HORARIOS DE LOTARIA NACIONAL DE BILHETES     v1.0 '
      ST   = SMG$PUT_CHARS (DISP1, cMSG, 1, 8)
C
C CREATES INPUT DISPLAY - DISP2
C
      ST = SMG$CREATE_VIRTUAL_DISPLAY ( 16, 78, DISP2, SMG$M_BORDER)
C
C CREATES MESSAGE AND ERROR DISPLAY - DISP3
C
      ST = SMG$CREATE_VIRTUAL_DISPLAY ( 1, 78, DISP3, SMG$M_BORDER)
      ST = SMG$LABEL_BORDER (DISP3,' Mensagem ', SMG$K_TOP, 65, SMG$M_REVERSE)
C
C CREATES VIRTUAL  KEYBOARD - KEYB 
C (inhibit numeric keypad mode if debug)
C
      ST = SMG$CREATE_VIRTUAL_KEYBOARD (KEYB)         
C
C CREATES PASTEBOARD - PB 
C
      ST = SMG$CREATE_PASTEBOARD (PB)
      IF (.NOT.ST) CALL LIB$STOP (%VAL(ST))
C
C CREATES MENU 
C
      ST = SMG$CREATE_VIRTUAL_DISPLAY(11, 30, DISPMENU)
      ST = SMG$CREATE_MENU(DISPMENU, MYMENU, SMG$K_VERTICAL, 
     *			   SMG$M_DOUBLE_SPACE, 2, SMG$M_REVERSE)
C
C PASTING  VIRTUAL  DISPLAYS  ON  TERMINAL  SCREEN 
C
      ST = SMG$PASTE_VIRTUAL_DISPLAY (DISP1, PB,  2, 2)
      ST = SMG$PASTE_VIRTUAL_DISPLAY (DISP2, PB,  5, 2)
      ST = SMG$PASTE_VIRTUAL_DISPLAY (DISP3, PB, 23, 2)

      ST = SMG$SET_CURSOR_MODE (PB, SMG$M_CURSOR_ON )
      ST = SMG$ERASE_DISPLAY (DISP3)
	
	MENUOPT = 0
	DO WHILE(MENUOPT.NE.4)
      	    ST = SMG$LABEL_BORDER (DISP2,'  Menu Principal   ',
     *                             SMG$K_TOP, 59, SMG$M_REVERSE)

      	    cMSG = '    Use setas para movimentar cursor e <ENTER> para selecionar '
      	    ST = SMG$PUT_CHARS (DISP3, cMSG, 1,1)
	    ST = SMG$SET_CURSOR_MODE(PB, SMG$M_CURSOR_ON)

      	    ST = SMG$PASTE_VIRTUAL_DISPLAY(DISPMENU, PB, 7, 25)
      	    ST = SMG$SELECT_FROM_MENU(KEYB, DISPMENU, MENUOPT, 
     *				       DEFAULT,,,,,,SMG$M_BOLD)
	    ST = SMG$SET_CURSOR_MODE(PB, SMG$M_CURSOR_OFF)
      	    ST = SMG$UNPASTE_VIRTUAL_DISPLAY (DISPMENU,PB)

	    ST = SMG$ERASE_DISPLAY(DISP2)
	    ST = SMG$ERASE_DISPLAY(DISP3)

	    IF(MENUOPT.EQ.1) THEN		
 		CALL UPD_DATETIME(DISP2,DISP3,KEYB,PB)
	    ELSEIF(MENUOPT.EQ.2) THEN
		CALL UPD_TIME(DISP2,DISP3,KEYB,PB)		
	    ELSEIF(MENUOPT.EQ.3) THEN
		CALL POSTPONE(DISP2,DISP3,KEYB,PB)		
	    ENDIF
	ENDDO 

      ST = SMG$UNPASTE_VIRTUAL_DISPLAY (DISP1,PB)
      ST = SMG$UNPASTE_VIRTUAL_DISPLAY (DISP2,PB)
      ST = SMG$UNPASTE_VIRTUAL_DISPLAY (DISP3,PB)

      ST = SMG$DELETE_VIRTUAL_DISPLAY (DISP1,PB)
      ST = SMG$DELETE_VIRTUAL_DISPLAY (DISP2,PB)
      ST = SMG$DELETE_VIRTUAL_DISPLAY (DISP3,PB)
      ST = SMG$DELETE_VIRTUAL_DISPLAY (DISPMENU,PB)

      ST = SMG$DELETE_PASTEBOARD (PB)

      CALL GSTOP (GEXIT_SUCCESS)
      END

C**********************************************
C SUBROUTINE UPD_DATETIME
C**********************************************
C UPDATE EMISSION CLOSE TIME AND DATE, ON P*F AND DAF FILE
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE UPD_DATETIME(DISP2,DISP3,KEYB,PB)
	IMPLICIT NONE

        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
      	INCLUDE 'INCLIB:GTECHSMG.DEF'
C
C ROUTINE PARAMETERS
C
	INTEGER KEYB,DISP2,DISP3,PB,KEY
	INTEGER*4 GIND
C
C LOCAL VARIABLES
C
	CHARACTER*78 CMSG

	INTEGER*4 EMIS,ST,GNUM,WEEKINI,YEARINI,WEEKFIM,YEARFIM
	INTEGER*4 DAYWEEK(7),CLSTIME(7),CDC

        CMSG = ' Digite o tipo de emissao (1-Classica 2-Popular): '
        ST = SMG$PUT_CHARS (DISP2, CMSG, 4, 4)
        CALL SMG_INPNUM(PB,KEYB,DISP2,DISP3,GIND,4,68,2,1,NUMPAS,ST)

	ST = SMG$ERASE_DISPLAY(DISP2)

	GNUM = GTNTAB(TPAS,GIND)

	IF (GNUM.LE.0) THEN
	  CMSG = ' Jogo nao esta ativo...'
          CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
          ST = SMG$ERASE_DISPLAY(DISP2)
          RETURN
	ENDIF

	CALL FASTSET(0,DAYWEEK,7)
	CALL FASTSET(0,CLSTIME,7)
C
C CHANGE VIRTUAL DISPLAY LABEL
C
        ST = SMG$LABEL_BORDER (DISP2,'Extracao - Dia/hora',
     *                         SMG$K_TOP, 59, SMG$M_REVERSE)
C
C PROMPT FOR DAY OF WEEK AND CLOSING TIME
C
	CALL GET_DAYWEEK(DAYWEEK,CLSTIME,DISP2,DISP3,KEYB,PB)
C
C PROMPT FOR FIRST EMISSION WITH NEW CONFIGURATION
C
        ST = SMG$ERASE_DISPLAY(DISP2)

	DO WHILE (.TRUE.)
	   WEEKINI = 0
	   YEARINI = 0
	   WEEKFIM = 0
	   YEARFIM = 0
      	   CMSG = ' Extracao Inicial p/ esta Configuracao: '
           CALL GET_EMISNO_WEK(GNUM,CMSG,EMIS,DISP2,DISP3,KEYB,PB,WEEKINI,YEARINI,0)

      	   CMSG = ' Extracao Final p/ esta Configuracao: '
           CALL GET_EMISNO_WEK(GNUM,CMSG,EMIS,DISP2,DISP3,KEYB,PB,WEEKFIM,YEARFIM,1)

	   IF (YEARINI.NE.YEARFIM.OR.WEEKINI.GT.WEEKFIM) THEN
              CMSG = 'Numero de extracao inicial ou final esta invalido'
              CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
              ST = SMG$ERASE_DISPLAY(DISP2)
	   ELSE
	      EXIT
	   ENDIF
	ENDDO

        CMSG = ' Digite a posicao inicial: '
        ST = SMG$PUT_CHARS (DISP2, CMSG, 8, 4)
        CALL SMG_INPNUM(PB,KEYB,DISP2,DISP3,EMIS,8,57,7,1,9999999,ST)

C
C PROMPT FOR FIRST CDC WITH NEW CONFIGURATION
C
	CALL GET_FIRSTCDC(CDC,DISP2,DISP3,KEYB,PB)
C
C ASK FOR CONFIRMATION
C
	CMSG = ' Deseja gravar novas datas e horarios ?'
	CALL MENU_CONFIRM(CMSG,16,4,DISP2,KEYB,PB,ST)
	IF(ST.NE.0) THEN
	    ST = SMG$ERASE_DISPLAY(DISP2)
	    ST = SMG$ERASE_DISPLAY(DISP3)
	    RETURN
	ENDIF
C
C UPDATE DAF AND GAME FILE
C
	CALL UPD_FILES(GNUM,CDC,EMIS,DAYWEEK,CLSTIME,DISP3,KEYB,0,WEEKINI,YEARINI,WEEKFIM)
C
C CLEAR VIRTUAL DISPLAYS
C
	ST = SMG$ERASE_DISPLAY(DISP2)
	ST = SMG$ERASE_DISPLAY(DISP3)

	RETURN
	END
C**********************************************
C SUBROUTINE UPD_TIME
C**********************************************
C UPDATE EMISSION CLOSE TIME, JUST ON P*F FILE
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE UPD_TIME(DISP2,DISP3,KEYB,PB)
	IMPLICIT NONE

        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:DPAREC.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C
C ROUTINE PARAMETERS
C
	INTEGER KEYB,DISP2,DISP3,PB
	INTEGER*4 GIND
C
C LOCAL VARIABLES
C
	CHARACTER*77 CMSG

	INTEGER KEY
	INTEGER*4 EMIS,LSTEMIS,UNIT,ST,FDB(7),GNUM,NEWTIM

        CMSG = ' Digite o tipo de emissao (1-Classica 2-Popular): '
        ST = SMG$PUT_CHARS (DISP2, CMSG, 4, 4)
        CALL SMG_INPNUM(PB,KEYB,DISP2,DISP3,GIND,4,68,2,1,NUMPAS,ST)

	ST = SMG$ERASE_DISPLAY(DISP2)

	GNUM = GTNTAB(TPAS,GIND)

	IF (GNUM.LE.0) THEN
	  CMSG = ' Jogo nao esta ativo...'
          CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
          ST = SMG$ERASE_DISPLAY(DISP2)
          RETURN
	ENDIF
C
C CHANGE VIRTUAL DISPLAY LABEL
C
        ST = SMG$LABEL_BORDER (DISP2,' Troca de Horario  ',
     *                         SMG$K_TOP, 59, SMG$M_REVERSE)
C
C PROMPT USER FOR EMISSION RANGE AND NEW CLOSING TIME
C
        ST = SMG$ERASE_DISPLAY(DISP2)

	CALL GET_EMIS_RANGE(GNUM,EMIS,LSTEMIS,DISP2,DISP3,KEYB,PB)
	CALL GET_NEW_TIME(NEWTIM,10,4,DISP2,DISP3,KEYB,PB,ST)

	CMSG = ' Deseja gravar novos horarios desta(s) extracao(oes) ?'
	CALL MENU_CONFIRM(CMSG,12,4,DISP2,KEYB,PB,ST)
	IF(ST.NE.0) THEN
	    ST = SMG$ERASE_DISPLAY(DISP2)
	    ST = SMG$ERASE_DISPLAY(DISP3)
	    RETURN
	ENDIF

	IF (EMIS.LE.0.OR.LSTEMIS.LE.0) THEN
	   WRITE (CMSG,80) 
	   CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	   ST = SMG$ERASE_DISPLAY(DISP2)
	   ST = SMG$ERASE_DISPLAY(DISP3)
	   RETURN
	ENDIF

C
C IF USER CONFIRMS, UPDATE FILE
C
      	WRITE(cMSG,30) GFNAMES(1,GNUM)
      	ST = SMG$PUT_CHARS (DISP3, cMSG, 1,1)
C
C FIND AVAILABLE UNIT AND OPEN GAME FILE
C
	CALL FIND_AVAILABLE_LUN(UNIT,ST)
	IF(ST.NE.0) THEN
	  WRITE (CMSG,40) GFNAMES(1,GNUM)
	  CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	  ST = SMG$ERASE_DISPLAY(DISP2)
	  RETURN
	ENDIF

	CALL OPENW(UNIT,GFNAMES(1,GNUM),4,0,0,ST)
	IF(ST.NE.0) THEN
	  WRITE (CMSG,50) GFNAMES(1,GNUM)
	  CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	ELSE
	  CALL IOINIT(FDB,UNIT,DPASEC*256)
C
C LOOP UPDATING CLOSING TIME
C
	  DO WHILE(EMIS.LE.LSTEMIS)
	    CALL READW(FDB,(EMIS-PAS_DRW_OFFSET),DPAREC,ST)
	    IF(ST.NE.0) THEN
		WRITE (CMSG,60) EMIS,ST
		CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	    ELSE
		DPATIM    = NEWTIM
		DPACHGCDC = DAYCDC
		CALL WRITEW(FDB,(EMIS-PAS_DRW_OFFSET),DPAREC,ST)
		IF(ST.NE.0) THEN
		    WRITE(CMSG,70) EMIS,ST
		    CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
		ENDIF
	    ENDIF
C
C ABORT LOOP
C
	    IF(KEY.EQ.iNEXT_KEY) EMIS=LSTEMIS

	    EMIS = EMIS + 1
	  ENDDO

	ENDIF
C
C CLEAR VIRTUAL DISPLAYS
C
	ST = SMG$ERASE_DISPLAY(DISP2)
	ST = SMG$ERASE_DISPLAY(DISP3)
C
C CLOSE GAME FILE
C
	CALL CLOSEFIL(FDB)

	RETURN
C
C FORMAT STATEMENTS
C
30	FORMAT(' Atualizando horario de fechamento no arquivo ',5A4)
40	FORMAT(' Nao ha handle para abertura do arquivo ',5A4,
     *	       ' Qualquer tecla p/ continuar')
50	FORMAT(' Erro de abertura no arquivo ',5A4,
     *	       ' Qualquer tecla p/ continuar')
60	FORMAT(' Erro de leitura, extracao ',I6,' status ',I4,
     *	       ' Qualquer tecla p/ continuar')
70	FORMAT(' Erro de escrita, extracao ',I6,' status ',I4,
     *	       ' Qualquer tecla p/ continuar')
80	FORMAT(' Erro obtendo concurso interno... Qualquer tecla p/ continuar')
	END
C**********************************************
C SUBROUTINE POSTPONE
C**********************************************
C ROUTINE TO POSTPONE EMISSION
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE POSTPONE(DISP2,DISP3,KEYB,PB)
	IMPLICIT NONE

        INCLUDE 'INCLIB:SYSPARAM.DEF'
        INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:DPAREC.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:DATBUF.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C
C ROUTINE PARAMETERS
C
	INTEGER KEYB,DISP2,DISP3,PB
	INTEGER*4 GIND
C
C LOCAL VARIABLES
C
	CHARACTER*77 CMSG

	INTEGER KEY
	INTEGER*2 DAT(12)
	INTEGER*4 EMIS,UNIT,ST,FDB(7),GNUM
	INTEGER*4 DAYWEEK(7),CLSTIME(7)
	INTEGER*4 OFF,WEEK,YEAR,WEEKFIM

	EMIS = 0
	CALL FASTSET(0,DAYWEEK,7)
	CALL FASTSET(0,CLSTIME,7)

        CMSG = ' Digite o tipo de emissao (1-Classica 2-Popular): '
        ST = SMG$PUT_CHARS (DISP2, CMSG, 4, 4)
        CALL SMG_INPNUM(PB,KEYB,DISP2,DISP3,GIND,4,68,2,1,NUMPAS,ST)

	ST = SMG$ERASE_DISPLAY(DISP2)

	GNUM = GTNTAB(TPAS,GIND)

	IF (GNUM.LE.0) THEN
	  CMSG = ' Jogo nao esta ativo...'
          CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
          ST = SMG$ERASE_DISPLAY(DISP2)
          RETURN
	ENDIF
C
C PROMPT FOR DAY OF WEEK AND CLOSING TIME
C
	CALL GET_DAYWEEK(DAYWEEK,CLSTIME,DISP2,DISP3,KEYB,PB)
C
C PROMPT FOR EMISSION TO BE POSTPONED
C
        ST = SMG$ERASE_DISPLAY(DISP2)
 
      	CMSG = ' Digite a extracao a ser adiada: '
        CALL GET_EMISNO_WEK(GNUM,CMSG,EMIS,DISP2,DISP3,KEYB,PB,WEEK,YEAR,0)

        ST = SMG$ERASE_DISPLAY(DISP2)
C
C FIND AVAILABLE UNIT
C
	CALL FIND_AVAILABLE_LUN(UNIT,ST)
	IF(ST.NE.0) THEN
	  WRITE (CMSG,40) GFNAMES(1,GNUM)
	  CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	  ST = SMG$ERASE_DISPLAY(DISP2)
	  RETURN
	ENDIF
C
C OPEN GAME FILE
C
	CALL OPENW(UNIT,GFNAMES(1,GNUM),4,0,0,ST)
	IF(ST.NE.0) THEN
	    WRITE (CMSG,50) GFNAMES(1,GNUM)
	    CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	ELSE
	    CALL IOINIT(FDB,UNIT,DPASEC*256)

	    CALL READW(FDB,(EMIS-PAS_DRW_OFFSET),DPAREC,ST)
	    IF(ST.NE.0) THEN
		WRITE (CMSG,80) EMIS,ST
		CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	    ELSE
		CALL CLOSEFIL(FDB)

		IF(DPAESD.LE.0) THEN
		    TYPE *,IAM(),'CDC INICIAL INVALIDO...'
		    CALL GPAUSE
		ENDIF
C
C DISPLAY OLD DATE FOR POSTPONED DRAW
C
		DAT(VCDC) = DPAESD
		CALL CDATE(DAT)		
		WRITE (CMSG,100) (DAT(OFF),OFF=9,12) 
		ST = SMG$PUT_CHARS (DISP2, CMSG, 15, 1,
     *				    SMG$M_BOLD,
     *				    SMG$M_REVERSE)
C
C ASK FOR CONFIRMATION
C
		CMSG = ' Deseja realmente adiar esta extracao?'
		CALL MENU_CONFIRM(CMSG,16,4,DISP2,KEYB,PB,ST)
		IF(ST.NE.0) THEN
		    ST = SMG$ERASE_DISPLAY(DISP2)
 		    ST = SMG$ERASE_DISPLAY(DISP3)
		    RETURN
		ENDIF
C
C UPDATE DAF AND GAME FILE
C
		WEEKFIM = WEEK
		CALL UPD_FILES(GNUM,DPAESD+1,EMIS,DAYWEEK,CLSTIME,DISP3,KEYB,1,WEEK,YEAR,WEEKFIM)
	    ENDIF
	ENDIF

	ST = SMG$ERASE_DISPLAY(DISP2)
	RETURN
C
C FORMAT STATEMENTS
C
40	FORMAT(' Nao ha handle para abertura do arquivo ',5A4,
     *	       ' Qualquer tecla p/ continuar')
50	FORMAT(' Erro de abertura no arquivo ',5A4,
     *	       ' Qualquer tecla p/ continuar')
80	FORMAT(' Erro de leitura, extracao ',I6,' status ',I4, 
     *	       ' Qualquer tecla p/continuar')
100	FORMAT(4X,'Extracao do dia ',4A2,' sera adiada !')
	END

C**********************************************
C SUBROUTINE GET_EMISNO_WEK
C**********************************************
C PROMPT USER FOR EMISSION NUMBER
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_EMISNO_WEK(GNUM,CMSG,IEMIS,DISP2,DISP3,IKEYB,PB,WEEK,YEAR,LIN)
	IMPLICIT NONE

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C 
C LOCAL VARIABLES
C
	CHARACTER*78 CMSG
	CHARACTER*3 SLASH/' / '/

	INTEGER   IKEYB,DISP2,DISP3,IST,PB

	INTEGER*4 IEMIS, GNUM, LIN

        INTEGER*4 YEAR,WEEK
        INTEGER*4 GETDRW             !FUNTION

        IEMIS = 0
        WEEK  = 0
        YEAR  = 0

        IST = SMG$SET_CURSOR_MODE(PB, SMG$M_CURSOR_OFF)

C       CMSG = ' Entre com o numero da extracao: '    
        IST = SMG$PUT_CHARS(DISP2, CMSG, 6+LIN, 4)

        IST = SMG$PUT_CHARS(DISP2, SLASH, 6+LIN, 66)

        CMSG = ' Digite numero da extracao ou <NEXT> para sair '
        IST = SMG$PUT_CHARS (DISP3, CMSG, 1,1)

        CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,YEAR,6+LIN,57,4,2000,2100,IST)

        CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,WEEK,6+LIN,68,2,1,53,IST)

        IEMIS = GETDRW(YEAR,WEEK,GNUM)

C       IST = SMG$ERASE_DISPLAY(DISP2)

	RETURN
	END
C**********************************************
C SUBROUTINE GET_FIRSTCDC
C**********************************************
C PROMPT USER FOR EMISSION NUMBER
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_FIRSTCDC(CDC,DISP2,DISP3,IKEYB,PB)
	IMPLICIT NONE

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C 
C LOCAL VARIABLES
C
	CHARACTER*55 CMSG

	INTEGER IKEYB,DISP2,DISP3,IST,PB

	INTEGER*4 CDC

	CDC = 0
	IST = SMG$SET_CURSOR_MODE(PB, SMG$M_CURSOR_OFF)

      	CMSG = ' CDC Inicial p/ esta Configuracao: '
      	IST = SMG$PUT_CHARS(DISP2, CMSG, 15, 4)

	CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,CDC,15,63,4,
     *			  DAYCDC-20,DAYCDC+2000,IST)
	RETURN
	END
C**********************************************
C SUBROUTINE GET_EMIS_RANGE
C**********************************************
C PROMPT USER FOR EMISSION RANGE
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_EMIS_RANGE(GNUM,IEMIS,ILSTEMIS,DISP2,DISP3,IKEYB,PB)
	IMPLICIT NONE

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C 
C LOCAL VARIABLES
C
	CHARACTER*55 CMSG

	INTEGER IKEYB,DISP2,DISP3,IST,PB

	INTEGER*4 IEMIS, ILSTEMIS, GNUM
	INTEGER*4 IWEK, LWEK, YEAR
	INTEGER*4 GETDRW            !FUNCTION

	IEMIS    = 0
	ILSTEMIS = 0
        IWEK     = 0
	LWEK     = 0
        YEAR     = 0

        IST = SMG$SET_CURSOR_MODE(PB, SMG$M_CURSOR_OFF)
        IST = SMG$ERASE_DISPLAY(DISP2)

        CMSG = ' Entre com extracao inicial: '    
        IST = SMG$PUT_CHARS(DISP2, CMSG, 6, 4)

        CMSG = ' / '    
        IST = SMG$PUT_CHARS(DISP2, CMSG, 6, 66)

        CMSG = ' Digite extracao ou <NEXT> para sair '
        IST = SMG$PUT_CHARS (DISP3, CMSG, 1,1)

        CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,YEAR,6,57,4,2000,2100,IST)

        CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,IWEK,6,68,2,1,53,IST)

        IEMIS = GETDRW(YEAR,IWEK,GNUM)

        CMSG = ' Entre com extracao final: '    
        IST = SMG$PUT_CHARS(DISP2, CMSG, 8, 4)

        CMSG = ' / '    
        IST = SMG$PUT_CHARS(DISP2, CMSG, 8, 66)

        CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,YEAR,8,57,4,2000,2100,IST)

        CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,LWEK,8,68,2,IWEK,53,IST)

        ILSTEMIS = GETDRW(YEAR,LWEK,GNUM)

	RETURN
	END

C**********************************************
C SUBROUTINE GET_NEW_TIME
C**********************************************
C PROMPT USER FOR EMISSION CLOSING TIME
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_NEW_TIME(NEWTIM,LIN,COL,DISP2,DISP3,IKEYB,PB,ST)
	IMPLICIT NONE

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C
C ROUTINE PARAMETERS
C
	INTEGER DISP2,DISP3,IKEYB,PB
	INTEGER*4 NEWTIM,ST,LIN,COL
C 
C LOCAL VARIABLES
C
	CHARACTER*78 CMSG

	INTEGER*4 AUXHR,AUXMIN

	ST     = 0
	AUXHR  = 0
	AUXMIN = 0

	CMSG = 
     *   ' Digite o horario de encerramento da extracao                 H     M'
	ST = SMG$PUT_CHARS (DISP2, CMSG, LIN, COL)
	CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,AUXHR,LIN,COL+57,2,0,23,ST)
	IF(ST.EQ.-2) RETURN

	CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,AUXMIN,LIN,COL+63,2,0,59,ST)
	IF(ST.EQ.-2) RETURN
	NEWTIM = AUXHR*60*60+AUXMIN*60	!TIME IN SECONDS

	RETURN
	END

C**********************************************
C SUBROUTINE MENU_CONFIRM
C**********************************************
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE MENU_CONFIRM(CMSG,LIN,COL,DISP2,IKEYB,PB,ST)
	IMPLICIT NONE

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C
C ROUTINE PARAMETERS
C
	CHARACTER*78 CMSG

	INTEGER DISP2,IKEYB,PB
	INTEGER*4 ST,LIN,COL
C 
C LOCAL VARIABLES
C
	CHARACTER*5 CONFIRM(2)/' SIM ', ' NAO '/
	CHARACTER*5 OPTION  /' SIM '/  

	INTEGER DISP4
	INTEGER*4 IOPT
C
C ASK FOR CONFIRMATION
C
	ST = SMG$PUT_CHARS (DISP2, CMSG, LIN, COL)
C
C CREATES YES/NO MENU DISPLAY - DISPCONF 
C
	ST = SMG$CREATE_VIRTUAL_DISPLAY(1, 15, DISP4)
	ST = SMG$CREATE_MENU(DISP4, CONFIRM,
     *				     SMG$K_HORIZONTAL,,, SMG$M_REVERSE)

	ST = SMG$PASTE_VIRTUAL_DISPLAY(DISP4, PB, LIN+4, COL+57)
	ST = SMG$SELECT_FROM_MENU(IKEYB, DISP4, IOPT, 2,
     *					  ,,,, OPTION, SMG$M_BOLD)
	ST = SMG$SET_CURSOR_MODE(PB, SMG$M_CURSOR_OFF)
	ST = SMG$UNPASTE_VIRTUAL_DISPLAY(DISP4, PB)
	ST = SMG$DELETE_VIRTUAL_DISPLAY (DISP4,PB)
	IF(IOPT.NE.1) THEN
	    ST = -1
	ELSE
	    ST = 0
	ENDIF

	RETURN
	END
C**********************************************
C SUBROUTINE GET_DAYWEEK
C**********************************************
C PROMPT USER FOR EMISSION CLOSING DATE/TIME
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE GET_DAYWEEK(DAYWEEK,CLSTIM,DISP2,DISP3,IKEYB,PB)
	IMPLICIT NONE

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C
C ROUTINE PARAMETERS
C
	INTEGER DISP2,DISP3,IKEYB,PB
	INTEGER*4 DAYWEEK(7),CLSTIM(7)
C 
C LOCAL VARIABLES
C
	CHARACTER*7 DAYNAME(7)/'Segunda','Terca  ','Quarta ','Quinta ',
     *			       'Sexta  ','Sabado ','Domingo'/
	CHARACTER*78 CMSG

	INTEGER*4 DAY,LIN,COL,ST

	DAY = 1
	LIN = 2
	COL = 5
	DO WHILE(DAY.LE.7)
	    WRITE(CMSG,100) DAYNAME(DAY)
	    CALL MENU_CONFIRM(CMSG,LIN,COL,DISP2,IKEYB,PB,ST)
	    IF(ST.EQ.0) THEN
		DAYWEEK(DAY) = 1
		CALL GET_NEW_TIME(CLSTIM(DAY),LIN+1,COL,DISP2,DISP3,IKEYB,PB,ST)
		LIN = LIN + 1
	    ENDIF

	    DAY = DAY + 1
	    LIN = LIN + 1
	ENDDO

	RETURN
100	FORMAT(A7,' e dia de extracao de Lotaria de Bilhetes ?')
	END


C**********************************************
C SUBROUTINE UPD_FILES
C**********************************************
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE UPD_FILES(GNUM,CDC,EMIS,DAYWEEK,CLSTIME,DISP3,KEYB,POSTPONE,
     *                       WEEKINI,YEARINI,WEEKFIM)
	IMPLICIT NONE

	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:RECDAF.DEF'
	INCLUDE 'INCLIB:DPAREC.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
        INCLUDE 'INCLIB:DATBUF.DEF'
	INCLUDE 'INCLIB:GTECHSMG.DEF'
C
C ROUTINE PARAMETERS
C
	INTEGER DISP3,KEYB
	INTEGER*4 CDC,EMIS,GNUM,DAYWEEK(7),CLSTIME(7),POSTPONE
	INTEGER*4 WEEKINI,YEARINI,WEEKFIM
C 
C LOCAL VARIABLES
C
	CHARACTER*78 CMSG

	INTEGER   KEY
	INTEGER*2 DATE(12)
	INTEGER*4 DAFUNIT,GAMUNIT,ST,DAFFDB(7),GAMFDB(7)
	INTEGER*4 GAMST,DAFST
	INTEGER*4 FSTCDC, FSTEMIS, AUXEMIS
C
C CLEAR SOME VARIABLES
C
	DAFST = 0
	GAMST = 0
C
C FIND AVAILABLE UNITS
C OPEN FILES
C
	FSTEMIS = EMIS
	FSTCDC  = CDC

	CALL FIND_AVAILABLE_LUN(GAMUNIT,ST)
	IF(ST.NE.0) THEN
	  WRITE (CMSG,40) GFNAMES(1,GNUM)
	  CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	  RETURN
	ENDIF

	CALL OPENW(GAMUNIT,GFNAMES(1,GNUM),4,0,0,ST)
	IF(ST.NE.0) THEN
	  WRITE (CMSG,50) GFNAMES(1,GNUM)
	  CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	  RETURN
	ENDIF

	CALL FIND_AVAILABLE_LUN(DAFUNIT,ST)
	IF(ST.NE.0) THEN
	  WRITE (CMSG,40) SFNAMES(1,DAF)
	  CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	  CALL CLOSEFIL(GAMFDB)
	  RETURN
	ENDIF

	CALL OPENW(DAFUNIT,SFNAMES(1,DAF),4,0,0,ST)
	IF(ST.NE.0) THEN
	  WRITE (CMSG,50) SFNAMES(1,DAF)
	  CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	ELSE
	  CALL IOINIT(DAFFDB,DAFUNIT,DAFSEC*256)
	  CALL IOINIT(GAMFDB,GAMUNIT,DPASEC*256)

C
C FIND LAST EMISSION ON GAME FILE
C
	  IF (POSTPONE.EQ.1) THEN
	    AUXEMIS = EMIS
	    ST      = 0
	    DO WHILE(ST.EQ.0)
		CALL READW(GAMFDB,(AUXEMIS-PAS_DRW_OFFSET),DPAREC,ST)
                IF(ST.NE.0.AND.ST.NE.144) THEN
                    WRITE (CMSG,80) EMIS,GAMST
                    CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
		    CALL CLOSEFIL(DAFFDB)
		    CALL CLOSEFIL(GAMFDB)
	            RETURN
                ELSEIF (ST.EQ.0) THEN
		    IF (DPADRAW.NE.0) THEN
                       AUXEMIS = AUXEMIS + 1
	               WEEKFIM = WEEKFIM + 1 
                    ELSE
		       EXIT
		    ENDIF
	        ENDIF
	    ENDDO
	    WEEKFIM = WEEKFIM - 1
	  ENDIF
C
C LOOP UPDATING DRAWS ON DAF
C
C	  DO WHILE(DAFST.NE.144)
	  DO WHILE(WEEKINI.LE.WEEKFIM.AND.DAFST.NE.144)
	    CALL READW(DAFFDB,CDC,DAFREC,DAFST)
	    IF(DAFST.NE.0 .AND. DAFST.NE.144) THEN
		WRITE (CMSG,60) CDC,DAFST
		CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
	    ELSE
		DAFDRW(GNUM) = EMIS
		DAFHDR(GNUM) = EMIS
		CALL WRITEW(DAFFDB,CDC,DAFREC,DAFST)
		IF(DAFST.NE.0 .AND. DAFST.NE.144) THEN
		    WRITE(CMSG,70) CDC,ST
		    CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
		ENDIF
	    ENDIF
C
C WE GOT AN ERROR AND OPERATOR ASKED
C TO ABORT...
C
	    IF(KEY.EQ.iNEXT_KEY) THEN
		CALL CLOSEFIL(DAFFDB)
		CALL CLOSEFIL(GAMFDB)
		RETURN
	    ENDIF

	    DATE(5) = CDC
	    CALL CDATE(DATE)
	    IF(DAYWEEK(DATE(VDOW)).EQ.1) THEN
		CALL READW(GAMFDB,(EMIS-PAS_DRW_OFFSET),DPAREC,GAMST)
		IF(GAMST.NE.0) THEN
		    WRITE (CMSG,80) EMIS,GAMST
		    CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
		ELSE
		    DPAEMIS = EMIS
		    DPATIM  = CLSTIME(DATE(VDOW))
		    IF (POSTPONE.EQ.0) DPADRAW = (WEEKINI*10000)+YEARINI

		    IF(.NOT.(POSTPONE.EQ.1 .AND. EMIS.EQ.FSTEMIS) ) 
     *		        DPABSD = FSTCDC
		    DPAESD    = CDC
		    FSTCDC    = DPAESD + 1
		    DPACHGCDC = DAYCDC
		    CALL WRITEW(GAMFDB,(EMIS-PAS_DRW_OFFSET),DPAREC,GAMST)
		    IF(GAMST.NE.0 .AND. GAMST.NE.144) THEN
			WRITE(CMSG,90) EMIS,GAMST
			CALL SMG_WERROR(CMSG,DISP3,KEYB,KEY)
		    ENDIF
		ENDIF
		WEEKINI = WEEKINI + 1
		EMIS = EMIS + 1
	    ENDIF

	    IF(KEY.EQ.iNEXT_KEY) THEN
		CALL CLOSEFIL(DAFFDB)
		CALL CLOSEFIL(GAMFDB)
		RETURN
	    ENDIF

	    CDC     = CDC + 1

	    IF(MOD(CDC,100).EQ.0) THEN
		WRITE(CMSG,100) CDC,EMIS
		ST = SMG$PUT_CHARS (DISP3, CMSG, 1,1)
	    ENDIF

	  ENDDO

	ENDIF
C
C CLOSE GAME FILE AND DAF FILE
C
	CALL CLOSEFIL(DAFFDB)
	CALL CLOSEFIL(GAMFDB)
	RETURN
C
C FORMAT STATEMENTS
C
40	FORMAT(' Nao ha handle para abertura do arquivo ',5A4,
     *	       ' Qualquer tecla p/ continuar')
50	FORMAT(' Erro de abertura no arquivo ',5A4,
     *	       ' Qualquer tecla p/ continuar')
60	FORMAT(' Erro de leitura, CDC ',I6,' status ',I4, 
     *	       ' Qualquer tecla p/continuar (next-fim)')
70	FORMAT(' Erro de escrita, CDC ',I6,' status ',I4,
     *	       ' Qualquer tecla p/continuar (next-fim)')
80	FORMAT(' Erro de leitura, extracao ',I6,' status ',I4, 
     *	       ' Qualquer tecla p/continuar')
90	FORMAT(' Erro de escrita, extracao ',I6,' status ',I4,
     *	       ' Qualquer tecla p/continuar')
100	FORMAT('Registro DAF:',I6,' Extracao P*F:',I6)
	END


C**********************************************
C SUBROUTINE GET_EMISNO
C**********************************************
C PROMPT USER FOR EMISSION NUMBER
C
C=======OPTIONS /CHECK=NOOVERFLOW
        SUBROUTINE GET_EMISNO(GNUM,CMSG,IEMIS,DISP2,DISP3,IKEYB,PB)
        IMPLICIT NONE

        INCLUDE 'INCLIB:GLOBAL.DEF'
        INCLUDE 'INCLIB:CONCOM.DEF'
        INCLUDE 'INCLIB:GTECHSMG.DEF'
C 
C LOCAL VARIABLES
C
        CHARACTER*78 CMSG

        INTEGER IKEYB,DISP2,DISP3,IST,PB

        INTEGER*4 IEMIS, GNUM

        IEMIS = 0
        IST = SMG$SET_CURSOR_MODE(PB, SMG$M_CURSOR_OFF)

        IST = SMG$PUT_CHARS(DISP2, CMSG, 14, 4)

        CALL SMG_INPNUM(PB,IKEYB,DISP2,DISP3,IEMIS,14,63,4,
     *                    DAYDRW(GNUM)-1,PAS_DRW_OFFSET+2001,IST)
        RETURN
        END

