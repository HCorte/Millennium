C     FILE   : PROC_BSAGTCTL.FOR
C     AUTHOR : J.H.R
C     VERSION: 01            DATE: 24 / 07 / 2001
C
C
C V02 FRP Modify for EM Joker (12-MAY-2009)
C V01 JHR INITIAL RELEASE FOR PORTUGAL PROJECT
C
C BETSLEEP AGENT CONTROL ( CONTROLO DO MIVIMENTO DOS AGENTES ) REPORT
C
C FILE WITH FUNCTIONS / SUBPROCEDURES TO CALCULATES HOW MANY BETSLEEPS 
C ( MATRICES ) ARE SPEND BY EVERY AGENT, AND GENERATES ONE REPORT TO SEND 
C IT TO EACH AGENT.
C
C     **************************************************************************
C
C        THIS ITEM IS THE PROPERTY OF GTECH CORPORATION, POVIDENCE, RHODE
C     ISLAND, AND CONTAINS CONFIDENTIAL AND TRADE SECRET INFORMATION. IT MAY
C     NOT BE TRANSFERRED FROM THE CUSTODY OR CONTROL OF GTECH EXCEPT AS AUTO -
C     RIZED IN WRITING BY AN OFFICER OF GTECH. NEITHER THIS ITEM NOR THE
C     INFORMATION IT CONTAINS MAY BE USED, TRANSFERRED, REPRODUCED, PUBLISHED
C     OR DISCLOSED, IN WHOLE OR IN PART, AND DIRECTLY OR INDIRECTLY, EXCEPT AS
C     EXPRESSLY AUTHORIZED BY AN OFFICER OR GTECH, PURSUANT TO WRITTEN AGREEMENT
C
C     Copyright 2000 GTECH Corporation. All Rigth Reserved
C
C     **************************************************************************
C
C THIS FILE CONTAINS FUNCTION / PROCEDURES FOR BSAGTCTL.EXE PROGRAM
C
C
C ******************************************************************************
C
C     SUBROUTINE: SET_DEFAULT_USER_OPTIONS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO SET DEFAULT USER OPTIONS ( FOR AUTHOMATICS RUNS )
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE SET_DEFAULT_USER_OPTIONS
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO SET DEFAULT USER OPTIONS
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:DATBUF.DEF'
C
C IF DAY STATUS IS NOT CLOSE AND WE DO A SUBRUN, IT'S AN ERROR
C
      IF(DAYSTS .NE. DSCLOS .AND. ISSUBPROC() .EQ. .TRUE.) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error, Subrun Mode Only Allowed In Stopsys Procedures'
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C SET DEFAULT REPORT CDC VALUE
C
      REPCDC = DAYCDC
C
C IF IS NOT RUN SUBPROCEDURE SET ALL USER OPTION TO FALSE AND EXIT
C
      IF(ISSUBPROC() .EQ. .FALSE.) THEN
        USRGENFIL = .FALSE.
        USRUPDONL = .FALSE.
        USRUPDOFF = .FALSE.
        USRGENRPT = .FALSE.
        USRCHKOVF = .TRUE.
        RETURN
      ENDIF
C
C SET DEFAULT USER OPTIONS ( GENERATE NEXT MATRIZ FILE ONLY ON SUNDAYS )
C
      USRGENFIL = .FALSE.
      IF(GET_WEEK_DAY(DAYCDC) .EQ. SUNDAY) USRGENFIL = .TRUE.
C
C SET DEFAULT USER OPTIONS ( UPDATE ON LINE INFORMATION ALL DAYS )
C
      USRUPDONL = .TRUE.
C
C SET DEFAULT USER OPTIONS ( UPDATE OFF LINE INFORMATION ONLY ON SATURDAYS )
C
C SCML - IT'S NOT NECESARY UPDATE VALUES WITH OFF LINE INFORMATION -
C
      USRUPDOFF = .FALSE.
C     IF(GET_WEEK_DAY(DAYCDC) .EQ. SATURDAY) USRUPDOFF = .TRUE.
C
C SET DEFAULT USER OPTIONS ( GENERATE REPORT ONLY ON SATURDAYS )
C
      USRGENRPT = .FALSE.
      IF(GET_WEEK_DAY(DAYCDC) .EQ. SATURDAY) USRGENRPT = .TRUE.
C
C SET DEFAULT USER OPTIONS ( CHECK OVERFLOW ERROR WHEN PRINTING THE REPORT )
C
      USRCHKOVF = .TRUE.
C
C THIS IS THE END TO SET DEFAULT USER OPTIONS
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_NEXT_SATURDAY_CDC
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT GETS NEXT SATURDAY CDC STARTING FROM IMPUT CDC
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_NEXT_SATURDAY_CDC(IMPCDC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET NEXT SATURDAY CDC
C
      INCLUDE 'INCLIB:DATBUF.DEF'
C
C FUNTIONS DEFINITION TO GET NEXT SATURDAY CDC
C
      INTEGER * 4 GET_WEEK_DAY     ! FUNCTION
C
C PARAMETERS DEFINITION TO GET NEXT SATURDAY CDC
C
      INTEGER * 4 IMPCDC           ! IMPUT CDC
C
C VARIABLES DEFINITION TO GET NEXT SATURDAY CDC
C
      INTEGER * 4 LOCAL_CDC        ! LOCAL WORK IMPUT CDC 
C
C INITIATE VARIABLES TO GET NEXT SATURDAY CDC
C
      LOCAL_CDC = IMPCDC
C
C LOOP TO GET NEXT SATURDAY CDC
C
      DOWHILE(.TRUE.)
        IF(GET_WEEK_DAY(LOCAL_CDC) .EQ. SATURDAY) THEN
          GET_NEXT_SATURDAY_CDC = LOCAL_CDC
          RETURN
        ENDIF
        LOCAL_CDC = LOCAL_CDC + 1
      ENDDO
C
C THIS IS THE END TO GET NEXT SATURDAY CDC
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_WEEK_DAY
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT GET WEEK DAY STARTING FROM CDC
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_WEEK_DAY(IMPCDC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET WEEK DAY STARTING FROM CDC
C
      INCLUDE 'INCLIB:DATBUF.DEF'
C
C PARAMETERS DEFINITION TO GET WEEK DAY STARTING FROM CDC
C
      INTEGER * 4 IMPCDC            ! IMPUT CDC
C
C VARIABLES DEFINITION TO GET WEEK DAY STARTING FROM CDC
C
      INTEGER * 2 DATE(12)          ! DATE ARRAY
C
C SET CDC DATE IN DATE ARRAY TO GET WEEK DAY
C
      DATE(VCDC) = IMPCDC
      CALL CDATE(DATE)
C
C SET WEEK DAY TO RETURN FUNCTION
C
      GET_WEEK_DAY = DATE(VDOW)
C
C THIS IS THE END TO GET WEEK DAY STARTING FROM CDC
C
      END


C ******************************************************************************
C
C     SUBROUTINE: DSP_TASK_PRESENTATION
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO DISPLAY USER PRESENTATION TASK 
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE DSP_TASK_PRESENTATION
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO DISPLAY USER PRESENTATION TASK
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C DISPLAY USER PRESENTATION ( AUTHOMATIC RUN PROGRAM )
C
      IF(ISSUBPROC() .EQ. .TRUE.) THEN
        CALL COPYRITE
        TYPE *, IAM()
        TYPE *, IAM(), 'Starting Movimento De Matrizes E Apostas Dos Agentes'
        TYPE *, IAM()
        RETURN
      ENDIF
C
C CLEAR SCREEN AND DISPLAY USER PRESENTATION ( MANUAL RUN PROGRAM )
C
      CALL CLRSCR(6)
      CALL COPYRITE
      TYPE *, IAM()
      TYPE *, IAM(), '* * * * * * * * * * * * * * * * * * * * * * * * * *'
      TYPE *, IAM(), '*   MOVIMENTO DE MATRIZES E APOSTAS DOS AGENTES   *'
      TYPE *, IAM(), '* * * * * * * * * * * * * * * * * * * * * * * * * *'
      TYPE *, IAM()
C
C THIS IS THE END TO DISPLAY USER PRESENTATION TASK
C
      END


C ******************************************************************************
C
C     SUBROUTINE: SET_YES_NO_MENU_VARS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO SET YES / NO ( 1, 2 ) MENU USER VARIABLES
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE SET_YES_NO_MENU_VARS(GENFIL, UPDONL, UPDOFF, GENRPT, CHKOVF)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO SET YES / NO MENU USER VARIABLES
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO SET YES / NO MENU USER VARIABLES
C
      INTEGER * 4 GENFIL               ! CREATE NEXT MATRIX FILE
      INTEGER * 4 UPDONL               ! UPDATE WITH ON LINE INFORMATION
      INTEGER * 4 UPDOFF               ! UPDATE WITH OFF LINE INFORMATION
      INTEGER * 4 GENRPT               ! NEGERATE REPORT
      INTEGER * 4 CHKOVF               ! CHECK OVERFLOW ERROR
C
C SET CREATE NEXT MATRIX AGENT FILE
C
      GENFIL = 1
      IF(USRGENFIL .EQ. .TRUE.) GENFIL = 2
C
C SET UPDATE MATRIX FILE WITH ON LINE INFORMATION
C
      UPDONL = 1
      IF(USRUPDONL .EQ. .TRUE.) UPDONL = 2
C
C SET UPDATE MATRIX FILE WITH OFF LINE INFORMATION
C
      UPDOFF = 1
      IF(USRUPDOFF .EQ. .TRUE.) UPDOFF = 2
C
C SET GENERATE MATRIX AGENT REPORT
C
      GENRPT = 1
      IF(USRGENRPT .EQ. .TRUE.) GENRPT = 2
C
C SET CHECK OVERFLOW ERROR WHEN IT IS GENERATING THE REPORT
C
      CHKOVF = 1
      IF(USRCHKOVF .EQ. .TRUE.) CHKOVF = 2
C
C THIS IS THE END TO SET YES / NO MENU USER VARIABLES
C
      END



C ******************************************************************************
C
C     SUBROUTINE: SET_MATRIX_CONF_FILE_NAME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION TO INITIATE MATRIX CONFIGURATION FILE NAME
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE SET_MATRIX_CONF_FILE_NAME
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO INITIATE MATRIX CONFIGURATION FILE NAME
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C VARIABLES DEFINITION TO INITIATE MATRIX CONFIGURATION FILE NAME
C
      INTEGER * 4 NXTSATCDCDATE          ! NEXT SATURDAY CDC DATE
C
      CHARACTER * 20 CHAR_FILE_NAME      ! FILE NAME IN CHAR FORMAT
C
C EQUIVALENCES DEFINITION TO SET REPORT FILE NAME
C
      EQUIVALENCE(CHAR_FILE_NAME, MTXFILNAME)
C
C IF USER DOES NOT WANT CREATE NEXT MATRIX AGENT FILE DO NOT SET THE NAME
C
      IF(USRGENFIL .EQ. .FALSE. .AND. 
     *   USRGENRPT .EQ. .FALSE. .AND.
     *   USRUPDONL .EQ. .FALSE. .AND.
     *   USRUPDOFF .EQ. .FALSE.) 
     * THEN
         WRITE(CHAR_FILE_NAME, 100)
         RETURN
       ENDIF
C
C GETS NEX SATURDAY CDC DATE
C
      NXTSATCDCDATE = GET_NEXT_SATURDAY_CDC(REPCDC)
C
C SET MATRIX AGENT FILE NAME
C
      WRITE(CHAR_FILE_NAME, 200) NXTSATCDCDATE
C
C FORMATS DEFINITION TO INITIATE MATRIX CONFIGURATION FILE NAME
C
100   FORMAT('-- Not Initiated -- ')
200   FORMAT('MTXAGTCTL', I4.4, '.FIL', 3(' '))
C
C THIS IS THE END TO INITIATE MATRIX CONFIGURATION FILE NAME
C
      END



C ******************************************************************************
C
C     SUBROUTINE: INIT_BSAGTCTL_PROGRAM_VARS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT INITIATE PROGRAM VARIABLES DEPENDING USER OPTION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE INIT_BSAGTCTL_PROGRAM_VARS
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO INITIATE PROGRAM VARIABLES
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C VARIABLES DEFINITION TO INITIATE PROGRAM VARIABLES
C
      INTEGER * 4 LNGUPDMTX        ! LENGHT OF UPDMTX VARIABLE
C
C INITATE MATRIX AGENT FILENAME ( WHEN WE ARE UPDATING INFORMATION )
C
      CALL SET_MATRIX_CONF_FILE_NAME
C
C INITIATE PROGRAM VARIABLES
C
      CALL FASTSET(0, AGTUPD, NUMAGT)
      LNGUPDMTX =  MAXTOT * MAXTIPW * MAXWEK * RPTMAXGAM * MAXWAG * NUMAGT
      CALL FASTSET(0, UPDMTX, LNGUPDMTX) 
C
C INITIATE WAGERS TABLE POSITION
C
      WAGTBLPOS(01) = 2
      WAGTBLPOS(02) = 3
      WAGTBLPOS(03) = 4
      WAGTBLPOS(04) = 6
      WAGTBLPOS(05) = 7
      WAGTBLPOS(06) = 8
      WAGTBLPOS(07) = 9
      WAGTBLPOS(08) = 10
      WAGTBLPOS(09) = 12
      WAGTBLPOS(10) = 16
      WAGTBLPOS(11) = 18
      WAGTBLPOS(12) = 24
      WAGTBLPOS(13) = 27
      WAGTBLPOS(14) = 28
      WAGTBLPOS(15) = 32
      WAGTBLPOS(16) = 36
      WAGTBLPOS(17) = 44
      WAGTBLPOS(18) = 48
      WAGTBLPOS(19) = 54
      WAGTBLPOS(20) = 64
      WAGTBLPOS(21) = 72
      WAGTBLPOS(22) = 81
      WAGTBLPOS(23) = 84
      WAGTBLPOS(24) = 96
      WAGTBLPOS(25) = 108
      WAGTBLPOS(26) = 128
      WAGTBLPOS(27) = 144
      WAGTBLPOS(28) = 162
      WAGTBLPOS(29) = 192
      WAGTBLPOS(30) = 210
      WAGTBLPOS(31) = 216
      WAGTBLPOS(32) = 243
      WAGTBLPOS(33) = 256
      WAGTBLPOS(34) = 288
      WAGTBLPOS(35) = 324
      WAGTBLPOS(36) = 384
      WAGTBLPOS(37) = 462
      WAGTBLPOS(38) = 924
      WAGTBLPOS(39) = 1
C
C INITIATE TOTAL NUMBER OF MATRIX USED BY ALL AGENTS
C
      CALL FASTSET(0, DTRTMTX, RPTMAXGAM)
      CALL FASTSET(0, TOTWEEKMTX, RPTMAXGAM)
C
C THIS IS THE END TO INITIATE PROGRAM VARIABLES
C
      END

C ******************************************************************************
C
C     SUBROUTINE: GET_USER_OPTIONS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO GET USER OPTIONS ( WHAT USER WANTS TO DO )
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GET_USER_OPTIONS
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET USER OPTIONS, WHAT USER WANTS TO DO
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C VARIABLES DEFINITION TO GET USER OPTIONS, WHAT USER WANTS TO DO
C
      INTEGER * 4 CNTA                           ! COUNTER A
      INTEGER * 4 GENFIL                         ! CREATE NEXT MATRIX FILE
      INTEGER * 4 UPDONL                         ! UPDATE WITH ON LINE INFO
      INTEGER * 4 UPDOFF                         ! UPDATE WITH OFF LINE INFO
      INTEGER * 4 GENRPT                         ! NEGERATE REPORT
      INTEGER * 4 CHKOVF                         ! CHECK OVERFLOW ERROR
      INTEGER * 4 USER_MENU_OPTION               ! USER SELECT FROM MENU
C
      CHARACTER * 3 NO_YES(2) / 'No ', 'Yes' /   ! YES / NO DISPLAY OPTIONS
C
C INITIATE PROGRAM VARIABLES VALUES DEPENDING OF USER SELECTION
C
1000   CONTINUE
       CALL INIT_BSAGTCTL_PROGRAM_VARS
C
C DISPLAY USER PRESENTION TASK
C
      CALL DSP_TASK_PRESENTATION
C
C SET LOCAL VARIABLES TO DISPLAY YES / NO IN MENU
C
      CALL SET_YES_NO_MENU_VARS(GENFIL, UPDONL, UPDOFF, GENRPT, CHKOVF)
C
C DISPLAY USER MENU, WHAT PROCEDURES CAN BE CANGED BY USER
C
      TYPE 100, IAM(), NO_YES(GENFIL), (MTXFILNAME(CNTA), CNTA = 1, 5)
      TYPE *, IAM()
      TYPE 200, IAM(), NO_YES(UPDONL)
      TYPE *, IAM()
      TYPE 300, IAM(), NO_YES(UPDOFF)
      TYPE *, IAM()
      TYPE 400, IAM(), NO_YES(GENRPT), REPCDC
      TYPE *, IAM()
      TYPE 500, IAM(), NO_YES(CHKOVF)
      TYPE *, IAM()
      TYPE 600, IAM()
      TYPE *, IAM()
      TYPE 700, IAM()
      TYPE *, IAM()
C
C GET USER SELECTION, WHAT USER HAS SELECTED
C
      CALL GET_MENU_SELECTED_OPTION(USER_MENU_OPTION)
C
C IF USER OPTION IS NOT EXECUTE PROCEDURES GO TO DISPLAY MENU AGAIN
C
      IF(USER_MENU_OPTION .NE. 6) GOTO 1000
C
C FORMATS DEFINITION TO GET USER OPTIONS, WHAT USER WANTS TO DO
C
100   FORMAT(X, A, '1.- Create Next Matrix File: ', A3, ' File: ', 5A4)
200   FORMAT(X, A, '2.- Update Matrix File With On Line Information: ', A3)
300   FORMAT(X, A, '3.- Update Matrix File With Off Line Information: ', A3)
400   FORMAT(X, A, '4.- Generate Matrix Report: ', A3, ' Cdc: ', I4.4)
500   FORMAT(X, A, '5.- Execute With No OverFlow Check: ', A3)
600   FORMAT(X, A, '6.- Execute Selected Options')
700   FORMAT(X, A, '7.- Exit')
C
C THIS IS THE END TO GET USER OPTIONS 
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_MENU_SELECTED_OPTION
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO GET MENU SELECTED AND SET PERTINENT ACTIONS
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GET_MENU_SELECTED_OPTION(USER_MENU_OPTION)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET MENU SELECTED AND SET PERTINENT ACTIONS
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITIONS TO GET MENU SELECTED AND SET PERTINENT ACTIONS
C
      INTEGER * 4 USER_MENU_OPTION        ! USER MENU OPTIONS
C
C VARIABLES DEFINITIONS TO GET MENU SELECTED AND SET PERTINENT ACTIONS
C
      INTEGER * 4 FSTS                    ! FUNCTION STSTAUS
C
C ASK TO USER TO ENTER MENU OPTION
C
      CALL INPNUM('Enter Option Number:', USER_MENU_OPTION, 1, 6, FSTS)
      TYPE *, IAM()
      IF(FSTS .LT. 0) CALL GSTOP(GEXIT_OPABORT)
C
C SET ACTION DEPENTDING OF USER SELECTION
C
      GOTO(1000, 2000, 3000, 4000, 5000, 6000) USER_MENU_OPTION
      RETURN
C
C SET ACTION ( CHANGE GENERATE NEXT MATRIX AGENT FILE STATUS )
C
1000  CONTINUE
      CALL OPTION_CHANGE_WITH_PASSWORD(USRGENFIL, USER_MENU_OPTION)
      RETURN
C
C SET ACTION ( CHANGE UPDATE ON LINE INFORMATION )
C
2000  CONTINUE
      CALL OPTION_CHANGE_WITH_PASSWORD(USRUPDONL, USER_MENU_OPTION)
      RETURN
C
C SET ACTION ( CHANGE UPDATE OFF LINE INFORMATION )
C
C SCML - IT'S NOT NECESARY UPDATE VALUES WITH OFF LINE INFORMATION -
C
3000  CONTINUE
      TYPE *, IAM()
      TYPE *, IAM(), 'SCML - It''s Not Necesary Update Off Line Information'
      TYPE *, IAM()
      CALL XWAIT(3, 2, FSTS)
C     CALL OPTION_CHANGE_WITH_PASSWORD(USRUPDOFF, USER_MENU_OPTION)
      RETURN
C
C SET ACTION ( CHANGE GENERATE REPORT )
C
4000  CONTINUE
      USRGENRPT = .NOT. USRGENRPT
      IF(USRGENRPT .EQ. .TRUE.) THEN
        CALL INPNUM('Enter Cdc To Generate Report:', REPCDC, 1, 9999, FSTS)
        IF(FSTS .LT. 0) THEN
          TYPE *, IAM()
          CALL GSTOP(GEXIT_OPABORT)
        ENDIF        
      ENDIF
      RETURN
C
C SET ACTION ( CHANGE CHECK OVERFLOW ERROR WHEN IT'S PRINTING THE REPORT )
C
5000  CONTINUE
      USRCHKOVF = .NOT. USRCHKOVF
      RETURN
C
C SET ACTION ( CONTINUE WITH SELECTED PROCEDURES )
C
6000  CONTINUE
      RETURN
C
C SET ACTION ( EXIT PROGRAM )
C
7000  CONTINUE
      CALL GSTOP(GEXIT_OPABORT)            
      RETURN
C
C THIS IS THE END TO GET MENU SELECTED AND SET PERTINENT ACTIONS
C
      END


C ******************************************************************************
C
C     SUBROUTINE: OPTION_CHANGE_WITH_PASSWORD
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO CHANGE USER SELECTION IF USER KNOW PASSWORD
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE OPTION_CHANGE_WITH_PASSWORD(VARTOCHG, USROPT)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO CHANGE USER SELECTION IF USER KNOW PASSWORD
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO CHANGE USER SELECTION IF USER KNOW PASSWORD
C
      INTEGER * 4 USROPT              ! USER MENU OPTION
C
      LOGICAL VARTOCHG                ! VARIABLE TO CHANGE VALUE 
C
C VARIABLES DEFINITION TO CHANGE USER SELECTION IF USER KNOW PASSWORD
C
      INTEGER * 4 FSTS                ! FUNCTION STATUS 
C
      CHARACTER * 09 ANSPSWD          ! PASSWORD THAT USER NEEDS ENTER
      CHARACTER * 20 USERPASWRD       ! PASSWORD THAT USER HAS ENTER
C
C IF USER WANTS TURN OFF VARIABLE HE/SHE DOES NOT NEED PASSWORD
C
      IF(VARTOCHG .EQ. .TRUE.) GOTO 1000
C
C DISPLAY MENSAGE WARNING TO USER
C
      CALL DSP_MESSAGE_WARNING(USROPT)
C
C FORMAT PASSWORD TO ASK TO USER
C
      WRITE(ANSPSWD, 100), USROPT
C
C ASK TO USER TO ENTER A PASSWOR
C
      CALL PASSWORD(20, USERPASWRD)
C
C IF USER DOES NOT KNOW THE PASSWORD RETURN, NOT ALLOWED CHANGES
C
      IF(USERPASWRD(1:9) .NE. ANSPSWD(1:9)) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Invalid Password Entered ...'
        TYPE *, IAM()
        CALL XWAIT(3, 2, FSTS)
        RETURN
      ENDIF
C
C IF USER KNOWS PASSWORD ALLOW CHANGES
C
1000  CONTINUE
      VARTOCHG = .NOT. VARTOCHG
C
C FORMATS DEFINITION TO CHANGE USER SELECTION IF USER KNOW PASSWORD
C
100   FORMAT('BSAGTCTL', I1.1)
C
C THIS IS THE END TO CHANGE USER SELECTION IF USER KNOW PASSWORD
C
      END


C ******************************************************************************
C
C     SUBROUTINE: DSP_MESSAGE_WARNING
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO DISPLAY MESSAGE WARNINGS TO THE USER
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE DSP_MESSAGE_WARNING(USROPT)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO DISPLAY MESSAGE WARNINGS
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERES DEFINITION TO DISPLAY MESSAGE WARNINGS
C
      INTEGER * 4 USROPT            ! USER MENU OPTION
C
C VARIABLES DEFINITION TO DISPLAY MESSAGE WARNINGS
C
      CHARACTER * 11 DAYOFWEEK      ! DAY OF WEEK WHEN RUNS OPTION IN STOPSYS
C
C DISPLAY PROGRAM PRESENTATION
C
      CALL DSP_TASK_PRESENTATION
C
C SET DAY OF WEEK WHEN IS RUNNING THIS OPTION IN STOPSYS
C
      DAYOFWEEK = 'On Saturday'
      IF(USROPT .EQ. 1) DAYOFWEEK = 'On Sunday  '
      IF(USROPT .EQ. 2) DAYOFWEEK = '           '
C
C DISPLAY MESSAGE WARNINGS
C
      TYPE *, IAM()
      TYPE *, IAM(), 'Warning !!!'
      TYPE *, IAM()
      TYPE *, IAM()
      TYPE *, IAM(), 'This Option Only Should Be Run One Time To Update'
      TYPE *, IAM(), 'Matrix Agent File And This Is Done In Normal Stopsys' 
      TYPE *, IAM(), 'Procedures ', DAYOFWEEK
      TYPE *, IAM()
      TYPE *, IAM(), 'So If You Wants Change This Option, You Have To Enter'
      TYPE *, IAM(), 'User Password ...'
      TYPE *, IAM()
C
C THIS IS THE END TO DISPLAY MESSAGE WARNING TO THE USER
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GENERATE_MATRIX_AGENT_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO GENERATE MATRIX AGENT FILE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GENERATE_MATRIX_AGENT_FILE
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GENERATE MATRIX AGENT FILE
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C VARIABLES DEFINITION TO GENERATE MATRIX AGENT FILE
C
      INTEGER * 4 FSTS             ! FUNCTION STATUS
      INTEGER * 4 CNTA             ! COUNTER A
C
C GENERATE MATRIX AGENT FILE
C
      CALL CRTFIL(MTXFILNAME, MFCSEC * NUMAGT, FSTS)
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE 100, IAM(), (MTXFILNAME(CNTA), CNTA = 1, 5)
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C FORMATS DEFINITION TO GENERATE MATRIX AGENT FILE
C
100   FORMAT(X, A, 'Unable To Create File: ', 5A4)
C
C THIS IS THE END TO GENERATE MATRIX AGENT FILE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_FREE_IDFIL
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET FREE IDENTIFICATION FILE NUMBER
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_FREE_IDFIL(CHECKIDFIL)
      IMPLICIT NONE
C
C INCLUDE DEFINITIONS TO GET FREE IDENTIFICATION FILE NUMBER
C
      INCLUDE '(LIB$ROUTINES)'
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO GET FREE IDENTIFICATION FILE NUMBER
C
      INTEGER * 4 CHECKIDFIL          ! CHECK IDFIL (0: NO, 1: YES )
C
C VARIABLES DEFINITION TO GET FREE IDENTIFICATION FILE NUMBER
C
      INTEGER * 4 FSTS                ! FUNCTION STATUS
      INTEGER * 4 IDFIL               ! IDENTIFICATION FILE
C
C GET FREE IDENTIFICATION FILE NUMBER
C
      FSTS = LIB$GET_LUN(IDFIL)
      IF(FSTS .EQ. 0 .OR. IDFIL .LE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Getting Identifiation File'
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C
C CHECK IDENTIFICATION FILE
C
      IF(CHECKIDFIL .NE. 0 .AND. IDFIL .GT. 100) IDFIL = MOD(IDFIL, 100)
C
C WRITE FREE IDENTIFICATION FILE TO RETURN FUNCTION
C
       GET_FREE_IDFIL = IDFIL
C
C THIS IS THE END TO GET FREE IDENTIFICATION FILE NUMBER
C
      END


C ******************************************************************************
C
C     SUBROUTINE: DELETE_FILE_NAME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO DELETE FILE THAT WE SET IN PARAMETER FUNCTION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE DELETE_FILE_NAME(FILENAME)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO DELETE FILE NAME
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO DELETE FILE NAME
C
      CHARACTER * (*) FILENAME            ! FILE NAME TO DELETE
C
C VARIABLES DEFINITION TO DELETE FILE NAME
C
      INTEGER * 4 FSTS                    ! FUNCTION STATUS
C
C IF FILENAME EXITS, DELETE IT
C
      CALL DFILX(FILENAME, 0, 0, FSTS)
      IF(FSTS. EQ. 4) FSTS = 0             ! IF FILE DON'T EXIST, NO PROBLEM
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Deleting File: ', FILENAME
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C THIS IS THE END TO DELETE FILE NAME
C
      END


C ******************************************************************************
C
C     SUBROUTINE: OPEN_FILE_NAME
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO OPEN FILE THAT WE SET IN PARAMETER FUNCTION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE OPEN_FILE_NAME(IDFIL, FILENAME, DELFILE)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO OPEN FILE NAME
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO OPEN FILE NAME
C
      INTEGER * 4 IDFIL                   ! IDENTIFICATION FILE
C
      CHARACTER * (*) FILENAME            ! FILE NAME TO OPEN
C
      LOGICAL DELFILE                     ! DELETE FILE ( YES / NO )
C
C VARIABLES DEFINITION TO OPEN FILE NAME
C
      INTEGER * 4 FSTS                    ! FUNCTION STATUS
C
C FUNCTIONS DEFINITION TO OPEN FILE NAME
C
      INTEGER * 4 GET_FREE_IDFIL          ! GET FREE IDENTIFICATION FILE NUMBER
C
C CHECK IF THE FILE TO BE OPEN SHOULD BE DELETED
C
      IF(DELFILE .EQ. .TRUE.) CALL DELETE_FILE_NAME(FILENAME)
C
C GET FREE IDENTIFICATION FILE NUMBER
C
      IDFIL = GET_FREE_IDFIL(0)
C
C OPEN FILE NAME ( NAME IT'S SET IN FUNCTION PARAMETER )
C
      OPEN(UNIT = IDFIL,
     *     FILE = FILENAME,
     *     IOSTAT = FSTS,
     *     FORM = 'FORMATTED',
     *     RECL = 2048,
     *     STATUS = 'NEW',
     *     RECORDTYPE = 'STREAM_CR')
C
C CHECK FOR OPEN FILE ERROR
C
      IF(FSTS .NE. 0)THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Opening File: ', FILENAME
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C THIS IS THE END TO OPEN FILE NAME
C
      END


C ******************************************************************************
C
C     SUBROUTINE: OPEN_SYS_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO OPEN SYSTEM FILE NAME
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE OPEN_SYS_FILE(SYSIDFIL, FILTYPE, FILE)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO OPEN SYSTEM FILE NAME
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:RECAGT.DEF'
C
C PARAMETERS DEFINITION TO OPEN SYSTEM FILE NAME
C
      INTEGER * 4 SYSIDFIL     ! SYSTEM IDENTIFICATION FILE
      INTEGER * 4 FILTYPE      ! FILE TYPE ( 1: MTMF01.FIL FILE, 2: GAME FILE )
      INTEGER * 4 FILE         ! FILE TO OPEN
C
C VARIABLES DEFINITION TO OPEN SYSTEM FILE NAME
C
      INTEGER * 4 FSTS         ! FUNCTION STATUS
      INTEGER * 4 CNTA         ! COUNTER A
      INTEGER * 4 FILENAME(5)  ! FILE NAME
C
C OPEN TRANSACTION FILE NAME TYPE
C
      IF(FILTYPE .EQ. MTMFIL) THEN
        CALL FASTMOV(SFNAMES(1, FILE), FILENAME, 5)
        CALL OPENWY(SYSIDFIL, FILENAME, 0, 4, 0, FSTS)
        CALL TOPEN(SYSIDFIL)
        GOTO 1000
      ENDIF
C
C OPEN AGENT SALES FILE AND MATRIX AGENT FILE
C
      IF(FILTYPE .EQ. ASFFIL) CALL FASTMOV(SFNAMES(1, FILE), FILENAME, 5)
      IF(FILTYPE .EQ. MTXFIL) CALL FASTMOV(MTXFILNAME, FILENAME, 5)
      CALL OPENW (SYSIDFIL, FILENAME, 4, 0, 0, FSTS) 
      IF(FILTYPE .EQ. ASFFIL) CALL IOINIT(ASFFDB, SYSIDFIL, ASFSEC * 256)
      IF(FILTYPE .EQ. MTXFIL) CALL IOINIT(MFCFDB, SYSIDFIL, MFCSEC * 256)
C
C CHECK IF FILE NAME OPEN ERROR
C
1000  CONTINUE
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE 100, IAM(), (FILENAME(CNTA), CNTA = 1, 5)
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C FORMATS DEFINITION TO OPEN SYSTEM FILE NAME
C
100   FORMAT(X, A, 'Error Opening File: ', 5A4)
C
C THIS IS THE END TO OPEN SYSTEM FILE NAME
C
      END
 

C ******************************************************************************
C
C     SUBROUTINE: CLOSE_ALL_SYSTEM_FILES
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO CLOSE ALL SYSTEM FILES USED BY PROGRAM
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE CLOSE_ALL_SYSTEM_FILES
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO CLOSE ALL SYSTEM FILES USED BY PROGRAM
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C CLOSE TRANSACTION MASTER FILE ( MTMF01.FIL )
C
      IF(USRUPDONL .EQ. .TRUE.) CALL USRCLOS1(MTMIDFIL)
C
C CLOSE OFF LINE FILE WITH MATRIX INFORMATION
C
      IF(USRUPDOFF .EQ. .TRUE.) CALL USRCLOS1(OFFIDFIL)
C
C CLOSE AGENT SALES FILE ( ASF.FIL )
C
      IF(USRUPDONL .EQ. .TRUE. .OR. USRUPDOFF .EQ. .TRUE.) THEN
        CALL CLOSEFIL(ASFFDB)
      ENDIF
C
C CLOSE MATRIX AGENT FILE ( MTXAGTCTLxxxx.FIL )
C
      IF(USRGENRPT .OR. USRUPDONL .OR. USRUPDOFF) THEN
        CALL CLOSEFIL(MFCFDB)
      ENDIF
C
C CLOSE ALL REPORTS FILES ( BETSLEEP AGENT CONTROL / SUMMARY / LABELS REPORTS )
C
      IF(USRGENRPT .EQ. .TRUE.) THEN
        CALL USRCLOS1(REPIDFIL)           ! BETSLEEP AGENT CONTROL REPOT
        CALL USRCLOS1(BSSIDFIL)           ! BETSLEEP SUMMARY REPORT
        CALL USRCLOS1(LBLIDFIL)           ! BETSLEEP SUMMARY LABEL REPORT
      ENDIF
C
C THIS IS THE END TO CLOSE ALL SYSTEM FILES USED BY PROGRAM
C
      END


C ******************************************************************************
C
C     SUBROUTINE: OPEN_ALL_SYSTEM_FILES
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 24 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO OPEN ALL SYSTEM FILES USED BY PROGRAM
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE OPEN_ALL_SYSTEM_FILES
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO OPEN ALL SYSTEM FILES USED BY PROGRAM
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C VARIABLES DEFINITION TO OPEN ALL SYSTEM FILES USED BY PROGRAM
C
      CHARACTER * 17 REPFILENAME      ! REPORT FILE NAME 
      CHARACTER * 17 OFFFILENAME      ! OFF LINE MATRIX FILE
      CHARACTER * 17 BSSFILENAME      ! BETSLEEP SUMMARY REPORT NAME
      CHARACTER * 17 BSLFILENAME      !  BETSLEEP SUMMARY LABELS REPORT NAME
C
C BEFORE OPEN ANY FILE CHECK IF MATRIX REPORT CAN BE GENERATE, IF CAN NOT BE
C GENERATE THIS ROUTINE WILL DO A FATAL ERROR AND FINISH THE PROGRAM
C
      CALL REPORT_CAN_BE_GENERATE
C
C SET REPORT FILE NAMES ( REPORTS FILES AND OFF LINE MATRIX FILE )
C
      WRITE(REPFILENAME, 100) REPCDC
      WRITE(OFFFILENAME, 200)
      WRITE(BSSFILENAME, 300) REPCDC
      WRITE(BSLFILENAME, 400) REPCDC
C
C OPEN TRANSACTION MASTER FILE ( MTMF01.FIL )
C
      IF(USRUPDONL .EQ. .TRUE.) THEN
        MTMIDFIL = GET_FREE_IDFIL(1)
        CALL OPEN_SYS_FILE(MTMIDFIL, MTMFIL, PTMF) 
      ENDIF
C
C OPEN OFF LINE FILE WITH MATRIX INFORMATION
C
      IF(USRUPDOFF .EQ. .TRUE.) THEN
        CALL OPEN_FILE_NAME(OFFIDFIL, OFFFILENAME, .FALSE.)
      ENDIF
C
C OPEN AGENT SALES FILE ( ASF.FIL )
C
      IF(USRUPDONL .EQ. .TRUE. .OR. USRUPDOFF .EQ. .TRUE.) THEN
        ASFIDFIL = GET_FREE_IDFIL(1)
        CALL OPEN_SYS_FILE(ASFIDFIL, ASFFIL, ASF)
      ENDIF
C
C OPEN MATRIX AGENT FILE ( MTXAGTCTLxxxx.FIL )
C
      IF(USRGENRPT .OR. USRUPDONL .OR. USRUPDOFF) THEN
        MTXIDFIL = GET_FREE_IDFIL(1)
        CALL OPEN_SYS_FILE(MTXIDFIL, MTXFIL, MTX)
      ENDIF
C
C OPEN ALL REPORTS FILES ( BETSLEEP AGENT CONTROL / SUMMARY / LABELS REPORTS )
C
      IF(USRGENRPT .EQ. .TRUE.) THEN
        CALL OPEN_FILE_NAME(REPIDFIL, REPFILENAME, .TRUE.)
        CALL OPEN_FILE_NAME(BSSIDFIL, BSSFILENAME, .TRUE.)
        CALL OPEN_FILE_NAME(LBLIDFIL, BSLFILENAME, .TRUE.)
      ENDIF

      WRITE(BSSFILENAME, 300) REPCDC
      WRITE(BSLFILENAME, 400) REPCDC

C
C FORMATS DEFINITION TO OPEN ALL SYSTEM FILES USED BY PROGRAM
C
100   FORMAT('MTXAGTCTL', I4.4, '.REP')
200   FORMAT('OFF_MATRIX.FIL')
300   FORMAT('MTXAGTSMR', I4.4, '.REP')
400   FORMAT('MTXAGTLBL', I4.4, '.REP')
C
C THIS IS THE END TO OPEN ALL SYSTEM FILES USED BY PROGRAM
C
      END


C ******************************************************************************
C
C     SUBROUTINE: REPORT_CAN_BE_GENERATE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 25 / 07 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO CHECK IF MATRIX REPORT CAN BE GENERATE, IF WEEK IS NOT FINISH
C AND WE TRY TO DO THE REPORT FOR THIS WEEK, THIS IS NOT ALLOWED BECAUSE
C WE HAVE NOT UPDATE ALL AGENT INFORMATION FOR THE WEEK
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE REPORT_CAN_BE_GENERATE
      IMPLICIT NONE
C
C INCLUDES DEFINITIONS TO CHECK IF MATRIX REPORT CAN BE GENERATE
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
C
C CALCULATE NEXT SATURDAY CDC, STARTING FROM REPORT CDC
C
      IF(GET_NEXT_SATURDAY_CDC(REPCDC) .GT. DAYCDC .AND. USRGENRPT) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error, Report Can Not Be Generate Because'
        TYPE *, IAM(), 'Is Not Update All Week Information'
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)        
      ENDIF
C
C THIS IS THE END TO CHECK IF MATRIX REPORT CAN BE GENERATE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: SEAR_WAGER_INDEX_POSITION
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 25 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT RETURN INDEX POSITION TO SAVE WAGER IN MEMORY, STARTING FROM
C NUMBER OF WAGERS
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE SEARCH_WAGER_INDEX_POSITION(NUMWAG, IDXPOS)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO SEARCH INDEX POSITION IN WAGER TABLE
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO SEARCH INDEX POSITION IN WAGER TABLE
C
      INTEGER * 4 NUMWAG          ! NUMBER OF WAGERS
      INTEGER * 4 IDXPOS          ! INDEX POSITION
C
C VARIABLES DEFINITION TO SEARCH INDEX POSITION IN WAGER TABLE
C
      INTEGER * 4 POS             ! INDEX POSITION IN THE TABLE
C
C LOOP TO SEARCH INDEX POSITION IN WAGER TABLE
C
      DO POS = 1, MAXWAG
        IF(WAGTBLPOS(POS) .EQ. NUMWAG) THEN
          IDXPOS = POS
          RETURN
        ENDIF
      ENDDO
C
C NUMBER OF WAGERS NOT FOUND IN TABLE, SO RETURN ERROR
C
      IDXPOS = -1
C
C THIS IS THE END TO SEARCH INDEX POSITION IN WAGER TABLE
C
      END



C ******************************************************************************
C
C     SUBROUTINE: READ_MATRIX_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 26 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT READ ONE TERMINAL RECORD FROM MATRIX FILE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE READ_MATRIX_FILE(TERM, MTXREC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO READ MATRIX FILE
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO READ MATRIX FILE
C
      INTEGER * 4 TERM         ! TERMINAL RECORD TO READ
      INTEGER * 4 MTXREC(*)    ! RECORD WHEN WE PUT READED INFORMATION
C
C VARIABLES DEFINITION TO READ MATRIX FILE
C
      INTEGER * 4 FSTS         ! FUNCTION STATUS
C
C READ ONE RECORD FROM MATRIX FILE
C
      CALL READW(MFCFDB, TERM, MTXREC, FSTS)
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Reading Matrix Agent File ...'
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C THIS IS THE END TO READ MATRIX FILE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_DATE_FROM_CDC
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 26 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT GET DAY, MONTH, YEAR STARTING FORM CDC
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GET_DATE_FROM_CDC(IMPCDC, DAY, MONTH, YEAR)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET DAY, MONTH, YEAR STARTING FORM CDC 
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:DATBUF.DEF'
C
C PARAMETERS DEFINITION TO GET DAY, MONTH, YEAR STARTING FORM CDC
C
      INTEGER * 4 IMPCDC      ! CDC IMPUT VALUE
      INTEGER * 4 DAY         ! DAY OUTPUT
      INTEGER * 4 MONTH       ! MONTH OUTPUT
      INTEGER * 4 YEAR        ! YEAR OUTPUT
C
C VARIABLES DEFINITION TO TRANSFORM CDC VALUE
C
      INTEGER * 2 DATES(12)            ! DATES ARRAY
C
C TRANSFORM CDC VALUE IN DAY, MONTH, YEAR
C
      DATES(VCDC) = IMPCDC
      CALL CDATE(DATES)
C
C SET OUTPUT INFORMATION
C
      DAY = DATES(VDAY)
      MONTH = DATES(VMON)
      IF(DATES(VYEAR) .GT. 77) THEN
        YEAR = DATES(VYEAR) + 1900
      ELSE
        YEAR = DATES(VYEAR) + 2000
      ENDIF
C
C THIS IS THE END TO GET DAY, MONTH, YEAR STARTING FORM CDC
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_PRINT_LOTO_QUARE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 26 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT FORMAT PRINTED SQUARE IN THE REPORT
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GET_PRINT_LOTO_SQUARE(LINPOS, LTOSQUARE)
      IMPLICIT NONE
C
C PARAMETERS DEFINITION TO GET PRINTED SQUARE IN THE REPORT
C
      INTEGER * 4 LINPOS          ! LINE POSITION TO PRINT
C
      CHARACTER * 26 LTOSQUARE    ! VARIABLEN WHEN WE PUT FORMATED SQUARE
C
C VARIABLES DEFINITION TO GET PRINTED SQUARE IN THE REPORT
C
      INTEGER * 4 IDXPOS          ! INDEX POSITION IN THE TABLE
      INTEGER * 4 WAGTBL(7)       ! WAGERS TABLE
C
      CHARACTER * 4 SYSWAGTBL(7)  ! SYSTEM WAGERS TABLE DRAWING
C
C INITIATE TABLES
C
      DATA SYSWAGTBL / ' (7)', ' (8)', ' (9)', 
     *                 '(10)', '(11)', '(12)', ' (5)'   /
C
      DATA WAGTBL / 7, 28, 84, 210, 462, 924, 44 /
C
C CHECK IF WE HAVE TO PRINT SOMETHING
C
      IF(LINPOS .LT. 6 .OR. LINPOS .GT. 17) THEN
        WRITE(LTOSQUARE, 100)
        RETURN
      ENDIF
C
C FORMAT '* ... *' LINES
C
      IF(LINPOS .EQ. 6 .OR. LINPOS .EQ. 17) THEN
        WRITE(LTOSQUARE, 101)
        RETURN
      ENDIF
C
C FORMAT '*   *' LINES
C
      IF(LINPOS .EQ. 7) THEN
        WRITE(LTOSQUARE, 102)
        RETURN
      ENDIF
C
C FORMAT 'E N L O T O' LINES
C
      IF(LINPOS .EQ. 8) THEN
        WRITE(LTOSQUARE, 103)
        RETURN
      ENDIF
C
C FORMAT ' --- ' LINES
C
      IF(LINPOS .EQ. 9) THEN
        WRITE(LTOSQUARE, 104)
        RETURN
      ENDIF
C
C FORMAT INFORMATION LINES
C
      IDXPOS = LINPOS - 9
      WRITE(LTOSQUARE, 105) SYSWAGTBL(IDXPOS), WAGTBL(IDXPOS)
      RETURN
C
C FORMATS DEFINITION TO GET PRINTED SQUARE IN THE REPORT
C
100   FORMAT(26(' '))
101   FORMAT(26('*'))
102   FORMAT('*', 24X, '*')
103   FORMAT('*', 6X, 'E M  L O T O', 6X, '*')
104   FORMAT('*', 4X, 16('-'), 4X, '*')
105   FORMAT('*', X, A, X, 'SAO', 2X, I3, 2X, 'APOSTAS', X, '*')
C
C THIS IS THE END TO GET PRINTED SQUARE IN THE REPORT
C
      END


C ******************************************************************************
C
C     SUBROUTINE: ADD_TOTALS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 26 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT ADD TO ADDTOVAR VARIABLE VALUE FROM ADDFROMVAR VARIABLE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE ADD_TOTALS(VARTOADD, ADDFROMVAR, POS, WEEK, GAM, WAG, JOKUPD)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO TO ADD ONE VARIABLE TO ANOTHER ONE
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO ADD ONE VARIABLE TO ANOTHER ONE
C
      INTEGER * 4 VARTOADD(MAXTOT, MAXWEK, RPTMAXGAM)           ! WHEN ADD
      INTEGER * 4 ADDFROMVAR(MAXTOT, MAXWEK, RPTMAXGAM, MAXWAG) ! FROM WE ADD
C
      INTEGER * 4 POS        ! WHERE / FROM WE HAVE TO ADD ( COUNTER / TOTAL )
      INTEGER * 4 WEEK       ! WHERE / FROM WE HAVE TO ADD ( WEEK POSITION )
      INTEGER * 4 GAM        ! WHERE / FROM WE HAVE TO ADD ( GAME POSITION )
      INTEGER * 4 WAG        ! FROM WE HAVE TO ADD ( WAGER POSITION )
      INTEGER * 4 JOKUPD     ! JOKER UPDATE INFORMATION ( YES / NO )
C
C VARIABLES DEFINITION TO ADD ONE VARIABLE TO ANOTHER ONE
C
      INTEGER * 4 ADDED      ! VALUE ADDED TO OUTPUT VARIABLE
C
C GET VALUE FROM TO ADD TO ADDTOVAR VARIABLE
C
      ADDED = ADDFROMVAR(POS, WEEK, GAM, WAG)
C
C ADD VALUE TO OUTPUT VARIABLE
C
      VARTOADD(POS, WEEK, GAM) = VARTOADD(POS, WEEK, GAM) + ADDED
C
C CHECK IF WE HAVE TO UPDATE JOKER OR NOT
C
      IF(JOKUPD .NE. 0) RETURN
C
C GET VALUE FROM TO ADD TO ADDTOVAR VARIABLE ( FOR JOKER GAME )
C
      ADDED = ADDFROMVAR(TOTJOK, WEEK, GAM, WAG)
C
C ADD VALUE TO OUTPUT VARIABLE ( FOR JOKER GAME )
C
      VARTOADD(TOTJOK, WEEK, GAM) = VARTOADD(TOTJOK, WEEK, GAM) + ADDED
C
C THIS IS THE END TO ADD ONE VARIABLE TO ANOTHER ONE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: PRINT_EURO_VALUE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 26 / 07 / 2001
C
C ******************************************************************************
C
C FUNCTION TO PRINT FORMATED ESCUDOS OR EUROS AMOUNT. IF CURRENCY IT IS ESCUDOS
C GET EUROS AMOUNT AND GET CORRESPONDIENT AMOUNT IN ESCUDOS
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      CHARACTER * 12 FUNCTION PRINT_EURO_VALUE(EURAMT, CURRENCY)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO PRINT FORMATED ESCUDOS OR EUROS AMOUNT
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
C
C PARAMETERS DEFINITION TO PRINT FORMATED ESCUDOS OR EUROS AMOUNT
C
      INTEGER * 4 EURAMT           ! EURO AMOUNT VALUE TO CONVERT
      INTEGER * 4 CURRENCY         ! CURRENT CURRENCY
C
C VARIABLES DEFINITION TO PRINT FORMATED ESCUDOS OR EUROS AMOUNT
C
      INTEGER * 4 CNT              ! COUNTER
      INTEGER * 4 EUROS            ! EUROS WORK WITH LOCAL VARIABLE 
      INTEGER * 4 EURINT           ! EUROS VALUE INTEGER PART
      INTEGER * 4 EURDEC           ! EUROS VALUE DECIMAL PART
      INTEGER * 4 GRP3D1           ! GORUP OF THREE DIGITS 1
      INTEGER * 4 GRP3D2           ! GORUP OF THREE DIGITS 2
      INTEGER * 4 GRP3D3           ! GORUP OF THREE DIGITS 3
C
      REAL * 8 EURCONV             ! EURO CONVERSION
C
      LOGICAL NEGATIVE             ! SET IF INPUT VALUE IS NEGATIVE OR NOT
C
      CHARACTER * 12 OUTEUR        ! OUTPUT EROS FORMATED
C
C INITIATE VARIABLES TO PRINT FORMATED ESCUDOS OR EUROS AMOUNT
C
      EUROS = EURAMT
      NEGATIVE = .FALSE.
C
C SET IF INPUT VALUE IS NEGATIVE OR NOT
C
      IF(EURAMT .LT. 0) THEN
        NEGATIVE = .TRUE.
        EUROS = -EUROS         
      ENDIF
C
C SET DECIMAL AND NOT DECIMAL PART FOR EUROS
C
      IF(CURRENCY .EQ. EUR) THEN
        EURDEC = MOD(EUROS, P(PRFACTOR))
        EURINT = EUROS / P(PRFACTOR)
      ENDIF
C
C SET DECIMAL AND NOT DECIMAL PART FOR ESCUDOS
C 
      IF(CURRENCY .EQ. ESC) THEN
        EURCONV = DFLOAT(EUROS) / DFLOAT(P(PRFACTOR))
        EURINT = IDNINT(EURCONV * DFLOAT(P(EUROCR)) / 1000.00D0) 
        EURDEC = 0
      ENDIF
C
C CALCULATE GROUPS OF 3 DIGITIS TO PRINT FORMATED OUTPUT
C
      GRP3D1 = EURINT / 1000000
      GRP3D2 = EURINT / 1000 - (GRP3D1 * 1000)
      GRP3D3 = EURINT - ((EURINT / 1000) * 1000)
C
C FORMAT ESCUDOS / EUROS VALUE OUTPUT
C
      IF(CURRENCY .EQ. ESC) WRITE(OUTEUR, 100) GRP3D1, GRP3D2, GRP3D3
      IF(CURRENCY .EQ. EUR) WRITE(OUTEUR, 200) GRP3D1, GRP3D2, GRP3D3, EURDEC
C
C REMOVE NOT IMPORTANT INFORMATION ( STARTED ZEROS )
C
      CNT = 1
      DOWHILE(OUTEUR(CNT:CNT) .LT. '1' .OR. OUTEUR(CNT:CNT) .GT.'9')
        IF(CNT .GT. 08 .AND. CURRENCY .EQ. EUR) GOTO 1000
        IF(CNT .GT. 11 .AND. CURRENCY .EQ. ESC) GOTO 1000
        OUTEUR(CNT:CNT) = ' '
        CNT = CNT + 1
      ENDDO
C
C SET NEGATIVE VALUES IF INPUT EURO AMOUNT IS NEGATIVE
C
1000  CONTINUE
      IF(CNT .GT. 1 .AND. NEGATIVE .EQ. .TRUE.) THEN
        OUTEUR(CNT - 1:CNT - 1) = '-'
      ENDIF 
C
C SET OUTPUT FORMATED VALUES
C
      PRINT_EURO_VALUE = OUTEUR
C
C FORMATS DEFINITION TO PRINT FORMATED ESCUDOS OR EUROS AMOUNT
C
100   FORMAT(' ', I3.3, '.', I3.3, '.', I3.3)
200   FORMAT(I1.1, '.', I3.3, '.', I3.3, ',', I2.2)
C
C THIS IS THE END TO PRINT FORMATED ESCUDOS OR EUROS AMOUNT
C
      END



C ******************************************************************************
C
C     SUBROUTINE: INIT_FORMATED_SUMMARY_LABEL_REGISTERS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 14 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO INITIATE FORMATED SUMMARY / LABEL INFORMATION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE INIT_FORMATED_SUMMARY_LABEL_REG(INITSMR, INITLBL)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO INITIATE FORMATED SUMMARY / LABEL INFORMATION
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO INITIATE FORMATED SUMMARY / LABEL INFORMATION
C
      INTEGER * 4 INITSMR           ! INITIATE SUMMARY VARIABLE
      INTEGER * 4 INITLBL           ! INITIATE SUMMARY LABEL VARIABLE
C
C VARIABLES DEFINITION TO INITIATE FORMATED SUMMARY / LABEL INFORMATION
C
      INTEGER * 4 COLUMN            ! COLUMN COUNTER 
      INTEGER * 4 LINE              ! LINE COUNTER
C
C CHECK IF SUMMARY VARIABLE SHOULD BE INITIATE
C
      IF(INITSMR .EQ. 0) WRITE(FMTSMRINF, 100)
C
C CHECK IF SUMMARY LABEL VARIABLE SHOULD BE INITIATE, IF NOT EXIT
C
      IF(INITLBL .NE. 0) RETURN
C
C INITIATE SUMMARY LABEL VARIABLE WITH BLANK SPACES
C
      DO COLUMN = 1, 3
        DO LINE = 1, 9
          WRITE(FMTLBLINF(COLUMN, LINE), 200)
        ENDDO
      ENDDO
C
C FORMATS DEFINITION TO INITIATE FORMATED SUMMARY / LABEL INFORMATION
C
100   FORMAT(70(' '))
200   FORMAT(35(' '))
C
C THIS IS THE END TO INITIATE FORMATED SUMMARY / LABEL INFORMATION
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_FORMATED_DATE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 19 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET DATE IN XX/XX/XX FORMAT
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      CHARACTER * 8 FUNCTION GET_FORMATED_DATE(DATECDC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET FORMATED DATE
C
      INCLUDE 'INCLIB:DATBUF.DEF'
C
C PARAMETERS DEFINITION TO GET FORMATED DATE
C
      INTEGER * 4 DATECDC      ! DATE IN CDC FORMAT
C
C VARIABLES DEFINITION TO GET FORMATED DATE
C
      INTEGER * 2 VDAT(LDATE_LEN)
C
C GET DAY, MONTH, YEAR
C
      VDAT(VCDC) = DATECDC
      CALL LCDATE(VDAT)
C
C SET FORMATED DATE IN OUTPUT FUNCTION
C
      WRITE(GET_FORMATED_DATE, 100) VDAT(VDAY), VDAT(VMON), VDAT(VYEAR)
C
C FORMATS DEFINITION TO GET FORMATED DATE
C
100   FORMAT(I2.2, '/', I2.2, '/', I2.2)
C
C THIS IS THE END TO GET FORMATED DATE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: PRINT_SUMMARY_HEADER
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 19 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO PRINT HEADER INFORMATION IN "MAPA RESUMO DAS MATRIZES" FILE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE PRINT_SUMMARY_HEADER(PAGE, CNTLINE, AGTDSTLIN)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO PRINT HEADER INFORMATION
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO PRINT HEADER INFORMATION
C
      INTEGER * 4 PAGE           ! PAGE COUNTER
      INTEGER * 4 CNTLINE        ! REPORT LINE COUNTER
      INTEGER * 4 AGTDSTLIN      ! AGENT DISTRIBUTION LINE
C
C CHECK IF WE HAVE TO PRINT INFORMATION OR NOT
C
      IF(CNTLINE .NE. 0) RETURN
C
C PRINT "DEPARTAMENTO DE JOGOS VALUE" IN THE REPORT
C
      WRITE(BSSIDFIL, 100)
      WRITE(BSSIDFIL, 200)
      WRITE(BSSIDFIL, 300)
      WRITE(BSSIDFIL, 400), PAGE
      WRITE(BSSIDFIL, 200)
C
C WRITE REPORT DAY AND DISTRIBUTION LINE IN THE HEADER
C
      WRITE(BSSIDFIL, 500) GET_FORMATED_DATE(REPCDC), AGTDSTLIN
      WRITE(BSSIDFIL, 200)
      WRITE(BSSIDFIL, 600)
      WRITE(BSSIDFIL, 700)    
C
C INITIATE COUNTER LINE TO APROPIATE VALUE
C
      CNTLINE = 9
C
C INCREASE PAGE COUNTER TO NEXT TIME WE HAVE TO PRINT NEW PAGE
C
      PAGE = PAGE + 1
C
C FORMATS DEFINITON TO PRINT HEADER INFORMATION
C
100   FORMAT('1')
200   FORMAT(X)
300   FORMAT(X, 'SCML - DEPARTAMENTO DE JOGOS')
400   FORMAT(X, 4X, 'TOTOBOLA - TOTOGOLO', 48X, 'PAG. ', I2.2)
500   FORMAT(X, 7X, 'EM ', A8, 
     *       ' - MAPA RESUMO DAS MATRIZES A DISTRIBUIR NO CENTRO N. ', I2.2)
600   FORMAT(X, 5X, 3(2X, 'MEDIADOR TOTO', 3X, 'GOLO', X))
700   FORMAT(X, 5X, 70('-'))
C
C THIS IS THE END TO PRINT HEADER INFORMATION
C
      END


C ******************************************************************************
C
C     SUBROUTINE: PRINT_SMRY_LINE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 19 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO PRINT ONE SUMMARY REPORT LINE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE PRINT_SMRY_LINE(CNTFMT, CNTLINE, LSTAGTLD, AGTLD, PRNTINFO)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO PRINT ONE SUMMARY REPORT LINE
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO PRINT ONE SUMMARY REPORT LINE
C
      INTEGER * 4 CNTFMT         ! SUMMARY FORMATED INFORMATION COUNTER
      INTEGER * 4 CNTLINE        ! LINE COUNTER
      INTEGER * 4 LSTAGTLD       ! LAST AGENT DISTRIBUTION LINE
      INTEGER * 4 AGTLD          ! AGENT DISTRIBUTION LINE
C
      LOGICAL PRNTINFO           ! PRINT INFORMATION ( YES / NO )
C
C CONSTANT VARIABLES TO PRINT ONE SUMMARY REPORT LINE
C
      INTEGER * 4 MAXSMRFMTINF          ! MAXIMUM SUMMARY FORMATED INFORMATION
C
C INTITIATE CONSTANT VARIABLES TO PRINT ONE SUMMARY REPORT LINE
C
      PARAMETER(MAXSMRFMTINF = 3)       ! MAXIMUM SUMMARY FORMATED INFORMATION
C
C CHECK IF SUMMARY INFORMATION SHOULD BE PRINTED OR NOT
C
      IF(PRNTINFO .EQ. .FALSE. .AND. CNTFMT .NE. MAXSMRFMTINF) THEN
        IF(LSTAGTLD .EQ. AGTLD) RETURN
      ENDIF
C
C WRITE ONE LINE INFORMATION IN SUMMARY AGENT REPORT
C
      WRITE(BSSIDFIL, 100) FMTSMRINF
C
C RESET TO ZERO  FORMATED INFORMATION COUNTER
C
      CNTFMT = 0
C
C INCREASE LINE COUNTER AND CHECK IF FUNCTION HAS TO START A NEW PAGE
C
      CNTLINE = CNTLINE + 1
      IF(CNTLINE .GT. 62) CNTLINE = 0
C
C FORMAT DEFINITION TO PRINT ONE SUMMARY REPORT LINE
C
100   FORMAT(X, 5X, A)
C
C THIS IS THE END TO PRINT ONE SUMMARY REPORT LINE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: PRINT_SMRY_LABEL_LINE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 19 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO PRINT ONE SUMMARY LABEL REPORT LINE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE PRINT_SMRY_LABEL_LINE(CNTLBLFMTINF, PRNTINFO)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO PRINT ONE SUMMARY LABEL REPORT LINE
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITON TO PRINT ONE SUMMARY LABEL REPORT LINE
C
      INTEGER * 4 CNTLBLFMTINF   ! SUMMARY LABEL FORMATED INFO COUNTER
C
      LOGICAL PRNTINFO                  ! PRINT INFORMATION ( YES / NO )
C
C CONSTANT VARIABLES TO PRINT ONE SUMMARY LABEL REPORT LINE
C
      INTEGER * 4 MAXLBLFMTINF          ! MAXIMUM SUMMARY LABEL FORMATED INFO
C
C INTITIATE CONSTANT VARIABLES TO PPRINT ONE SUMMARY LABEL REPORT LINE
C
      PARAMETER(MAXLBLFMTINF = 3)       ! MAXIMUM SUMMARY LABEL FORMATED INFO
C
C VARIABLES DEFINITION TO PRINT ONE SUMMARY LABEL REPORT LINE
C
      INTEGER * 4 LINCNT         ! LINE COUNTER ( TO PRINT INFORMATION )
C
C CHECK IF LABEL INFORMATION SHOULD BE PRINTED OR NOT
C
      IF(PRNTINFO .EQ. .FALSE. .AND. CNTLBLFMTINF .NE. MAXLBLFMTINF) RETURN
C
C WRITE ONE LINE INFORMATION IN SUMMARY LABEL AGENT REPORT
C
      DO LINCNT = 1, 9
        WRITE(LBLIDFIL, 100) FMTLBLINF(1, LINCNT),
     *                       FMTLBLINF(2, LINCNT),
     *                       FMTLBLINF(3, LINCNT)
      ENDDO
C
C RESET TO ZERO  FORMATED INFORMATION COUNTER
C
      CNTLBLFMTINF = 0
C
C FORMATS DEFINITION TO PRINT ONE SUMMARY LABEL REPORT LINE
C
100   FORMAT(X, A, 6X, A, 6X, A)
C
C THIS IS THE END TO PRINT ONE SUMMARY LABEL REPORT LINE
C
      END



C ******************************************************************************
C
C     SUBROUTINE: FORMAT_SUMMARY_INFO
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 19 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO FORMAT IN AGENT SUMMARY REPORT ONE AGENT INFORMATION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE FORMAT_SUMMARY_INFO(MTXREC, CNTSMRFMTINF, TOTGOLO, TOTBOLO)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO FORMAT IN AGENT SUMMARY REPORT ONE AGENT INFORMATION
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO FORMAT IN AGENT SUMMARY REPORT ONE AGENT INFORMATION
C
      INTEGER * 4 MTXREC(*)      ! MATRIX REGISTER
      INTEGER * 4 CNTSMRFMTINF   ! FORMATED SUMMARY INFORMATION COUNTER
      INTEGER * 4 TOTGOLO        ! TOTAL TOTOGOLO GAME
      INTEGER * 4 TOTBOLO        ! TOTAL TOTOBOLA GAME
C
C VARIABLES DEFINITION TO FORMAT IN AGENT SUMMARY REPORT ONE AGENT INFORMATION
C
      INTEGER * 4 POS            ! POSITION
      INTEGER * 4 LKTOTGOLO      ! LOCAL OTAL TOTOGOLO GAME
      INTEGER * 4 LKTOTBOLO      ! LOCAL TOTAL TOTOBOLA GAME
C
C FUNCTIONS DEFINITION TO FORMAT IN AGENT SUMMARY REPORT ONE AGENT INFORMATION
C
      INTEGER * 4 GET_TOTAL_MATRIX_TOTO    ! FUNCTION TO GET TOTAL MATRIX TOTO
      INTEGER * 4 GET_TOTAL_MATRIX_GOLO    ! FUNCTION TO GET TOTAL MATRIX GOLO
      INTEGER * 4 ROUND_TO_PACKET          ! FUNCTION TO ROUND NUMBER OF MATRIX
C
      CHARACTER * 8 IAGT_NO                ! FUNCTION TO FORMAT AGENT NUMBER
C
C COPY PARAMETER RECORD REGISTER TO LOCAL ONE IN ORDER TO WORK WITH
C
      CALL FASTMOV(MTXREC, MFCREC, MFCLEN)
C
C CALCULATE REGISTER POSITION TO WRITE NEW INFORMATION
C
      POS = 23 * CNTSMRFMTINF + 1
C
C INCREASE FORMATED SUMMARY REPORT INFORMATION COUNTER
C
      CNTSMRFMTINF = CNTSMRFMTINF + 1
C
C GET TOTAL MATRIX FOR TOTOGOLO / TOTOBOLA AND INCREASE TOTALS BY DISTRICT
C
      LKTOTGOLO = ROUND_TO_PACKET(GET_TOTAL_MATRIX_GOLO(MTXREC), TGLGAM)
      LKTOTBOLO = ROUND_TO_PACKET(GET_TOTAL_MATRIX_TOTO(MTXREC), TBLGAM)
      TOTGOLO = TOTGOLO + LKTOTGOLO
      TOTBOLO = TOTBOLO + LKTOTBOLO
C
C WRITE FORMATED INFORMATION IN REGISTER POSITION
C
      WRITE(FMTSMRINF(POS:POS + 23), 100) IAGT_NO(MFCAGT), LKTOTBOLO, LKTOTGOLO
C
C FORMATS DEFINITION TO FORMAT IN AGENT SUMMARY REPORT ONE AGENT INFORMATION
C
100   FORMAT('| ', A8, X, I4, ' | ', I4, X)
C
C THIS IS THE END TO FORMAT IN AGENT SUMMARY REPORT ONE AGENT INFORMATION
C
      END


C ******************************************************************************
C
C     SUBROUTINE: FORMAT_LABEL_INFO
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 19 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO FORMAT IN AGENT SUMMARY LABEL REPORT ONE AGENT INFORMATION
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE FORMAT_LABEL_INFO(MTXREC, CNTLBLFMTINF)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO FORMAT IN AGENT SUMMARY LABEL REPORT ONE AGENT INFOR.
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITON TO FORMAT IN AGENT SUMMARY LABEL REPORT ONE AGENT INFOR.
C
      INTEGER * 4 MTXREC(*)         ! MATRIX REGISTER
      INTEGER * 4 CNTLBLFMTINF      ! SUMMARY LABEL FORMATED INFO COUNTER 
C
C VARIABLES DEFINITON TO FORMAT IN AGENT SUMMARY LABEL REPORT ONE AGENT INFOR.
C
      INTEGER * 4 POS               ! POSITION
      INTEGER * 4 CNT               ! COUNTER
      INTEGER * 4 TOT_TOTO          ! TOTAL MAXTRIX FOR TOTO
      INTEGER * 4 TOT_GOLO          ! TOTAL MAXTRIX FOR GOLO
      INTEGER * 4 TOP_MFCADR(8)     ! TOP ADDRESS
      INTEGER * 4 BOT_MFCADR(8)     ! BOTTON ADDRESS
      INTEGER * 4 TOP_MFCNAM(8)     ! TOP AGENT NAME
      INTEGER * 4 BOT_MFCNAM(8)     ! BOTTON AGENT NAME
C
C FUNCTIONS DEFINITION TO FORMAT IN AGENT SUMMARY LABEL REPORT ONE AGENT INFOR.
C
      INTEGER * 4 GET_TOTAL_MATRIX_TOTO    ! FUNCTION TO GET TOTAL MATRIX TOTO
      INTEGER * 4 GET_TOTAL_MATRIX_GOLO    ! FUNCTION TO GET TOTAL MATRIX GOLO
      INTEGER * 4 ROUND_TO_PACKET          ! FUNCTION TO ROUND NUMBER OF MATRIX
C
      CHARACTER * 8 IAGT_NO                ! FUNCTION TO FORMAT AGENT NUMBER
C
C COPY PARAMETER RECORD REGISTER TO LOCAL ONE IN ORDER TO WORK WITH
C
      CALL FASTMOV(MTXREC, MFCREC, MFCLEN)
C
C INCREASE FORMATED SUMMARY LABEL REPORT INFORMATION COUNTER
C
      CNTLBLFMTINF = CNTLBLFMTINF + 1
C
C SET VARIABLES TO FORMAT AGENT LABEL INFORMATION
C
      POS = CNTLBLFMTINF
C
C CALCULATE TOTAL MATRIX TOTO AND TOTAL MATRIX GOLO
C
      TOT_TOTO = ROUND_TO_PACKET(GET_TOTAL_MATRIX_TOTO(MTXREC), TBLGAM)
      TOT_GOLO = ROUND_TO_PACKET(GET_TOTAL_MATRIX_GOLO(MTXREC), TGLGAM)
C
C FORMAT "AGENTE DE LOTARIA INSTANTANEA" ( SCML AT LEAST DO NOT WANT THIS )
C
C    WRITE(FMTLBLINF(POS, 1), 100)
C
C WRITE TOTAL OF MATRIXES CALCULATED TO TOTOGOLO / TOTOBOLA 
C
      WRITE(FMTLBLINF(POS, 2), 200) IAGT_NO(MFCAGT),
     *                              MCFALD,
     *                              MCFACR,
     *                              TOT_TOTO,
     *                              TOT_GOLO
C
C WRITE TOTAL MATRIZES
C
      WRITE(FMTLBLINF(POS, 3), 300) TOT_TOTO + TOT_GOLO
C
C FORMAT AGENT NAME IN THE REGISTER VARIABLE
C
      CALL DIVIDE_STRING(MFCNAM, TOP_MFCNAM, BOT_MFCNAM, 8, MAXMFCNAM)
      WRITE(FMTLBLINF(POS, 4), 400) (TOP_MFCNAM(CNT), CNT = 1, 8)
      WRITE(FMTLBLINF(POS, 5), 500) (BOT_MFCNAM(CNT), CNT = 1, 8)
C
C FORMAT AGENT ADRESS INFORMATION IN THE REGISTER VARIABLE
C
      CALL DIVIDE_STRING(MFCADR, TOP_MFCADR, BOT_MFCADR, 8, MAXMFCADR)
      WRITE(FMTLBLINF(POS, 6), 400) (TOP_MFCADR(CNT), CNT = 1, 8)
      WRITE(FMTLBLINF(POS, 7), 600) (BOT_MFCADR(CNT), CNT = 1, 8)
C
C FORMAT AGENT ZIP CODE / AGEN CITY IN THE REGISTER VARIABLE
C
      WRITE(FMTLBLINF(POS, 8), 700) MCFZCD / 1000,
     *                              MOD(MCFZCD, 1000),
     *                              (MFCCTY(CNT), CNT = 1, 6)
      WRITE(FMTLBLINF(POS, 9), 800) (MFCCTY(CNT), CNT = 7, 8)
C
C FORMATS DEFINITION TO FORMAT IN AGENT SUMMARY LABEL REPORT ONE AGENT INFOR.
C
100   FORMAT('- MEDIADOR DE LOTARIA INSTANTANEA -')
200   FORMAT(A, X, I2.2, X, I7.7, ' (T ', I4, X 'G ', I4, ')')
300   FORMAT(X, 3X, 'TOT. MAT.:', X, I5)
400   FORMAT(8A4)
500   FORMAT(8A4)
600   FORMAT(8A4)
700   FORMAT(I4.4, '-', I3.3, X, 6A4)
800   FORMAT(2A4)
C
C THIS IS THE END TO  FORMAT IN AGENT SUMMARY LABEL REPORT ONE AGENT INFOR.
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_TOTAL_MATRIX_TOTO
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 19 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET TOTAL NUMBER OF TOTO MATRIX USED BY THE AGENT
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_TOTAL_MATRIX_TOTO(MTXREC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET TOTAL NUMBER OF TOTO MATRIX USED BY THE AGENT
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO GET TOTAL NUMBER OF TOTO MATRIX USED BY THE AGENT
C
      INTEGER * 4 MTXREC(*)      ! MATRIX REGISTER
C
C VARIABLES DEFINITION TO GET TOTAL NUMBER OF TOTO MATRIX USED BY THE AGENT
C
      INTEGER * 4 TOT_TOTO       ! TOTAL TOTO COUNTER
      INTEGER * 4 WEEK           ! WEEK COUNTER
      INTEGER * 4 WAGER          ! WAGER COUNTER
C
C COPY PARAMETER RECORD REGISTER TO LOCAL ONE IN ORDER TO WORK WITH
C
      CALL FASTMOV(MTXREC, MFCREC, MFCLEN)
C
C INITIATE TOTAL TOTOBOLA ( TOTO ) COUNTER
C
      TOT_TOTO = 0
C
C CALCULATE TOTALS FOR TOTOBOLA ( TOTO )       
C
      DO WEEK = 1, MAXWEK
        DO WAGER = 1, MAXWAG
          TOT_TOTO = TOT_TOTO + MFCWSB(TOTCNT, WEEK, TBLGAM, WAGER)
          TOT_TOTO = TOT_TOTO + MFCWMB(TOTCNT, WEEK, TBLGAM, WAGER)
        ENDDO
      ENDDO
C
C SET OUTPUT CALCULATED VALUE
C
      GET_TOTAL_MATRIX_TOTO = TOT_TOTO      
C
C THIS IS THE END TO GET TOTAL NUMBER OF TOTO MATRIX USED BY THE AGENT
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_TOTAL_MATRIX_GOLO
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 19 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET TOTAL NUMBER OF GOLO MATRIX USED BY THE AGENT
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_TOTAL_MATRIX_GOLO(MTXREC)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET TOTAL NUMBER OF GOLO MATRIX USED BY THE AGENT
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO GET TOTAL NUMBER OF GOLO MATRIX USED BY THE AGENT
C
      INTEGER * 4 MTXREC(*)      ! MATRIX REGISTER
C
C VARIABLES DEFINITION TO GET TOTAL NUMBER OF GOLO MATRIX USED BY THE AGENT
C
      INTEGER * 4 TOT_GOLO       ! TOTAL GOLO COUNTER
      INTEGER * 4 WEEK           ! WEEK COUNTER
      INTEGER * 4 WAGER          ! WAGER COUNTER
C
C COPY PARAMETER RECORD REGISTER TO LOCAL ONE IN ORDER TO WORK WITH
C
      CALL FASTMOV(MTXREC, MFCREC, MFCLEN)
C
C INITIATE TOTAL TOTOGOLO ( GOLO ) COUNTER
C
      TOT_GOLO = 0
C
C CALCULATE TOTALS FOR TOTOGOLO ( GOLO )       
C
      DO WEEK = 1, MAXWEK
        DO WAGER = 1, MAXWAG
          TOT_GOLO = TOT_GOLO + MFCWSB(TOTCNT, WEEK, TGLGAM, WAGER)
          TOT_GOLO = TOT_GOLO + MFCWMB(TOTCNT, WEEK, TGLGAM, WAGER)
        ENDDO
      ENDDO
C
C SET OUTPUT CALCULATED VALUE
C
      GET_TOTAL_MATRIX_GOLO = TOT_GOLO      
C
C THIS IS THE END TO GET TOTAL NUMBER OF GOLO MATRIX USED BY THE AGENT
C
      END


C ******************************************************************************
C
C     SUBROUTINE: ROUND_TO_PACKET
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 21 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO ROUND TOTAL NUMBER OF MATRIX USE TO NUMBER OF MATRIX TO SEND TO
C THE AGENTS ( MATRIX ARE PACKET IN 25 MATRIX )
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION ROUND_TO_PACKET(MTXUSED, GAME)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO ROUND TOTAL NUMBER OF MATRIX TO SEND
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO ROUND TOTAL NUMBER OF MATRIX TO SEND
C
      INTEGER * 4 MTXUSED        ! TOTAL NUMBER OF MATRIX USED
      INTEGER * 4 GAME           ! GAME TO ROUND AND SET NUMBER OF MATRIX
C
C DEFINE CONSTANT VARIABLES DEFINITION TO ROUND TOTAL NUMBER OF MATRIX TO SEND
C
      INTEGER * 4 MINMTX         ! MINIMUM NUMBER OF MATRIX IN ONE PACKET
      INTEGER * 4 MXPKVL         ! MAXIMUM PACKET VALUE
C
C INITIATE CONSTANT VARIABLES TO ROUND TOTAL NUMBER OF MATRIX TO SEND
C
      PARAMETER(MINMTX = 30)     ! MINIMUM NUMBER OF MATRIX IN ONE PACKET
      PARAMETER(MXPKVL = 9990)   ! MAXIMUM PACKET VALUE
C
C VARIABLES DEFINITION TO ROUND TOTAL NUMBER OF MATRIX TO SEND
C
      INTEGER * 4 MTXSEND        ! TOTAL NUMBER OF MATRIX TO SEND 
      INTEGER * 4 DECVAL         ! DECIMAL VALUE
C
      REAL * 8 AGTFACTOR         ! AGENT FACTOR TO SET NUMBER OF MATRIX
C
C CALCULATE FACTOR OF MULTIPLICATION BY AGENT
C
      AGTFACTOR = 0
      IF(TOTWEEKMTX(GAME) .GT. 0) THEN
        AGTFACTOR = DFLOAT(DTRTMTX(GAME)) / DFLOAT(TOTWEEKMTX(GAME))
        AGTFACTOR = AGTFACTOR * DFLOAT(MTXUSED)
      ENDIF
C
C SET ROUND VALUES TO SET TOTAL NUMBER OF MATRIX TO SEND
C
      MTXSEND = IDNINT(AGTFACTOR)
      DECVAL = MOD(MTXSEND, 10)
C
C ROUND MATRIX TO SEND TO NEAREST 10 VALUE AND CHECK MINIMUM NUMBER TO SEND
C
      MTXSEND = MTXSEND - DECVAL
      IF(DECVAL .GE. 5) MTXSEND = MTXSEND + 10
      IF(MTXSEND .LT. MINMTX) MTXSEND = MINMTX
C
C IF TOTAL TO SEND IS GREATER THAN MAXIMUM ABAILABLE ( 9990 ) PUT MAXIMUM
C
      IF(MTXSEND .GT. MXPKVL) MTXSEND = MXPKVL 
C
C SET OUT TOTAL NUMBER OF MATRIX TO SEND
C
      ROUND_TO_PACKET = MTXSEND
      RETURN      
C
C THIS IS THE END TO ROUND TOTAL NUMBER OF MATRIX TO SEND
C
      END



C ******************************************************************************
C
C     SUBROUTINE: GET_AGENT_DISTRICT
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 28 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION THAT CALCULATES ASOCIATED DISTRICT TO ONE AGENT
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_AGENT_DISTRICT(AGENT)
      IMPLICIT NONE
C
C PARAMETERS DEFINITON TO CALCULATE ASOCIATED DISTRICT TO ONE AGENT
C
      INTEGER * 4 AGENT          ! AGENT NUMBER]
C
C CALCULATE ASOCIATED DISTRICT TO ONE AGENT AND RETURN THE VALUE
C
      GET_AGENT_DISTRICT = AGENT / 100000
      RETURN
C
C THIS IS THE END TO CALCULATE ASOCIATED DISTRICT TO ONE AGENT
C
      END




C ******************************************************************************
C
C     SUBROUTINE: PRINT_DISTRICT_TOTALS
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 28 / 09 / 2001
C
C ******************************************************************************
C
C FUNCTION TO PRINT TOTALS BY DISTRICT FOR TOTOGOLO AND TOTOBOLA
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE PRINT_DISTRICT_TOTALS(CNTLINE, PAGE, LSTDTCT, TOTGOLO, TOTBOLO)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO PRINT TOTALS BY DISTRICT
C
      INCLUDE 'INCLIB:BSAGTCTL.DEF'
C
C PARAMETERS DEFINITION TO PRINT TOTALS BY DISTRICT
C
      INTEGER * 4 CNTLINE      ! REPORT LINE COUNTER
      INTEGER * 4 PAGE         ! PAGE COUNTER
      INTEGER * 4 LSTDTCT      ! LAST DISTRICT
      INTEGER * 4 TOTGOLO      ! TOTAL DISTRICT GOLO GAME
      INTEGER * 4 TOTBOLO      ! TOTAL DISTRICT BOLO GAME
C
C CHECH IF WE HAVE ESPACE ENOUGHT IN ACTUAL PAGE OR WE NEED A NEW PAGE
C WE NEED 5 LINES TO PRINT TOTALS
C
      IF(CNTLINE .GT. 56) THEN
        CALL PRINT_SUMMARY_HEADER(PAGE, CNTLINE, LSTDTCT)
      ENDIF
C
C PRINT TOTALS BY DISTRICT FOR TOTOBOLA AND TOTOGOLO
C
      WRITE(BSSIDFIL, 100)
      WRITE(BSSIDFIL, 200) 
      WRITE(BSSIDFIL, 300) 'TotoBola', TOTBOLO
      WRITE(BSSIDFIL, 300) 'TotoGolo', TOTGOLO
      WRITE(BSSIDFIL, 200)
C
C RESET VARIABLES IN ORDER TO PREPARE TO NEXT DISTRICT
C
      PAGE = 1
      CNTLINE = 0
      TOTGOLO = 0
      TOTBOLO = 0
C
C FORMATS DEFINITION TO PRINT TOTALS BY DISTRICT
C
100   FORMAT(X)
200   FORMAT(X, 10X, 31('='))
300   FORMAT(X, 10X, 'Total Centro ', A, ':', X, I8)
C
C THIS IS THE END TO PRINT TOTALS BY DISTRICT
C
      END

