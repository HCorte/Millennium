C PROGRAM X2XREL
C
C V10 16-JUN-2000 OXK Cleanup w/ WARNINGS=ALL
C V09 03-MAR-1996 wsm Fixed appending ## to X2XWAIT##.FIL name.
C V08 09-NOV-1995 WJK USE SYSTEM FLAG TO DETERMINE X2XWAIT##.FIL PATH
C V07 29-DEC-1994 WJK MOVE UNSOLICITED STATION CONNECT AND DISCONNECT 
C			FROM GLOBAL TO STATION CLASS
C V06 12-DEC-1994 DAS Integrate UK changes into X2X Baseline
C V05 19-JUL-1994 WS MULTINETWORK CHANGES
C V04 05-APR-1994 GPR USE X2X_I4_STATION TO EXTRACT STATION AND TERNUM
C V03 01-FEB-1993 DAS MAJOR RESTRUCTURING AND BUG FIXES 
C V02 14-JUL-1992 NJA ADDED (CHECK FOR ONLINE TERMINALS)
C V01 01-AUG-1990 XXX RELEASED FOR VAX
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C 
C     PROGRAM:
C        X2RSTNST(STATION,CHAIN,GROUP,PROCESS,STATUS) 
C
C     PURPOSE:
C       RELAYS PROCESSING TASK
C 
C       THIS TASK WILL ACCEPT:
C         RELAY START
C         RELAY STOP
C         RELAY STATUS
C         RELAY REQUEST
C         DELIVERY ERROR FOR RELAY MESSAGE
C         DELIVERY ACK FOR SENDING RELAY MESSAGE
C 
C     TASK WILL GENERATE TIMEOUT IF NONE OF THE ABOVE OCCURED
C 
C     INPUT:   NONE
C     OUTPUT:  NONE
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
C
	PROGRAM X2XREL
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'			!V05
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:X2RCMD.DEF'
	INCLUDE 'INCLIB:X2XREL.DEF'
	INCLUDE 'INCLIB:X2STMES.DEF'
	INCLUDE 'INCLIB:X2FEMES.DEF'
C
	INTEGER*4 STATUS, STATION, DEST_LAYER, TYPE, ST
	INTEGER*4 PROCESS
	INTEGER*4 I4, PROBUF
        INTEGER*4  INPTAB2
        PARAMETER (INPTAB2=INPTAB*2-1)

C	START V05 CHANGE BLOCK
	INTEGER*4 FDB(7,X2X_RELAY_APPS), SIZE(X2X_RELAY_APPS)
	INTEGER*4 LASTREC(X2X_RELAY_APPS) /X2X_RELAY_APPS*0/
	INTEGER*4 LAST_TIME/0/
	INTEGER*4 NEXT_FILE, NEXT_PROCESS, QSIZE
	LOGICAL CHECK_AGAIN
	CHARACTER*24	X2XRWAIT
	CHARACTER*1	CX2XRWAIT(24)
	INTEGER*4	I4X2XRWAIT(6)
	EQUIVALENCE	(X2XRWAIT,CX2XRWAIT,I4X2XRWAIT)
	INTEGER*4	SUBNETWORK
C	END V05 CHANGE BLOCK
C
	CALL COPYRITE
	CALL SNIF_AND_WRKSET
C 
C       INITIALIZE QUEUES AND WAIT VALUE
C 
        CALL FASTSET(0,X2XR_INPUT_QUEUE,NUMPRO+QHEDSZ)
	CALL DEFLST(X2XR_INPUT_QUEUE,NUMPRO)
C****V05        CALL FASTSET(0,X2XR_WAIT_QUEUE,NUMPRO+QHEDSZ)
C****V05        CALL DEFLST(X2XR_WAIT_QUEUE,NUMPRO)
C
C	START V05 CHANGE BLOCK
	CALL FASTSET(1,X2XR_WAIT_FRONT,X2X_RELAY_APPS)
	CALL FASTSET(1,X2XR_WAIT_BACK,X2X_RELAY_APPS)
	CALL FASTSET(0,X2XR_WAIT_MAX,X2X_RELAY_APPS)
C
	DO 5, NEXT_FILE=X2XR_FIRST_COMMON_PROCESS, X2X_RELAY_APPS
	    IF (X2XR_APP_STATUS(NEXT_FILE).EQ.0) GOTO 5

001	    CONTINUE

        IF (PX2X_TASK) THEN                                     	!V08
	    X2XRWAIT='PX2XFILES:X2XRWAIT  .FIL'				!V06
	    CX2XRWAIT(19)=CHAR(NEXT_FILE/10+48)
	    CX2XRWAIT(20)=CHAR(MOD(NEXT_FILE,10)+48)
	ELSE								!V08
	    X2XRWAIT='X2XRWAIT  .FIL'					!V08
	    CX2XRWAIT(9)=CHAR(NEXT_FILE/10+48)
	    CX2XRWAIT(10)=CHAR(MOD(NEXT_FILE,10)+48)
	ENDIF								!V08

	    CALL OPENW(10+NEXT_FILE,I4X2XRWAIT,4,0,0,ST)
	    IF (ST .NE. 0) THEN
		TYPE *,'Cannot open ',X2XRWAIT,ST
		CALL GSTOP(GEXIT_SUCCESS)
	    ENDIF
	
C
	    CALL GETSIZ_USED(10+NEXT_FILE,SIZE(NEXT_FILE))
	    LASTREC(NEXT_FILE) = SIZE(NEXT_FILE) / 2
	    CALL IOINIT(FDB(1,NEXT_FILE),10+NEXT_FILE,512)
5	CONTINUE
C	END V05 CHANGE BLOCK

	DO 10 PROCESS=1,X2X_RELAY_APPS
	   CALL DEFLST(X2XR_APP_QUEUE(1,PROCESS),NUMPRO)
10	CONTINUE
C 
C       SET RELAY WAIT VALUE
C 
	IF (X2X_RELAY_WAIT.EQ.0) X2X_RELAY_WAIT=500 
C
C=====================================================================
C
C       START PROCESSING 
C
C=====================================================================
C 
20	CONTINUE
C
C       IF COMMUNICATIONS HAS BEEN DISABLED THEN STOP THE TASK
C       (DONE AT DAYEND)
C 
	IF(X2X_GAME_STATE.EQ.X2X_GAMES_SHUTDOWN) THEN
C****V05	  CALL X2RKICK1
	  CALL GSTOP(GEXIT_SUCCESS)
	ENDIF
C 
C       TRY TO GET A BUFFER FROM THE RELAY INPUT QUEUE
C 
	CHECK_AGAIN=.FALSE.				!V05
	IF (P(ACTTIM).NE.LAST_TIME) THEN		!V05
	    CALL X2RRELTM(ST)				!V05
	    IF (ST.GE.0) CHECK_AGAIN=.TRUE.		!V05
	    LAST_TIME=P(ACTTIM)				!V05
	ENDIF  						!V05
	CALL X2RGETBF(PROBUF,ST)
C
C       IF A BUFFER LIST IS EMPTY (ST = 2):
C          EXISTING PROCESSES MUST BE CHECKED. 
C          1) CALL X2RRELTM TO HANDLE ANY "TIMED OUT" PROCESS
C          2) DETERMINE IF ANY PROCESSES WAS WAITING TO BE STARTED
C             BECAUSE OF LACK OF RESOURCES(WILL BE IN X2XR WAIT QUEUE)  
C
C
	IF (ST.EQ.2) THEN
	    IF (CHECK_AGAIN) GOTO 20			!V05
C
C          TRY TO PROCESS ANY TIMED OUT PROCESS
C
C	START OF V05 CHANGE BLOCK
C****	    IF (ST.GE.0) GOTO 20  
C****	   CALL X2RKICK                  !KICK RELAY APPLICATION TASKS
	   CALL XWAIT(X2X_RELAY_WAIT,1,ST)
C
C****           CALL RTL(PROBUF,X2XR_WAIT_QUEUE,ST)
C****           IF(ST.EQ.2) THEN
C****             GOTO 20                     !NOTHING IN WAIT QUEUE        
C****           ENDIF
*
*        CHECK IF THERE IS AVAILABLE PROCESS
*
      	    DO 30, NEXT_PROCESS=X2XR_FIRST_COMMON_PROCESS,
     *						  X2X_RELAY_APPS
	      IF (X2XR_WAIT_FRONT(NEXT_PROCESS) .EQ. 
     *		  X2XR_WAIT_BACK(NEXT_PROCESS)) GOTO 30
      	      IF (X2XR_APP_STATUS(NEXT_PROCESS).NE.X2XR_APPS_IDLE)GOTO 30
C
C        THERE IS PROCESS AVAILABLE AND OUTSTANDING REQUESTS
C
            IF (X2XR_WAIT_MAX(NEXT_PROCESS) .NE. 0)  THEN
               QSIZE = X2XR_WAIT_BACK(NEXT_PROCESS) - 
     *		     X2XR_WAIT_FRONT(NEXT_PROCESS)
               IF (QSIZE .LT. 0) QSIZE = QSIZE + LASTREC(NEXT_PROCESS)
               IF (QSIZE .GT. X2XR_WAIT_MAX(NEXT_PROCESS)) THEN
                   X2XR_WAIT_FRONT(NEXT_PROCESS)  = 
     *			  X2XR_WAIT_FRONT(NEXT_PROCESS) +
     *			      (QSIZE - X2XR_WAIT_MAX(NEXT_PROCESS))
                   IF (X2XR_WAIT_FRONT(NEXT_PROCESS) .GT. 
     *			  LASTREC(NEXT_PROCESS))
     *                 X2XR_WAIT_FRONT(NEXT_PROCESS) = 
     *			  X2XR_WAIT_FRONT(NEXT_PROCESS) - 
     *						  LASTREC(NEXT_PROCESS)
               ENDIF
            ENDIF
            CALL GETBUF (PROBUF)
            IF (PROBUF .LE. 0) GOTO 30
            CALL READW(FDB(1,NEXT_PROCESS),
     *	      X2XR_WAIT_FRONT(NEXT_PROCESS), PRO(1,PROBUF),ST)
            IF (ST .NE. 0) THEN
              GOTO 30
            ENDIF
            X2XR_WAIT_FRONT(NEXT_PROCESS) = 
     *			      X2XR_WAIT_FRONT(NEXT_PROCESS) + 1
            IF (X2XR_WAIT_FRONT(NEXT_PROCESS).GT.LASTREC(NEXT_PROCESS)) 
     *	      X2XR_WAIT_FRONT(NEXT_PROCESS) = 1
C 
	    GOTO 35
30    	  CONTINUE
	  GOTO 20
35	  CONTINUE
C	END OF V05 CHANGE BLOCK
	ENDIF   !/* END (ST.EQ.2)  */

C 
C       IF COMMUNICATIONS IS NOT UP RELEASE THIS BUFFER BACK TO THE
C       FREE LIST
C 
	IF (X2X_GAME_STATE.NE.X2X_GAMES_UP .AND.
     *	    X2X_GAME_STATE.NE.X2X_GAMES_REQUP) THEN
	   CALL RELBUF(PROBUF)
	   GOTO 20
	ENDIF
C 
C       START DECODING THE RELAY BUFFER CONTENTS
C 
	TYPE       = HPRO(TRCODE,PROBUF)   !GET TRANS TYPE
	DEST_LAYER = HPRO(X2X_DEST,PROBUF) !DESTINATION LAYER CAME FROM

C	***** Start V04 changes *****

        IF (X2X_I4_STATION) THEN
	   STATION    = PRO(LINENO,PROBUF)    !STATION #
	ELSE
	   STATION    = HPRO(LINENO,PROBUF)    !STATION #
	ENDIF

C	***** End V04 changes *****

C 
	IF (IAND(X2X_DEBUG,X2X_DEBUG_X2XREL).NE.0) THEN
      	   TYPE *,'Got transaction, type ',TYPE,' dest ',DEST_LAYER,
     *  	       ' station ',STATION
        ENDIF
C
C=====================================================================
C
C      PROCESS RELAY BUFFER ACCORDING TO TYPE
C         CURRENT VALUES IN PROCOM.DEF ARE:
C           TYPX2X_RELAY_CMD     -  START / STOP COMMANDS (X2RCMD)
C           TYPX2X_RELAY         -  RELAY MESSAGES  (X2RELMSG)
C           TYPX2X_RELAY_TIMEOUT -  RELAY TIMEOUTS  (X2RELMSG)
C           TYPX2X_RELAY_DELACK  -  RELAY DEL. ACKS (X2RDELACK)
C           TYPX2X_RELAY_DELERR  -  RELAY DEL. ERRORS (X2RDELER)
C
C      STATUS VALUES:
C              -2  -- BUFFER HAS BEEN PLACED IN WAIT QUEUE (START CMD)
C              -1  -- DO NOT SEND TO RELAY PROC. TASK, RELEASE BUFFER
C               0  -- SEND TO RELAY PROCESSING TASK
C               1  -- CLEAR THE SVC CALL
C
C=====================================================================
C
C       TYPE COMMAND (START OR STOP)
C 
	IF (TYPE.EQ.TYPX2X_RELAY_CMD) THEN
	   CALL X2RCMD(PRO(INPTAB,PROBUF),PROCESS,SUBNETWORK,STATUS)	!V05
           IF (IAND(X2X_DEBUG,X2X_DEBUG_X2XREL).NE.0)
     *        TYPE *,'RETURN X2RCMD ',STATUS
C
C       TYPE RELAY
C
	ELSEIF (TYPE.EQ.TYPX2X_RELAY) THEN
          CALL X2RELMSG(PRO(INPTAB,PROBUF),STATION,TYPE,PROCESS,STATUS)
          IF (IAND(X2X_DEBUG,X2X_DEBUG_X2XREL).NE.0)
     *	     TYPE *,'RETURN X2RELMSG 1 ',STATUS
C
C       TYPE RELAY TIMEOUT
C
	ELSEIF (TYPE.EQ.TYPX2X_RELAY_TIMOUT) THEN
          CALL X2RELMSG(PRO(INPTAB,PROBUF),STATION,TYPE,PROCESS,STATUS)
          IF (IAND(X2X_DEBUG,X2X_DEBUG_X2XREL).NE.0)
     *	     TYPE *,'RETURN X2RELMSG 2 ',STATUS
C
C       TYPE RELAY DELIVERY ACKNOWLEDGEMENT
C
	ELSEIF (TYPE.EQ.TYPX2X_RELAY_DELACK) THEN 
C 
          CALL X2RDELAK(PRO(INPTAB,PROBUF),STATION,PROCESS,STATUS)
          IF (IAND(X2X_DEBUG,X2X_DEBUG_X2XREL).NE.0)
     *	     TYPE *,'RETURN X2RDELACK ',STATUS
C
C       TYPE RELAY DELIVERY ERROR     
C 
	ELSEIF (TYPE.EQ.TYPX2X_RELAY_DELERR) THEN  !DELIVERY ERROR
          CALL X2RDELER(PRO(INPTAB,PROBUF),STATION,PROCESS,STATUS)
          IF (IAND(X2X_DEBUG,X2X_DEBUG_X2XREL).NE.0)
     *	     TYPE *,'RETURN X2RDELER ',STATUS
	ENDIF
C
C=====================================================================
C       PROCESS RESULTS ACCORDING TO STATUS
C=====================================================================
C
        STATUS = STATUS + 3
C             -2  -1   0   1             
        GOTO (100,200,300,400),STATUS
          TYPE *,' Invalid status recieved in X2XREL STATUS: ',STATUS
          TYPE *,' Type: ',TYPE,'Station: ',STATION
          CALL RELBUF(PROBUF)
          GOTO 20
C
C=====================================================================
C       STATUS = -2
C       BUFFER PUT ON WAIT QUEUE
C       FROM X2RCMD ONLY
C=====================================================================
C
100     CONTINUE
C	START OF V05 CHANGE BLOCK
C****        CALL ABL(PROBUF,X2XR_WAIT_QUEUE,ST)
C****        IF(ST.NE.0) THEN
C****          TYPE *,' Error place buffer on x2xrel wait que'
C****          CALL RELBUF(PROBUF)
C****        ENDIF
C
C	FIND PROCESS NO TO USE
C
	
      	DO 130, NEXT_PROCESS=X2XR_FIRST_COMMON_PROCESS,
     *						  X2X_RELAY_APPS
      	  IF (X2XR_APP_STATUS(NEXT_PROCESS).EQ.0)GOTO 130
	  IF (X2XR_SUBNETWORK(NEXT_PROCESS).EQ.SUBNETWORK) THEN
C
	      CALL WRITEW(FDB(1,NEXT_PROCESS),
     *		      X2XR_WAIT_BACK(NEXT_PROCESS),PRO(1,PROBUF),ST)
      	      IF (ST .NE. 0) THEN
      		  GOTO 20
      	      ENDIF
      	      X2XR_WAIT_BACK(NEXT_PROCESS)
     *		    =X2XR_WAIT_BACK(NEXT_PROCESS)+1
      	      IF (X2XR_WAIT_BACK(NEXT_PROCESS) .GT. 
     *		 LASTREC(NEXT_PROCESS)) X2XR_WAIT_BACK(NEXT_PROCESS)=1
      	      IF (X2XR_WAIT_BACK(NEXT_PROCESS) .EQ. 
     *		  X2XR_WAIT_FRONT(NEXT_PROCESS)) THEN
      		  X2XR_WAIT_FRONT(NEXT_PROCESS) = 
     *			  X2XR_WAIT_FRONT(NEXT_PROCESS) + 1
      		  IF (X2XR_WAIT_FRONT(NEXT_PROCESS) .GT. 
     *				      LASTREC(NEXT_PROCESS)) 
     *		      X2XR_WAIT_FRONT(NEXT_PROCESS) = 1
      	      ENDIF
      	      GOTO 140
	   ENDIF
130	CONTINUE
140	CONTINUE
	CALL RELBUF(PROBUF)
	GOTO 20

C
C	END OF V05 CHANGE BLOCK
C
C=====================================================================
C       STATUS = -1
C       RELEASE THE BUFFER
C       DO NOT QUEUE TO RELAY PROCESSING TASK
C=====================================================================
C
200     CONTINUE
        CALL RELBUF(PROBUF)
        GOTO 20
C
C=====================================================================
C       STATUS = 0
C       BUILD PROCOM BUFFER AND
C       QUEUE TO THE RELAY PROCESSING TASK
C=====================================================================
C
300     CONTINUE
C..........................................................................
C       SET THE BUFFER LENGTH:
C         THIS CODE MAY LOOK LIKE NONSENSE BUT MUST BE RETAINED.
C         APPEARENTLY TWO LENGTHS MUST BE PAST TO X2XMGR (MSGEDT)
C         FOR ACTUAL RELAYS TO WORK CORRECTLY ????           
C            
C
	I4 = X2STMES_RELAY_HEADER_LEN*OUTLEN_MAX
     *	     + X2XR_APP_DATA_LEN(PROCESS)
C.........................................................................
C
C       AS LONG AS THE LENGTH OF THE BUFFER DOES NOT EXCEED 32 K
C       WE CAN DIRECTING ASSIGN THE I4 VALUE TO HPRO. A BUFFER THAT
C       LARGE OR LARGER SHOULD NEVER HAPPEN. 
C
	HPRO(OUTLEN,PROBUF)     = I4
	HPRO(MSGNUM,PROBUF)     = X2XR_APP_DATA_MSGNUM(PROCESS)
        HPRO(X2X_DEST,PROBUF)   = X2DEST_APP_STATION

C	***** Start V04 changes *****

        IF (X2X_I4_STATION) THEN
	   PRO(TERNUM,PROBUF)      = 0
	ELSE
	   HPRO(TERNUM,PROBUF)      = 0
	ENDIF

C	***** End V04 changes *****

	HPRO(X2X_HOST_ID,PROBUF)= PROCESS
C
C
	IF (X2XR_APP_DATA_LEN(PROCESS).NE.0 .OR.
     *	    X2XR_APP_DATA_MSGNUM(PROCESS).GT.0) THEN
C
C           SINGLE MESSAGE BROADCAST/UNSOLICITED
C
C           SET END OF BROADCAST FLAG TO TERMINATE THE SINGLE MESSAGE
C           PROCESS FOR EACH STATION, THIS WILL BE RETURNED WITH THE
C           ACKNOWLEDGEMENT FOR THE FRONT END.
C 
            HPRO(X2X_HOST_ID,PROBUF)     =
     *                     IOR(PROCESS,X2FEMES_HOST_ID_EB_FLAG)
C
C           TURN ON DELIVERY ACKNOWLEDGEMENTS AND DELIVERY ERRORS
C           X2RTOTER/X2RTOSTN MAY CHANGE THESE VALUES.
C
	    HPRO(X2X_DELIVER_OVR,PROBUF) = X2FEMES_FLAGS_DA
     *	                                 + X2FEMES_FLAGS_ER
 	    HPRO(X2X_CONNCTL_OVR,PROBUF) = 256*
     *	                      (X2X_UNSOLICIT_FE_CONNECT*16)
C
	    IF(IAND(X2X_DEBUG,X2X_DEBUG_X2XREL).NE.0) THEN
               TYPE *,'PROCESS: ',PROCESS
               TYPE *,'HPRO(HOST_ID): ',HPRO(X2X_HOST_ID,PROBUF)
            ENDIF
C 
C           SINGLE MESSAGE BROADCASTS TO ALL ARE SENT WITH NO
C           RELAY HEADER
C 
C           UNSOLICITED/BROADCAST MESSAGES TO ALL TERMINALS (no header)
C
	    IF(X2XR_APP_ATRIBUTE(PROCESS).EQ.
     *                             X2XR_APPA_ALL_NO_FORMAT) THEN
              CALL X2RTOTER(HPRO(1,PROBUF))
C
C           UNSOLICITED/BROADCAST MESSAGES TO ALL STATIONS (no header)
C
	    ELSEIF (X2XR_APP_ATRIBUTE(PROCESS).EQ.
     *	            X2XR_APPA_ALL_STN_NO_FORMAT) THEN
	       CALL X2RTOSTN(HPRO(1,PROBUF))
C
C
C           BROADCASTS AND UNSOLICITED  (formatted)
C
	    ELSEIF (X2XR_APP_DATA_MSGNUM(PROCESS).EQ.0) THEN
	      HPRO(OUTLEN,PROBUF)=X2STMES_RELAY_HEADER_LEN+
     *	                          X2XR_APP_DATA_LEN(PROCESS)
	    ENDIF
	ENDIF
C
C       QUEUE TO THE RELAY APPLICATION
C 
        CALL X2RQUE(PROBUF,PROCESS)
        GOTO 20
C
C=====================================================================
C       STATUS = 1 
C       DELIVERY ACK/WAIT FROM STATION 
C       CLEAR THE CALL
C=====================================================================
C
400     CONTINUE
        CALL X2CLRSVC(PROBUF)
        CALL X2ADDPRO(PROBUF)     !QUEUE DIRECTLY TO X2XPRO 
        GO TO 20
C 
      END
