C
C LODEMIS.FOR
C
C V02 01-OCT-2010 FRP Update DAF file
C V01 23-MAR-2010 FRP Initial Release for Portugal ePassive
C
C LOAD PASSIVE EMISSIONS FROM ORACLE INTERFACE AND UPDATE LOTTERY EMISSIONS FILE
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode Island,
C and contains confidential and trade secret information. It may not be
C transferred from the custody or control of GTECH except as authorized in
C writing by an officer of GTECH. Neither this item nor the information it
C contains may be used, transferred, reproduced, published, or disclosed,
C in whole or in part, and directly or indirectly, except as expressly
C authorized by an officer of GTECH, pursuant to written agreement.
C
C Copyright 1993 GTECH Corporation. All rights reserved.
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
      PROGRAM LODEMIS
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:ORCCOM.DEF'
      INCLUDE 'INCLIB:DPAREC.DEF'
C
      INTEGER*4 ST,GIND,GNUM,IND
      INTEGER*4 YEAR,MONTH,DAY
      INTEGER*4 IGEN_DAT,GENDAT_POS
      CHARACTER CGEN_DAT*8
      LOGICAL*1 ISTHERE,WRITE_EMIS
C
      COMMON /DPACOM/ DPAREC,GNUM,WRITE_EMIS
C
      TYPE*,IAM(),'*********************************************************'
      TYPE*,IAM(),'PROCESS PASSIVE EMISSIONS FILE (ORCEXT_<C/P>AAAAMMDD.ASC)'
      TYPE*,IAM(),'*********************************************************'
      TYPE*,IAM()
C
C Check if System Is Up
      CALL CHCKDIS(ST)
      IF(ST .EQ. 0) THEN
        TYPE*,IAM()
        TYPE*,IAM(),'System is ACTIVE!'
        TYPE*,IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C Ask Passive Type
      CALL INPNUM('Enter 1:Classica or 2:Popular: ',GIND,1,NUMPAS,ST)
      IF(ST.LT.0) CALL GSTOP(GEXIT_OPABORT)
C
      GNUM  = GTNTAB(TPAS,GIND)
      IF(GNUM.LE.0) THEN
        TYPE*,IAM(),'GAME NOT ACTIVE'
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C Ask Generation Date
      CALL INPNUM('Enter File Generation Date (AAAAMMDD): ',IGEN_DAT,1,99999999,ST)
      IF(ST.LT.0) CALL GSTOP(GEXIT_OPABORT)
C
      CGEN_DAT = ITOC(IGEN_DAT,IND)
C
      GENDAT_POS = 1
      CALL GET_VALUE(GENDAT_POS,4,YEAR,CGEN_DAT)
      IF(YEAR .LT. 2010) THEN
        TYPE*,IAM(),'YEAR LOWER THAN 2010'
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
      GENDAT_POS = 5
      CALL GET_VALUE(GENDAT_POS,2,MONTH,CGEN_DAT)
      IF(MONTH .LT. 1 .OR. MONTH .GT. 12) THEN
        TYPE*,IAM(),'MONTH LOWER THAN 1 OR HIGHER THAN 12'
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
      GENDAT_POS = 7
      CALL GET_VALUE(GENDAT_POS,2,DAY,CGEN_DAT)
      IF(DAY .LT. 1 .OR. DAY .GT. 31) THEN
        TYPE*,IAM(),'DAY LOWER THAN 1 OR HIGHER THAN 31'
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C Inquire for Oracle File
      WRITE(ORCNAM,100) STRTYP(GIND),CGEN_DAT
      INQUIRE(FILE=ORCNAM,EXIST=ISTHERE)
      IF(.NOT. ISTHERE) THEN
        TYPE*,IAM(),'ERROR: FILE ',ORCNAM,' NOT FOUND'
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C Open Oracle File
      CALL OPEN_ORC_FILE
C
C Open Log File
      WRITE(LOGNAM,200) STRTYP(GIND),CGEN_DAT
      CALL OPEN_LOG_FILE
C
C Load Oracle File
      WRITE_EMIS = .FALSE.
      CALL LOAD_ORC_FILE
      IF(ORC_ERR_CNT .NE. 0) THEN
        TYPE*,IAM()
        TYPE*,IAM(),ORC_ERR_CNT,' ERRORS FOUND'
        TYPE*,IAM(),'SEE LOG FILE - ',LOGNAM
        TYPE*,IAM(),'FILE WILL NOT BE PROCESSED'
        TYPE*,IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C Rewind Oracle File
      REWIND(ORCLUN)
C
C Load Oracle File
      WRITE_EMIS = .TRUE.
      CALL LOAD_ORC_FILE
C
C Close Oracle File
      CLOSE(ORCLUN)
C
C Close Log File
      CLOSE(LOGLUN)
C
C Formats
100   FORMAT('SYSX:ORCEXT_',A1,A8,'.ASC')
200   FORMAT('SYSX:ORCEXT_',A1,A8,'.LOG')
C
C End
      CALL GSTOP(GEXIT_SUCCESS)
      END
C
C*************************
C SUBROUTINE LOAD_ORC_FILE
C*************************
C LOAD ORACLE INTERFACE FILE
C
C=======OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE LOAD_ORC_FILE
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:STANDARD.DEF'
      INCLUDE 'INCLIB:ORCCOM.DEF'
C
      INTEGER*4 ST
C
      ORC_LIN_CNT = 0
      ORC_ERR_CNT = 0
      ORC_ERR_STR = ' '
C
      CALL LOAD_ORC_HEADER(ST)
      IF(ST .EQ. EOF) RETURN
C
      CALL LOAD_ORC_BODY_TRAILER(ST)
      IF(ST .EQ. EOF) RETURN
C
      RETURN
      END
C
C***************************
C SUBROUTINE LOAD_ORC_HEADER
C***************************
C READ ORACLE INTERFACE FILE HEADER RECORD
C
C=======OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE LOAD_ORC_HEADER(ST)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:STANDARD.DEF'
      INCLUDE 'INCLIB:ORCCOM.DEF'
C
      INTEGER*4 ST
      INTEGER*4 POS
      CHARACTER REC_TYPE*2
C
      CALL READ_ORC_FILE(ST)
      IF(ST .EQ. EOF) THEN
        ORC_ERR_STR = IAM()//' INVALID EOF. SHOULD BE A HEADER RECORD'
        CALL WRITE_LOG_FILE
        RETURN
      ENDIF
C
      POS=1
C
      CALL GET_REC_TYPE(POS,REC_TYPE)
      IF(REC_TYPE .NE. 'HP') THEN
        ORC_ERR_STR = IAM()//' HEADER RECORD INVALID. SHOULD BE TYPE HP'
        CALL WRITE_LOG_FILE
      ENDIF
C
      CALL GET_GEN_DATE(POS)
      IF(ORC_GEN_DAT .NE. ORCNAM(14:21)) THEN
        ORC_ERR_STR = IAM()//' GENDATE NOT EQUAL TO GENDATE IN FILE NAME'
        CALL WRITE_LOG_FILE
      ENDIF
C
      RETURN
      END
C
C*********************************
C SUBROUTINE LOAD_ORC_BODY_TRAILER
C*********************************
C READ ORACLE INTERFACE FILE BODY AND TRAILER RECORDS
C
C=======OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE LOAD_ORC_BODY_TRAILER(ST)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:STANDARD.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:ORCCOM.DEF'
      INCLUDE 'INCLIB:DPPREC.DEF'
      INCLUDE 'INCLIB:DPAREC.DEF'
      INCLUDE 'INCLIB:RECDAF.DEF'
C
      INTEGER*4 ST
      INTEGER*4 GNUM,POS
      INTEGER*4 UNIT_P,FDB_P(7),UNIT_E,FDB_E(7),UNIT_A,FDB_A(7)
      CHARACTER REC_TYPE*2
      LOGICAL*1 WRITE_EMIS,IS_TRAILER
C
      COMMON /DPACOM/ DPAREC,GNUM,WRITE_EMIS
C
C Open Passive Emission File
      CALL FIND_AVAILABLE_LUN(UNIT_E,ST)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR GETTING LOGICAL UNIT FOR PASSIVE EMISSION FILE'
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
      CALL OPENW(UNIT_E,GFNAMES(1,GNUM),4,0,0,ST)
      CALL IOINIT(FDB_E,UNIT_E,DPASEC*256)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR OPENING PASSIVE EMISSION FILE STATUS ',ST
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
C Open Passive Plan File
      CALL FIND_AVAILABLE_LUN(UNIT_P,ST)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR GETTING LOGICAL UNIT FOR PASSIVE PLAN FILE'
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
      CALL OPENW(UNIT_P,SFNAMES(1,PPF),4,0,0,ST)
      CALL IOINIT(FDB_P,UNIT_P,DPPSEC*256)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR OPENING PASSIVE PLAN FILE STATUS ',ST
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
C Open Daily Activity File
      CALL FIND_AVAILABLE_LUN(UNIT_A,ST)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR GETTING LOGICAL UNIT FOR ACTIVITY FILE'
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
      CALL OPENW(UNIT_A,SFNAMES(1,DAF),4,0,0,ST)
      CALL IOINIT(FDB_A,UNIT_A,DAFSEC*256)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR OPENING ACTIVITY FILE STATUS ',ST
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
C Read Oracle File
      ST = 0
      ORC_TOT_REC_01 = 0
      IS_TRAILER = .FALSE.
C
      DO WHILE(ST .EQ. 0)
C
        CALL READ_ORC_FILE(ST)
        IF(ST .EQ. EOF) THEN
          IF(ORC_TOT_REC_01 .EQ. 0) THEN
            ORC_ERR_STR = IAM()//' INVALID EOF. SHOULD BE A RECORD 01'
            CALL WRITE_LOG_FILE
          ENDIF
          IF(IS_TRAILER .EQ. .FALSE.) THEN
            ORC_ERR_STR = IAM()//' INVALID EOF. SHOULD BE A TRAILER RECORD'
            CALL WRITE_LOG_FILE
          ENDIF
          GOTO 1000
        ENDIF
C
        POS=1
C
        CALL GET_REC_TYPE(POS,REC_TYPE)
C
        IF(REC_TYPE .EQ. '01') THEN
          ORC_TOT_REC_01 = ORC_TOT_REC_01+1
          CALL GET_REC_01(POS,FDB_E,FDB_P,FDB_A)
C
        ELSEIF(REC_TYPE .EQ. 'TP') THEN
          IS_TRAILER = .TRUE.
          CALL GET_VALUE(POS,8,ORC_TOT_LIN,ORC_REC)
          IF(ORC_TOT_LIN .NE. ORC_LIN_CNT) THEN
            ORC_ERR_STR = IAM()//' TOTRECS IN TRAILER NOT EQUAL TO TOTRECS IN FILE'
            CALL WRITE_LOG_FILE
          ENDIF
C
        ELSE
          ORC_ERR_STR = IAM()//' INVALID RECORD. SHOULD BE TYPE 01 OR TYPE TP'
          CALL WRITE_LOG_FILE
        ENDIF
C
      ENDDO
C
C Close Passive Emission and Plan Files
1000  CONTINUE
      CALL CLOSEFIL(FDB_E)
      CALL CLOSEFIL(FDB_P)
      CALL CLOSEFIL(FDB_A)
C
      RETURN
      END
C
C**********************
C SUBROUTINE GET_REC_01
C**********************
C GET ORACLE INTERFACE FILE BODY RECORD '01'
C
C=======OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE GET_REC_01(POS,FDB_E,FDB_P,FDB_A)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:ORCCOM.DEF'
      INCLUDE 'INCLIB:DPPREC.DEF'
      INCLUDE 'INCLIB:DPAREC.DEF'
      INCLUDE 'INCLIB:RECDAF.DEF'
C
      INTEGER*4 POS,FDB_E(7),FDB_P(7),FDB_A(7),YESNO
      INTEGER*4 ST,GNUM,GIND,WEEK,YEAR,EMIS,IND,CDC
      INTEGER*4 CLODAT,INIDAYPAY,ENDDAYPAY,MAXNUMSER
      INTEGER*4 GETDRW,GET_CDC_YYYYMMDD,GET_TIM_HHMMSS
      LOGICAL*1 WRITE_EMIS
C
      INTEGER*4 ILITDRW(6),CLITDRW_LEN/24/
      CHARACTER CLITDRW*24
      EQUIVALENCE(ILITDRW,CLITDRW)
C
      CHARACTER WWYYYY*6,DATTIM*14,PRGDAT*8
      INTEGER*4 DATTIM_LEN/14/,PRGDAT_LEN/8/
C
      COMMON /DPACOM/ DPAREC,GNUM,WRITE_EMIS
C
C Week of Draw
      CALL GET_VALUE(POS,2,WEEK,ORC_REC)
      IF(WEEK .LT. 1 .OR. WEEK .GT. PMAXWEK) THEN
        ORC_ERR_STR = IAM()//' INVALID WEEK OF DRAW. SHOULD BE UP TO '//ITOC(PMAXWEK,IND)
        CALL WRITE_LOG_FILE
      ENDIF
C
C Year of Draw
      CALL GET_VALUE(POS,4,YEAR,ORC_REC)
      IF(YEAR .LT. 2010) THEN
        ORC_ERR_STR = IAM()//' INVALID YEAR OF DRAW. SHOULD BE STARTING FROM 2010'
        CALL WRITE_LOG_FILE
      ENDIF
C
      WRITE(WWYYYY,100) WEEK,YEAR
100   FORMAT(I2.2,I4.4)
C
C Emission
      EMIS = GETDRW(YEAR,WEEK,GNUM)  !memory
      IF(EMIS .LE. 0) THEN
        CALL FIND_EMIS_ON_DSK(WEEK,YEAR,GNUM,EMIS)
        IF(EMIS .LE. 0 .AND. WRITE_EMIS .EQ. .FALSE.) THEN
          TYPE*,IAM()
          TYPE*,IAM(),'**** WARNING! ****'
          TYPE*,IAM(),'New Emission ',WWYYYY,' Will Be Configured.'
          TYPE*,IAM()
          CALL PRMYESNO('Do you want to continue [Y/N] ?',YESNO)
          IF(YESNO .NE. 1) CALL GSTOP(GEXIT_OPABORT)
        ENDIF
C
        IND = 117
        CALL GET_VALUE(IND,4,EMIS,ORC_REC)
      ENDIF
C
C Read Emission Number
      CALL READW(FDB_E,(EMIS-PAS_DRW_OFFSET),DPAREC,ST)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR READING PASSIVE EMISSION FILE STATUS ',ST
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
      DPAEMIS = EMIS
      DPADRAW = CTOI(WWYYYY,IND)
C
C Check Emission Status
      IF(DPASTS .NE. GAMNUL .AND.
     *   DPASTS .NE. GAMINF .AND.
     *   DPASTS .NE. GAMOPN) THEN
        ORC_ERR_STR = IAM()//' INVALID WEEK-YEAR OF DRAW. INCORRECT DRW STATUS'
        CALL WRITE_LOG_FILE
      ENDIF
C
      IF(DPASTS .LT. GAMOPN) DPASTS = GAMINF
C
C Draw Description
      CLITDRW = ORC_REC(POS:(POS+CLITDRW_LEN-1))
      POS = POS+CLITDRW_LEN
C
      CALL FASTMOV(ILITDRW,DPALITDRW,6)
C
C Draw Opening Date
      DATTIM = ORC_REC(POS:(POS+DATTIM_LEN-1))
      POS = POS+DATTIM_LEN
C
      DPABSD = GET_CDC_YYYYMMDD(DATTIM(1:8))
C
C Draw Closing Date
      DATTIM = ORC_REC(POS:(POS+DATTIM_LEN-1))
      POS = POS+DATTIM_LEN
C
      CLODAT = GET_CDC_YYYYMMDD(DATTIM(1:8))
      IF(CLODAT .LT. DPABSD) THEN
        ORC_ERR_STR = IAM()//' INVALID CLOSE DATE. DRAW CLOSES BEFORE IS OPEN'
        CALL WRITE_LOG_FILE
      ENDIF
C
      DPATIM = GET_TIM_HHMMSS(DATTIM(9:14))
C
      IF(WRITE_EMIS .EQ. .TRUE.) GOTO 1000
C
C Check If Between Sales Period
      IF(DAYCDC .GE. DPABSD .AND. DAYCDC .LE. CLODAT) THEN
        TYPE*,IAM()
        TYPE*,IAM(),'**** WARNING! ****'
        TYPE*,IAM(),'Sales Have Started For Emission ',WWYYYY,'.'
        TYPE*,IAM()
        CALL PRMYESNO('Do you want to continue [Y/N] ?',YESNO)
        IF(YESNO .NE. 1) CALL GSTOP(GEXIT_OPABORT)
      ENDIF
C
C Draw Date
1000  CONTINUE
      DATTIM = ORC_REC(POS:(POS+DATTIM_LEN-1))
      POS = POS+DATTIM_LEN
C
      DPAESD = GET_CDC_YYYYMMDD(DATTIM(1:8))
      IF(DPAESD .NE. CLODAT) THEN
        ORC_ERR_STR = IAM()//' INVALID DRAW DATE. SHOULD BE EQUAL TO CLOSE DATE'
        CALL WRITE_LOG_FILE
      ENDIF
C
C Draw Start Paying Date
      DATTIM = ORC_REC(POS:(POS+DATTIM_LEN-1))
      POS = POS+DATTIM_LEN
C
      INIDAYPAY = GET_CDC_YYYYMMDD(DATTIM(1:8))
      IF(INIDAYPAY .NE. DPAESD) THEN
        ORC_ERR_STR = IAM()//' INVALID START PAY DATE. SHOULD BE EQUAL TO DRW DATE'
        CALL WRITE_LOG_FILE
      ENDIF
C
C Draw End Paying Date
      DATTIM = ORC_REC(POS:(POS+DATTIM_LEN-1))
      POS = POS+DATTIM_LEN
C
      ENDDAYPAY = GET_CDC_YYYYMMDD(DATTIM(1:8))
      IF(ENDDAYPAY .LT. INIDAYPAY) THEN
        ORC_ERR_STR = IAM()//' INVALID END PAY DATE. IS LOWER THAN START PAY DATE'
        CALL WRITE_LOG_FILE
      ENDIF
C
      DPAMAXDAYPAY = ENDDAYPAY-INIDAYPAY
C
C Prize Plan
      CALL GET_VALUE(POS,4,DPAPLAN,ORC_REC)
C
C Draw Purge Date
      PRGDAT = ORC_REC(POS:(POS+PRGDAT_LEN-1))
      POS = POS+PRGDAT_LEN
C
      DPAPRGCDC = GET_CDC_YYYYMMDD(PRGDAT)
C
      IF(DPAESD + DPAMAXDAYPAY .GT. DPAPRGCDC) THEN
        ORC_ERR_STR = IAM()//' INVALID PURGE DATE. SHOULD BE HIGHER THAN END PAY'
        CALL WRITE_LOG_FILE
      ENDIF
C
      IF(DPAESD .GE. DPAPRGCDC) THEN
        ORC_ERR_STR = IAM()//' INVALID PURGE DATE. SHOULD BE HIGHER THAN DRAW DATE'
        CALL WRITE_LOG_FILE
      ENDIF
C
C Number of Series
      CALL GET_VALUE(POS,2,DPANUMSER,ORC_REC)
C
      MAXNUMSER = 0
      GIND = GNTTAB(GAMIDX,GNUM)
      IF((GIND .EQ. PSBCLA) .AND.
     *   (DPANUMSER .LT. 1 .OR. DPANUMSER .GT. pmaxsercla)) MAXNUMSER = pmaxsercla
      IF((GIND .EQ. PSBPOP) .AND.
     *   (DPANUMSER .LT. 1 .OR. DPANUMSER .GT. pmaxserpop)) MAXNUMSER = pmaxserpop
      IF(MAXNUMSER .NE. 0) THEN
        ORC_ERR_STR = IAM()//' INVALID NUMBER OF SERIES. SHOULD BE UP TO '//ITOC(MAXNUMSER,IND)
        CALL WRITE_LOG_FILE
      ENDIF
C
C Draw Number
      CALL GET_VALUE(POS,4,EMIS,ORC_REC)
      IF(EMIS .NE. DPAEMIS) THEN
        ORC_ERR_STR = IAM()//' INVALID DRAW NUMBER. SHOULD BE EQUAL TO '//ITOC(DPAEMIS,IND)
        CALL WRITE_LOG_FILE
      ENDIF
C
C Read Plan Id Number
      CALL READW(FDB_P,DPAPLAN,DPPREC,ST)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR READING PASSIVE PLAN FILE STATUS ',ST
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
C Check for Valid Plan Id Number
      IF(DPPNUMTCK .EQ. 0 .OR. DPPDIV .EQ. 0) THEN
        ORC_ERR_STR = IAM()//' INVALID PRIZE PLAN ID. PLAN IS NOT YET CONFIGURED'
        CALL WRITE_LOG_FILE
      ENDIF
C
C Copy Plan Info into Emission Info
      DPAPRC    = DPPPRC
      DPADIV    = DPPDIV
      DPANUMTCK = DPPNUMTCK
      DPANOFFRA = DPPNOFFRA
      DPAEMT    = DPPPLT
      CALL FASTMOV(DPPSHR,DPASHR,PAGDIV)
      CALL FASTMOV(DPPSHV,DPASHV,PAGDIV*2)
      CALL FASTMOV(DPPEXSHR,DPAEXSHR,PAGEDV)
      CALL FASTMOV(DPPEXSHV,DPAEXSHV,PAGEDV*2)
      CALL FASTMOV(DPPTYP,DPATYP,PAGDIV)
      CALL FASTMOV(DPPDIG,DPADIG,PAGDIV)
      CALL FASTMOV(DPPIDNUM,DPAIDNUM,PAGDIV)
      CALL FASTMOV(DPPWNUM,DPAWNUM,PAGDIV)
C
C Write Passive Emission File and Daily Activity File
      IF(WRITE_EMIS .EQ. .TRUE. .AND. ORC_ERR_CNT .EQ. 0) THEN
        DPACHGCDC = DAYCDC
C
        CALL WRITEW(FDB_E,(DPAEMIS-PAS_DRW_OFFSET),DPAREC,ST)
        IF(ST .NE. 0) THEN
          TYPE*,IAM(),'ERROR WRITING PASSIVE EMISSION FILE STATUS ',ST
          CALL GSTOP(GEXIT_FATAL)
        ENDIF
C
        DO CDC=DPABSD,DPAESD
          CALL READW(FDB_A,CDC,DAFREC,ST)
          IF(ST .NE. 0 .AND. ST .NE. 144) THEN
            TYPE*,IAM(),'ERROR READING ACTIVITY FILE STATUS ',ST
            CALL GSTOP(GEXIT_FATAL)
          ENDIF
          IF(ST .EQ. 144) GOTO 2000
C
          IF(DAFDRW(GNUM) .EQ. 0 .OR. DAFDRW(GNUM) .GT. DPAEMIS) THEN
            DAFDRW(GNUM)=DPAEMIS
            DAFHDR(GNUM)=DPAEMIS
C
            CALL WRITEW(FDB_A,CDC,DAFREC,ST)
            IF(ST .NE. 0 .AND. ST .NE. 144) THEN
              TYPE*,IAM(),'ERROR WRITING ACTIVITY FILE STATUS ',ST
              CALL GSTOP(GEXIT_FATAL)
            ENDIF
            IF(ST .EQ. 144) GOTO 2000
          ENDIF
        ENDDO
      ENDIF
C
2000  CONTINUE
      RETURN
      END
C
C****************************
C SUBROUTINE FIND_EMIS_ON_DSK
C****************************
C FIND EMISSION NUMBER ON DISK
C
C=======OPTIONS /CHECK=NOOVERFLOW
      SUBROUTINE FIND_EMIS_ON_DSK(WEEK,YEAR,GNUM,EMIS)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:STANDARD.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:CONCOM.DEF'
      INCLUDE 'INCLIB:DPAREC.DEF'
C
      INTEGER*4 WEEK,YEAR,GNUM,EMIS
      INTEGER*4 ST,UNIT,FDB(7)
      INTEGER*4 DRW,DRW_WEEK,DRW_YEAR
C
      CALL FIND_AVAILABLE_LUN(UNIT,ST)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR GETTING LOGICAL UNIT FOR PASSIVE EMISSION FILE'
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
      CALL OPENW(UNIT,GFNAMES(1,GNUM),4,0,0,ST)
      CALL IOINIT(FDB,UNIT,DPASEC*256)
      IF(ST .NE. 0) THEN
        TYPE*,IAM(),'ERROR OPENING PASSIVE EMISSION FILE STATUS ',ST
        CALL GSTOP(GEXIT_FATAL) 
      ENDIF
C
      ST = 0
      DRW = 1
      DO WHILE(ST .EQ. 0)
        CALL READW(FDB,(DRW-PAS_DRW_OFFSET),DPAREC,ST)
        IF(ST .NE. 0) THEN
          IF(ST .EQ. EOF) GOTO 1000
          TYPE*,IAM(),'ERROR READING PASSIVE EMISSION FILE STATUS ',ST
          CALL GSTOP(GEXIT_FATAL) 
        ENDIF
C
        CALL GETPASDRW(DPADRAW,DRW_WEEK,DRW_YEAR)
        IF(DRW_WEEK .EQ. WEEK .AND. DRW_YEAR .EQ. YEAR) THEN
          EMIS = DRW
          GOTO 1000
        ELSE
          DRW = DRW+1
        ENDIF
      ENDDO
C
1000  CONTINUE
      CALL CLOSEFIL(FDB)
C
      RETURN
      END
C
C****************************
C SUBROUTINE GET_CDC_YYYYMMDD
C****************************
C GET CDC DATE FROM YYYYMMDD
C
C=======OPTIONS /CHECK=NOOVERFLOW
      INTEGER*4 FUNCTION GET_CDC_YYYYMMDD(INPDATE)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:DATBUF.DEF'
C
      CHARACTER INPDATE*8
C
      INTEGER*2 DATE(12)
      INTEGER*4 IND
C
      DATE(VYEAR) = CTOI(INPDATE(1:4),IND)
      DATE(VMON)  = CTOI(INPDATE(5:6),IND)
      DATE(VDAY)  = CTOI(INPDATE(7:8),IND)
C
      CALL BDATE(DATE)
C
      GET_CDC_YYYYMMDD = DATE(VCDC)
C
      RETURN
      END
C
C**************************
C SUBROUTINE GET_TIM_HHMMSS
C**************************
C GET TIME IN SECS FROM HHMMSS
C
C=======OPTIONS /CHECK=NOOVERFLOW
      INTEGER*4 FUNCTION GET_TIM_HHMMSS(INPTIME)
      IMPLICIT NONE
C
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
      CHARACTER INPTIME*6
      INTEGER*4 HOUR,MINS,SECS,IND
C
      HOUR = CTOI(INPTIME(1:2),IND)
      MINS = CTOI(INPTIME(3:4),IND)
      SECS = CTOI(INPTIME(5:6),IND)
C
C
      GET_TIM_HHMMSS = HOUR*3600 + MINS*60 +SECS
C
      RETURN
      END
