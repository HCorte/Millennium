C SUBROUTINE CALODD
C
C V22 16-JUN-2000 OXK Cleanup w/ WARNINGS=ALL
C V21 17 Apr 1996 HXK Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C V20 15 Mar 1996 HXK Putting Rita's fixes (RXK) into PVCS archive
C V19 11 Mar 1996 RXK Calculation of odds of Today's Couple fixed 
C V18 28 Feb 1996 RXK Lost calculation of other pools fixed again (Rfss 95234)
C V17 24 Jan 1996 HXK Fix for Couple Odds sort to allow evA row = evB row
C V16 24 Jan 1996 HXK Fix for odds
C V15 21 Jan 1996 HXK First part of sorting out sort
C V14 11 Jan 1996 HXK Fix for floating point error
C V13 22 Dec 1995 HXK Fix for overwriting BITMAP variable
C V12 20 Dec 1995 HXK Fix for fastmov of DBPSORT
C V11 20 Dec 1995 HXK Removed TYPE* statement
C V10 20 Dec 1995 HXK Various fixes as part of the Double / Couple installation
C V09 10 Dec 1995 HXK Some tidying up
C V08 23 Nov 1995 HXK Merge of post 65 stuff; changes for Double/Couple
C V07 08 Nov 1995 HXK Removed DLEN
C V06 07 Nov 1995 HXK Changes for Double, Couple install
C V05 29 Jan 1994 HXK ODDS NO LONGER TRUNCATED.
C V04 21 Jan 1993 DAB Initial Release
C  			Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  			DEC Baseline
C V03 14-AUG-1992 GCAN REMOVED AMOUNT FILED FOR OUTSIDE SCORES FOR SCORE,
C		     TO BE ABLE TO FIT ALL DATA IN ONE MESSAGE.
C V02 28-APR-1992 GCAN CANGED LOGIC. DO NOT SEND BUFFER TO COM HERE,
C                    ONLY BUILD IT. SEND FROM ODSPRO OR UNSPRO.
C		     ALSO ADDED ODDS UPDATE TIME TO ODDS MESSAGE.
C V01 22-NOV-1991 GCAN INITIAL RELEASE FOR THE NETHERLANDS
C
C THE PURPOSE OF THIS PROGRAM IS TO CALCULATE THE ODDS FOR A GIVEN
C GAME TYPE AND GAME INDEX. EACH OF THE WIN TIP AND SCORE POOLS
C HAVE A DYNAMIC AREA AND A STATIC AREA. THE DYNAMIC AREA IS UPDATED
C ALWAYS DURING WAGERING. THE STATIC AREA IS USED ONLY TO CALCULATE
C ODDS ONCE THE DYNAMIC SALES TOTALS HAVE BEEN MOVED OVER TO IT.
C AFTER THE ODDS HAVE BEEN CALCULATED A MESSAGE IS BUILT WITH ALL ODDS 
C THAT HAVE CHANGED SINCE LAST TIME.
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 2000 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW/EXT
	SUBROUTINE CALODD(TRABUF,MESTAB,MESLEN,ALLFLG)
C
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:SCRCOM.DEF'
	INCLUDE 'INCLIB:WITCOM.DEF'
	INCLUDE 'INCLIB:DBLCOM.DEF'
	INCLUDE 'INCLIB:CPLCOM.DEF'
	INCLUDE 'INCLIB:CHKSUMCM.DEF'
C
        REAL*8	    TOTAL			!Total Sales for Game
	REAL*8	    RODDS    			!Odds / Row
C
	BYTE	    MESTAB(*)			!Output Message Table
	BYTE	    CHKTAB(OUTLEN_MAX)		!Table to Checksum all odds.
	BYTE	    BITMAP(6)			!Bitmap of Rows Sent
	BYTE	    CTL				!Control / Sequence
	BYTE	    TYP				!Message Type
	BYTE	    I1TEMP(4)			!Temp. Variable
C
	INTEGER*2   MESLEN			!Message Length
C
	INTEGER*4   INDTAB(MAXD)		!All Regular Scores to Send
	INTEGER*4   OVRTAB(MAXO)		!All Outside Scores to Send
	INTEGER*4   HSCORE			!Home Score #
	INTEGER*4   ASCORE			!Away Score #
	INTEGER*4   GTYPE			!Game Type
	INTEGER*4   GINDX			!Game Index
	INTEGER*4   GNUM			!Game Number
	INTEGER*4   IODDS			!Integer Value of Odds
	INTEGER*4   IND				!Index into Message Table.
	INTEGER*4   BITMAP_IND			!Index to save BITMAP at.
	INTEGER*4   CHKIND			!Index into Checksum Table.
	INTEGER*4   CHKLEN			!Length of checksumed buffer.
	INTEGER*4   MYCHKSUM			!Checksum Value of Message.
	INTEGER*4   I4TEMP			!Temp. Variable
	INTEGER*4   I				!Loop Variables
	INTEGER*4   TIMBUF(3)			!Time Buffer (HH:MM:SS)
	INTEGER*4   TIECNT			!Tie score counter.

	INTEGER*4   LOCAL_DBPSORT(2,MAXDBLRW*MAXDBLRW)
	INTEGER*4   LOCAL_CPPSORT(2,MAXCPLRW/2*MAXCPLRW/2)
C
	LOGICAL	    SNDODS			!Send Odds (They have changed)
	LOGICAL	    ALLFLG			!Odds Force Flag, Send ALL odds
C                                               !if flag is set.
	LOGICAL	    REQFLG			!Terminal Requested Odds.
	LOGICAL	    SKIPIT			!Skip this data flag.
C
	EQUIVALENCE (I4TEMP,I1TEMP)
C
C
	DATA	    CTL/Z20/			
	DATA	    TYP/ZB0/			
C
C SET / CLEAR VARIABLES
C
	ALLFLG = .TRUE.   !always set odds
	REQFLG = .FALSE.
	IF(TRABUF(TTER).GT.0) REQFLG = .TRUE.  !Determine if terminal Request.
C
	TOTAL = 0.0D0
	TIECNT= 0
	DO 10 I = 1,OUTLEN_MAX
	   CHKTAB(I) = 0
10	CONTINUE
C
C IF TERMINAL REQUESTED ODDS SET SEND FLAG ELSE CLEAR IT.
C
	IF(REQFLG) THEN
	   SNDODS = .TRUE.
	ELSE
	   SNDODS = .FALSE.
	ENDIF
C
C IF TERMINAL REQUESTED ODDS SET ALL BITTS, ELSE CLEAR THEM.
C
	DO 20 I = 1,6
	   IF(REQFLG) THEN
	      BITMAP(I) = 'FF'X
	   ELSE
	      BITMAP(I) = 0
	   ENDIF
20	CONTINUE
C
	GTYPE = TRABUF(TGAMTYP)
	GINDX = TRABUF(TGAMIND)
	IF(GTYPE.LT.1.OR.GTYPE.GT.MAXTYP) RETURN
	IF(GINDX.LT.1.OR.GINDX.GT.MAXIND) RETURN
C
	GOTO ( 9000, 9000, 9000, 9000, 5000, 6000, 7000, 9000, 9000, 9000, 
     *         9000, 9000,13000, 9000) GTYPE
C
	RETURN                   !GAME TYPE OUT OF RANGE


C PROCESS DOUBLE ODDS UPDATE
C -------------------------
5000	CONTINUE
C
C GET AND CHECK GAME NUMBER
C
	GNUM = GTNTAB(TDBL,GINDX)
	IF(GNUM.LT.1.OR.GNUM.GT.MAXGAM) RETURN
C
C IF TERMINAL REQUESTED ODDS, SKIP CALCULATING PART, GO FORMAT MESSAGE.
C
	IF(REQFLG) THEN
	   GOTO 5250
	ENDIF
C
C MOVE DYNAMIC SALES DATA TO STATIC AREA AND ACCUMULATE TOTAL
C
	DO 5100 I = 1,MAXDBLRW*MAXDBLRW
	   DBPOOL(I,DBLPAMNT,DBLPSTAT,GINDX)=DBPOOL(I,DBLPAMNT,DBLPDYNM,GINDX)
      	   IF(DBLSTA((I-1)/MAXDBLRW+1,GINDX).GT.GAMBFD) GOTO 5100
      	   IF(DBLSTA(MOD(I-1,MAXDBLRW)+1,GINDX).GT.GAMBFD) GOTO 5100

	   IF(DBPOOL(I,DBLPAMNT,DBLPSTAT,GINDX).GE.0) THEN
	      TOTAL = TOTAL + 
     *                DFLOAT(DBPOOL(I,DBLPAMNT,DBLPSTAT,GINDX) * DYN_BETUNIT)
	   ENDIF

5100	CONTINUE
	TOTAL = (TOTAL * CALPER(DBLSPR(GINDX))) + DBLPOL(1,GINDX) * DYN_BETUNIT
C
C CALCULATE ODDS FOR DOUBLE GAME
C
	DO 5200 I = 1,MAXDBLRW*MAXDBLRW
	   IF(DBPOOL(I,DBLPAMNT,DBLPSTAT,GINDX).LE.0) THEN
	      RODDS = 99999
	   ELSE
	      RODDS = TOTAL / (DBPOOL(I,DBLPAMNT,DBLPSTAT,GINDX) *
     *		      DYN_BETUNIT) * 100
	   ENDIF
	   IODDS = NINT(RODDS)
	   IF(IODDS.LT.100) IODDS = 100
	   IF(IODDS.GT.99999) IODDS = 99999
	   IF(DBLSTA((I-1)/MAXDBLRW+1,GINDX).EQ.GAMCAN.OR.
     *	      DBLSTA((I-1)/MAXDBLRW+1,GINDX).EQ.GAMBFD.OR.
     *	      DBLSTA((I-1)/MAXDBLRW+1,GINDX).EQ.GAMREF.OR.
     *	      DBLSTA((I-1)/MAXDBLRW+1,GINDX).EQ.GAMNUL.OR.
     *        DBLSTA(MOD(I-1,MAXDBLRW)+1,GINDX).EQ.GAMCAN.OR.
     *	      DBLSTA(MOD(I-1,MAXDBLRW)+1,GINDX).EQ.GAMBFD.OR.
     *	      DBLSTA(MOD(I-1,MAXDBLRW)+1,GINDX).EQ.GAMREF.OR.
     *	      DBLSTA(MOD(I-1,MAXDBLRW)+1,GINDX).EQ.GAMNUL)    THEN
	      IODDS = 0
	   ENDIF

	   DBPOOL(I,DBLPODDS,DBLPSTAT,GINDX) = IODDS

           LOCAL_DBPSORT(1,I) = DBPOOL(I,DBLPAMNT,DBLPSTAT,GINDX)
	   IF(DBLSTA((I-1)/MAXDBLRW+1,GINDX).EQ.GAMNUL.OR.
     *        DBLSTA(MOD(I-1,MAXDBLRW)+1,GINDX).EQ.GAMNUL)    THEN
	      LOCAL_DBPSORT(1,I) = -1
	   ENDIF
	   IF(((I-1)/MAXDBLRW)+1.EQ.MOD(I-1,MAXDBLRW)+1)    THEN
	      LOCAL_DBPSORT(1,I) = -2
	   ENDIF
           LOCAL_DBPSORT(2,I) = I

5200	CONTINUE
C
C SORT ON ODDS FOR DOUBLE
C
        CALL ISORT(LOCAL_DBPSORT,MAXDBLRW*MAXDBLRW)
	CALL FASTMOV(LOCAL_DBPSORT,DBPSORT(1,1,GINDX),2*MAXDBLRW*MAXDBLRW)

C
5250	CONTINUE
C
	IF(.NOT.SNDODS) RETURN			    !Only Send if Changed.
	IF(P(SYSTYP).NE.LIVSYS.OR.DAYSTS.NE.DSOPEN) RETURN
C
	IF(.TRUE.) RETURN     !do NOT send to network in Finland
CV22C
CV22C BUILD OUTPUT MESSAGE TO THE NETWORK
CV22C (CORRECT SEQUENCE NUMBER WILL BE SET IN UNSPRO TYPREG TRANSACTIONS).
CV22C
CV22	IND = 7
CV22	CHKIND = 1
CV22	MESTAB(  1) = CTL			!CONTROL / SEQUENCE
CV22	MESTAB(  2) = TYP + TDBL		!TYPE / SUBTYPE
CV22	CALL ICLOCK(0,TIMBUF)			!TIME (HH:MM:SS)
CV22	CALL ISBYTE(TIMBUF(1),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	CALL ISBYTE(TIMBUF(2),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	CALL ISBYTE(TIMBUF(3),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	MESTAB(IND) = GINDX			!GAME INDEX
CV22	IND = IND + 1
CV22	I4TEMP = P(ODSUPD)			!ODDS UPDATE TIME
CV22	CALL REVBYT(I4TEMP,2,MESTAB,IND,2)
CV22	IND = IND + 2
CV22	BITMAP_IND = IND
CV22	IND = IND + 6
CV22C
CV22C STUFF ODDS INTO THE OUTPUT BUFFER (ONLY ROWS THAT HAVE CHANGED)
CV22C ALSO STUFF ODDS INTO CHECKSUM TABLE (ALL ROWS!!!)
CV22C
CV22	DO 5300 I = 0,(MAXDBLRW*MAXDBLRW) - 1
CV22	   CALL REVBYT(DBPOOL(I+1,DBLPODDS,DBLPSTAT,GINDX),
CV22     *		       3,CHKTAB,CHKIND,3)
CV22	   CHKIND = CHKIND + 3
CV22C
CV22C IF ODDS ARE REQUESTED DO NOT SEND ODDS THAT ARE ZERO (NOT ACTIVE)
CV22C
CV22	   IF(REQFLG.AND.DBPOOL(I+1,DBLPODDS,DBLPSTAT,GINDX).EQ.0) 
CV22     *        CALL CLRBIT_BSTRNG(BITMAP,I)
CV22C
CV22	   IF(.NOT.TSTBIT_BSTRNG(BITMAP,I)) GOTO 5300
CV22	   CALL REVBYT(DBPOOL(I+1,DBLPODDS,DBLPSTAT,GINDX),
CV22     *		       3,MESTAB,IND,3)
CV22	   IND = IND + 3
CV225300	CONTINUE
CV22	MESLEN = IND - 1
CV22	CHKIND = CHKIND - 1
CV22C
CV22C PUT BITMAP INTO MESSGAE (AT PREVIOUSLY SAVED POSSITION)
CV22C
CV22	CALL MOVBYT(BITMAP,1,MESTAB,BITMAP_IND,6) !6 BYTE BITMAP
CV22C
CV22C CALCULATE CHECKSUM ON ALL ODDS (CHECKSUM TABLE).
CV22C THEN STICK IT INTO THE MESSAGE.
CV22C
CV22	CHKLEN = CHKIND 
CV22	CALL GETCCITT(CHKTAB,0,CHKLEN,MYCHKSUM)
CV22	I4CCITT = MYCHKSUM
CV22	MESTAB(5) = I1CCITT(2)
CV22	MESTAB(6) = I1CCITT(1)
CV22C
CV22C CALCULATE CHECKSUM ON OUTPUT BUFFER
CV22C
CV22	CHKLEN = MESLEN - 1
CV22	I4CCITT = 0
CV22	MESTAB(3) = I1CCITT(2)
CV22	MESTAB(4) = I1CCITT(1)
CV22	CALL GETCCITT(MESTAB,1,CHKLEN,MYCHKSUM)
CV22	I4CCITT = MYCHKSUM
CV22	MESTAB(3) = I1CCITT(2)
CV22	MESTAB(4) = I1CCITT(1)
CV22C
CV22C
CV22	RETURN
C
C PROCESS SCORE ODDS UPDATE
C
6000    CONTINUE
C
C GET AND CHECK GAME NUMBER
C
        GNUM=GTNTAB(TSCR,GINDX)
        IF(GNUM.LT.1.OR.GNUM.GT.MAXGAM) RETURN
C
C IF TERMINAL REQUESTED ODDS, SKIP CALCULATING PART, GO FORMAT MESSAGE.
C
        IF(REQFLG) GOTO 6250
C
C MOVE DYNAMIC SALES DATA TO STATIC AREA
C
        DO 6100 I = 1,SLEN
           SCPOOL(I,SPAMNT,SPSTAT,GINDX) = SCPOOL(I,SPAMNT,SPDYNM,GINDX)
           TOTAL = TOTAL + SCPOOL(I,SPAMNT,SPSTAT,GINDX) * DYN_BETUNIT
6100    CONTINUE
        TOTAL = (TOTAL * CALPER(SCRSPR(GINDX))) + SCRPOL(1,GINDX) * DYN_BETUNIT
C
C SORT ON SCORES FOR SOCCER AND SORT ON ODDS FOR HOCKEY
C
        CALL SRTPOL(GINDX,INDTAB,OVRTAB)
C
        DO 6200 I = 1,MAXD
           DPOOL(I,SPSCOR,GINDX) = INDTAB(I)
           DPOOL(I,SPDAMT,GINDX) = SCPOOL(INDTAB(I),SPAMNT,SPSTAT,GINDX)
           IF(DPOOL(I,SPDAMT,GINDX).EQ.0) THEN
              RODDS = 99999                     ! IF NO INVESTMENT
           ELSE
              RODDS = TOTAL / (DPOOL(I,SPDAMT,GINDX) *
     *                DYN_BETUNIT) * 100
           ENDIF
           IODDS = NINT(RODDS)
           IF(IODDS.LT.100) IODDS = 100    ! MINIMUM ODD 1 TO 1
           IF(IODDS.GT.99999) IODDS = 99999
C
C
C CHECK IF NEW CALCULATED ODDS IS DIFFERENT FROM OLD STATIC ODDS
C IF DIFFERENT SET SEND BITMAP AND UPDATE ODDS IN STATIC AREA.
C
           IF(IODDS.NE.DPOOL(I,SPDODS,GINDX).OR.ALLFLG) THEN
              DPOOL(I,SPDODS,GINDX) = IODDS
              CALL SETBIT_BSTRNG(BITMAP,I-1)
              SNDODS = .TRUE.
           ENDIF
C
6200    CONTINUE
C
C UPDATE OTHER POOLS
C
        DO 6210 I = 1,MAXO
           OPOOL(I,SPSCOR,GINDX) = OVRTAB(I)
           OPOOL(I,SPDAMT,GINDX) = SCPOOL(OVRTAB(I),SPAMNT,SPSTAT,GINDX)
           IF(OPOOL(I,SPDAMT,GINDX).EQ.0) THEN
              RODDS = 99999                     ! IF NO INVESTMENT
           ELSE
              RODDS = TOTAL / OPOOL(I,SPDAMT,GINDX) * (100/DYN_BETUNIT)
           ENDIF
           IODDS = NINT(RODDS)
           IF(IODDS.LT.100) IODDS = 100
           IF(IODDS.GT.99999) IODDS = 99999
C
C CHECK IF NEW CALCULATED ODDS IS DIFFERENT FROM OLD STATIC ODDS
C IF DIFFERENT SET SEND BITPAM AND UPDATE ODDS IN STATIC AREA.
C
           IF(IODDS.NE.OPOOL(I,SPDODS,GINDX).OR.ALLFLG) THEN
              OPOOL(I,SPDODS,GINDX) = IODDS
              CALL SETBIT_BSTRNG(BITMAP,MAXD+I-1)
              SNDODS = .TRUE.
           ENDIF
C
6210    CONTINUE
C
        IF(.NOT.SNDODS) RETURN                      !Only Changed ones.
        IF(P(SYSTYP).NE.LIVSYS.OR.DAYSTS.NE.DSOPEN) RETURN
C
	IF(.TRUE.) RETURN      !do NOT send to network for Finland
C
C
C BUILD OUTPUT MESSAGE TO NETWORK
C (CORRECT SEQUENCE NUMBER WILL BE SET IN UNSPRO TYPREG TRANSACTIONS).
C
6250    CONTINUE
        IND = 7
        CHKIND = 1
        MESTAB(  1) = CTL                       !CONTROL / SEQUENCE
        MESTAB(  2) = TYP + TSCR                !TYPE / SUBTYPE
        CALL ICLOCK(0,TIMBUF)                   !TIME (HH:MM:SS)
        CALL ISBYTE(TIMBUF(1),MESTAB,IND-1)
        IND = IND + 1
        CALL ISBYTE(TIMBUF(2),MESTAB,IND-1)
        IND = IND + 1
        CALL ISBYTE(TIMBUF(3),MESTAB,IND-1)
        IND = IND + 1
        MESTAB(IND) = GINDX                     !GAME INDEX
        IND = IND + 1
        I4TEMP = P(ODSUPD)                      !ODDS UPDATE TIME
        CALL REVBYT(I4TEMP,2,MESTAB,IND,2)
        IND = IND + 2
        BITMAP_IND = IND
        IND = IND + 6
C
C LOOP FOR ALL DISPLAYD COMBINATIONS
C
        DO 6300 I = 1,MAXD
C
C STUFF HOME AND AWAY SCORE INTO CHECKSUM TABLE (ALL SCORES)
C FOR SCORES GREATER THEN OUTSIDE START SCORES STAORE AS ZEROS
C (BOTH SCORES AND ODDS) THE TERMINAL ALLWAYS CHECKSUMS FULL LENGHT
C OF DATA (MAXD + MAXO)
C
           SKIPIT = .FALSE.
           CALL INDPOL(HSCORE,ASCORE,DPOOL(I,SPSCOR,GINDX))
           IF(HSCORE.EQ.ASCORE) THEN
              TIECNT = TIECNT + 1
              IF(TIECNT.GT.STSCO ) THEN
                 SKIPIT = .TRUE.
                 CALL CLRBIT_BSTRNG(BITMAP,I-1)
              ENDIF
           ENDIF
C
           IF(SKIPIT) THEN
              HSCORE = 0
              ASCORE = 0
           ENDIF
C
           CHKTAB(CHKIND+0) = ZEXT(HSCORE)
           CHKTAB(CHKIND+1) = ZEXT(ASCORE)
           CHKIND = CHKIND + 2
C
C STUFF THE ODDS INTO CHECKSUM TABLE (ALL ODDS)
C
           I4TEMP = DPOOL(I,SPDODS,GINDX)
           IF(SKIPIT) I4TEMP = 0
           CHKTAB(CHKIND+0) = I1TEMP(3)
           CHKTAB(CHKIND+1) = I1TEMP(2)
           CHKTAB(CHKIND+2) = I1TEMP(1)
           CHKIND = CHKIND + 3

C
C
C STUFF HOME AND AWAY SCORE INTO THE OUTPUT BUFFER (ONLY CHANGED ONES)
C IF ODDS ARE REQUESTED DO NOT SEND ODDS THAT ARE ZERO (NOT ACTIVE)
C
           IF(REQFLG.AND.DPOOL(I,SPDODS,GINDX).EQ.0)
     *        CALL CLRBIT_BSTRNG(BITMAP,I-1)
C
           IF(.NOT.TSTBIT_BSTRNG(BITMAP,I-1)) GOTO 6300
C
           MESTAB(IND+0) = ZEXT(HSCORE)
           MESTAB(IND+1) = ZEXT(ASCORE)
           IND = IND + 2
C
C STUFF THE ODDS INTO THE OUTPUT BUFFER
C
           I4TEMP = DPOOL(I,SPDODS,GINDX)
           MESTAB(IND+0) = I1TEMP(3)
           MESTAB(IND+1) = I1TEMP(2)
           MESTAB(IND+2) = I1TEMP(1)
           IND = IND + 3
C
6300    CONTINUE
C
C LOOP FOR ALL OUTSIDE DISPLAYED COMBINATIONS
C NOTE! DO NOT SEND SCORE FILEDS (TO BE ABLE TO FIT IN ONE MESSAGE).
C
        DO 6400 I = 1,MAXO
C
C STUFF THE ODDS INTO THE CHCKSUM TABLE.
C
           I4TEMP = OPOOL(I,SPDODS,GINDX)
           CHKTAB(CHKIND+0) = I1TEMP(3)
           CHKTAB(CHKIND+1) = I1TEMP(2)
           CHKTAB(CHKIND+2) = I1TEMP(1)
           CHKIND = CHKIND + 3
C
C
C IF ODDS ARE REQUESTED DO NOT SEND ODDS THAT ARE ZERO (NOT ACTIVE)
C
           IF(REQFLG.AND.OPOOL(I,SPDODS,GINDX).EQ.0)
     *        CALL CLRBIT_BSTRNG(BITMAP,MAXD+I-1)
C
           IF(.NOT.TSTBIT_BSTRNG(BITMAP,MAXD+I-1)) GOTO 6400
C
C STUFF THE ODDS INTO THE OUTPUT BUFFER
C
           I4TEMP = OPOOL(I,SPDODS,GINDX)
           MESTAB(IND+0) = I1TEMP(3)
           MESTAB(IND+1) = I1TEMP(2)
           MESTAB(IND+2) = I1TEMP(1)
           IND = IND + 3
C
6400    CONTINUE
C
C PUT BITMAP INTO MESSAGE (AT PREVIOUSLY SAVED POSSITION)
C
        CALL MOVBYT(BITMAP,1,MESTAB,BITMAP_IND,6)       !6 BYTE BITMAP
C
C CALCULATE CHECKSUM ON ALL ODDS (CHECKSUM TABLE).
C THEN STICK IT INTO THE MESSAGE.
C
        CHKIND = CHKIND - 1
        CHKLEN = CHKIND
        CALL GETCCITT(CHKTAB,0,CHKLEN,MYCHKSUM)
        I4CCITT = MYCHKSUM
        MESTAB(5) = I1CCITT(2)
        MESTAB(6) = I1CCITT(1)
C
C CALCULATE CHECK SUM ON OUTPUT BUFFER
C
        MESLEN = IND - 1
        CHKLEN = MESLEN - 1
        I4CCITT = 0
        MESTAB(3) = I1CCITT(2)
        MESTAB(4) = I1CCITT(1)
        CALL GETCCITT(MESTAB,1,CHKLEN,MYCHKSUM)
        I4CCITT = MYCHKSUM
        MESTAB(3) = I1CCITT(2)
        MESTAB(4) = I1CCITT(1)
C
	RETURN
C
C PROCESS WIN TIP ODDS UPDATE
C ---------------------------
7000	CONTINUE
C
C GET AND CHECK GAME NUMBER
C
	GNUM = GTNTAB(TWIT,GINDX)
	IF(GNUM.LT.1.OR.GNUM.GT.MAXGAM) RETURN
C
C IF TERMINAL REQUESTED ODDS, SKIP CALCULATING PART, GO FORMAT MESSAGE.
C
	IF(REQFLG) THEN
C***	   TYPE*,IAM(),'REQUESTED BY TER: ',TRABUF(TTER)
	   GOTO 7250
	ENDIF
C
C MOVE DYNAMIC SALES DATA TO STATIC AREA AND ACCUMULATE TOTAL
C
	DO 7100 I = 1,MAXWRW
	   WTPOOL(I,WPAMNT,WPSTAT,GINDX) = WTPOOL(I,WPAMNT,WPDYNM,GINDX)
	   IF(WITSTA(I,GINDX).EQ.GAMCAN) GOTO 7100
	   IF(WITSTA(I,GINDX).EQ.GAMBFD) GOTO 7100
	   IF(WITSTA(I,GINDX).EQ.GAMREF) GOTO 7100
	   TOTAL = TOTAL + WTPOOL(I,WPAMNT,WPSTAT,GINDX) * DYN_BETUNIT
7100	CONTINUE
	TOTAL = (TOTAL * CALPER(WITSPR(GINDX))) + WITPOL(1,GINDX) * DYN_BETUNIT
C
C CALCULATE ODDS FOR WIN TIP GAME
C
	DO 7200 I = 1,MAXWRW
	   IF(WTPOOL(I,WPAMNT,WPSTAT,GINDX).EQ.0) THEN
	      RODDS = 99999
	   ELSE
	      RODDS = TOTAL / (WTPOOL(I,WPAMNT,WPSTAT,GINDX) *
     *		      DYN_BETUNIT) * 100
	   ENDIF
	   IODDS = NINT(RODDS)
	   IF(IODDS.LT.100) IODDS = 100
	   IF(IODDS.GT.99999) IODDS = 99999
	   IF(WITSTA(I,GINDX).EQ.GAMCAN.OR.
     *	      WITSTA(I,GINDX).EQ.GAMBFD.OR.
     *	      WITSTA(I,GINDX).EQ.GAMREF.OR.
     *	      WITSTA(I,GINDX).EQ.GAMNUL)    THEN
	      IODDS = 0
	   ENDIF
C
C CHECK IF NEW CALCULATED ODDS IS DIFFERENT FROM OLD STATIC ODDS
C IF DIFFERENT OR FORCE FLAG, SET SEND BITMAP AND UPDATE ODDS IN STATIC AREA.
C
	   IF(IODDS.NE.WTPOOL(I,WPODDS,WPSTAT,GINDX).OR.ALLFLG) THEN
	      WTPOOL(I,WPODDS,WPSTAT,GINDX) = IODDS
	      CALL SETBIT_BSTRNG(BITMAP,I-1)
	      SNDODS = .TRUE.
	   ENDIF
C
7200	CONTINUE
7250	CONTINUE
C
	IF(.NOT.SNDODS) RETURN			    !Only Send if Changed.
	IF(P(SYSTYP).NE.LIVSYS.OR.DAYSTS.NE.DSOPEN) RETURN
C
	IF(.TRUE.) RETURN      !do NOT send to network for Finland
CV22C
CV22C BUILD OUTPUT MESSAGE TO THE NETWORK
CV22C (CORRECT SEQUENCE NUMBER WILL BE SET IN UNSPRO TYPREG TRANSACTIONS).
CV22C
CV22	IND = 7
CV22	CHKIND = 1
CV22	MESTAB(  1) = CTL			!CONTROL / SEQUENCE
CV22	MESTAB(  2) = TYP + TWIT		!TYPE / SUBTYPE
CV22	CALL ICLOCK(0,TIMBUF)			!TIME (HH:MM:SS)
CV22	CALL ISBYTE(TIMBUF(1),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	CALL ISBYTE(TIMBUF(2),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	CALL ISBYTE(TIMBUF(3),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	MESTAB(IND) = GINDX			!GAME INDEX
CV22	IND = IND + 1
CV22	I4TEMP = P(ODSUPD)			!ODDS UPDATE TIME
CV22	CALL REVBYT(I4TEMP,2,MESTAB,IND,2)
CV22	IND = IND + 2
CV22	BITMAP_IND = IND
CV22	IND = IND + 6
CV22C
CV22C STUFF ODDS INTO THE OUTPUT BUFFER (ONLY ROWS THAT HAVE CHANGED)
CV22C ALSO STUFF ODDS INTO CHECKSUM TABLE (ALL ROWS!!!)
CV22C
CV22	DO 7300 I = 0,MAXWRW - 1
CV22	   CALL REVBYT(WTPOOL(I+1,WPODDS,WPSTAT,GINDX),
CV22     *		       3,CHKTAB,CHKIND,3)
CV22	   CHKIND = CHKIND + 3
CV22C
CV22C IF ODDS ARE REQUESTED DO NOT SEND ODDS THAT ARE ZERO (NOT ACTIVE)
CV22C
CV22	   IF(REQFLG.AND.WTPOOL(I+1,WPODDS,WPSTAT,GINDX).EQ.0) 
CV22     *        CALL CLRBIT_BSTRNG(BITMAP,I)
CV22C
CV22	   IF(.NOT.TSTBIT_BSTRNG(BITMAP,I)) GOTO 7300
CV22	   CALL REVBYT(WTPOOL(I+1,WPODDS,WPSTAT,GINDX),
CV22     *		       3,MESTAB,IND,3)
CV22	   IND = IND + 3
CV227300	CONTINUE
CV22	MESLEN = IND - 1
CV22	CHKIND = CHKIND - 1
CV22C
CV22C PUT BITMAP INTO MESSGAE (AT PREVIOUSLY SAVED POSSITION)
CV22C
CV22	CALL MOVBYT(BITMAP,1,MESTAB,BITMAP_IND,6) !6 BYTE BITMAP
CV22C
CV22C CALCULATE CHECKSUM ON ALL ODDS (CHECKSUM TABLE).
CV22C THEN STICK IT INTO THE MESSAGE.
CV22C
CV22	CHKLEN = CHKIND 
CV22	CALL GETCCITT(CHKTAB,0,CHKLEN,MYCHKSUM)
CV22	I4CCITT = MYCHKSUM
CV22	MESTAB(5) = I1CCITT(2)
CV22	MESTAB(6) = I1CCITT(1)
CV22C
CV22C CALCULATE CHECKSUM ON OUTPUT BUFFER
CV22C
CV22	CHKLEN = MESLEN - 1
CV22	I4CCITT = 0
CV22	MESTAB(3) = I1CCITT(2)
CV22	MESTAB(4) = I1CCITT(1)
CV22	CALL GETCCITT(MESTAB,1,CHKLEN,MYCHKSUM)
CV22	I4CCITT = MYCHKSUM
CV22	MESTAB(3) = I1CCITT(2)
CV22	MESTAB(4) = I1CCITT(1)
CV22C
CV22C
CV22	RETURN
C
C PROCESS COUPLE ODDS UPDATE
C -------------------------
C
13000	CONTINUE
C
C GET AND CHECK GAME NUMBER
C
	GNUM = GTNTAB(TCPL,GINDX)
	IF(GNUM.LT.1.OR.GNUM.GT.MAXGAM) RETURN
C
C IF TERMINAL REQUESTED ODDS, SKIP CALCULATING PART, GO FORMAT MESSAGE.
C
	IF(REQFLG) THEN
	   GOTO 13250
	ENDIF
C
C MOVE DYNAMIC SALES DATA TO STATIC AREA AND ACCUMULATE TOTAL
C
	DO 13100 I = 1,(MAXCPLRW/2)*(MAXCPLRW/2)
	   CPPOOL(I,CPLPAMNT,CPLPSTAT,GINDX)=CPPOOL(I,CPLPAMNT,CPLPDYNM,GINDX)
      	   IF(CPLSTA((I-1)/(MAXCPLRW/2)+1,GINDX).GT.GAMBFD) GOTO 13100
      	   IF(CPLSTA(MOD(I-1,(MAXCPLRW/2))+1+MAXCPLRW/2,GINDX).GT.GAMBFD) 
     *        GOTO 13100
           IF(DBPOOL(I,DBLPAMNT,DBLPSTAT,GINDX).GE.0) THEN
	      TOTAL = TOTAL + 
     *                DFLOAT(CPPOOL(I,CPLPAMNT,CPLPSTAT,GINDX) * DYN_BETUNIT)
           ENDIF

13100	CONTINUE
	TOTAL = (TOTAL * CALPER(CPLSPR(GINDX))) + CPLPOL(1,GINDX) * DYN_BETUNIT
C
C CALCULATE ODDS FOR COUPLE GAME
C
	DO 13200 I = 1,(MAXCPLRW/2)*(MAXCPLRW/2)
	   IF(CPPOOL(I,CPLPAMNT,CPLPSTAT,GINDX).LE.0) THEN
	      RODDS = 99999
	   ELSE
	      RODDS = TOTAL / (CPPOOL(I,CPLPAMNT,CPLPSTAT,GINDX) *
     *		      DYN_BETUNIT) * 100
	   ENDIF
	   IODDS = NINT(RODDS)
	   IF(IODDS.LT.100) IODDS = 100
	   IF(IODDS.GT.99999) IODDS = 99999
	   IF(CPLSTA((I-1)/(MAXCPLRW/2)+1,GINDX).EQ.GAMCAN.OR.
     *	      CPLSTA((I-1)/(MAXCPLRW/2)+1,GINDX).EQ.GAMBFD.OR.
     *	      CPLSTA((I-1)/(MAXCPLRW/2)+1,GINDX).EQ.GAMREF.OR.
     *	      CPLSTA((I-1)/(MAXCPLRW/2)+1,GINDX).EQ.GAMNUL.OR.
     *        CPLSTA(MOD(I-1,(MAXCPLRW/2))+1+MAXCPLRW/2,GINDX).EQ.GAMCAN.OR.
     *	      CPLSTA(MOD(I-1,(MAXCPLRW/2))+1+MAXCPLRW/2,GINDX).EQ.GAMBFD.OR.
     *	      CPLSTA(MOD(I-1,(MAXCPLRW/2))+1+MAXCPLRW/2,GINDX).EQ.GAMREF.OR.
     *	      CPLSTA(MOD(I-1,(MAXCPLRW/2))+1+MAXCPLRW/2,GINDX).EQ.GAMNUL)
     *        THEN
	      IODDS = 0
	   ENDIF

	   CPPOOL(I,CPLPODDS,CPLPSTAT,GINDX) = IODDS

           LOCAL_CPPSORT(1,I) = CPPOOL(I,CPLPAMNT,CPLPSTAT,GINDX)
           IF(CPLSTA((I-1)/(MAXCPLRW/2)+1,GINDX).EQ.GAMNUL.OR.
     *        CPLSTA(MOD(I-1,(MAXCPLRW/2))+1+MAXCPLRW/2,GINDX).EQ.GAMNUL)
     *        THEN
              LOCAL_CPPSORT(1,I) = -1
           ENDIF
           LOCAL_CPPSORT(2,I) = I

13200	CONTINUE
C
C SORT ON ODDS FOR COUPLE
C
        CALL ISORT(LOCAL_CPPSORT,MAXCPLRW/2*MAXCPLRW/2)
	CALL FASTMOV(LOCAL_CPPSORT,CPPSORT(1,1,GINDX),2*MAXCPLRW/2*MAXCPLRW/2)

C
13250	CONTINUE
C
	IF(.NOT.SNDODS) RETURN			    !Only Send if Changed.
	IF(P(SYSTYP).NE.LIVSYS.OR.DAYSTS.NE.DSOPEN) RETURN
C
	IF(.TRUE.) RETURN      !do NOT send to network for Finland
CV22C
CV22C BUILD OUTPUT MESSAGE TO THE NETWORK
CV22C (CORRECT SEQUENCE NUMBER WILL BE SET IN UNSPRO TYPREG TRANSACTIONS).
CV22C
CV22	IND = 7
CV22	CHKIND = 1
CV22	MESTAB(  1) = CTL			!CONTROL / SEQUENCE
CV22	MESTAB(  2) = TYP + TCPL		!TYPE / SUBTYPE
CV22	CALL ICLOCK(0,TIMBUF)			!TIME (HH:MM:SS)
CV22	CALL ISBYTE(TIMBUF(1),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	CALL ISBYTE(TIMBUF(2),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	CALL ISBYTE(TIMBUF(3),MESTAB,IND-1)
CV22	IND = IND + 1
CV22	MESTAB(IND) = GINDX			!GAME INDEX
CV22	IND = IND + 1
CV22	I4TEMP = P(ODSUPD)			!ODDS UPDATE TIME
CV22	CALL REVBYT(I4TEMP,2,MESTAB,IND,2)
CV22	IND = IND + 2
CV22	BITMAP_IND = IND
CV22	IND = IND + 6
CV22C
CV22C STUFF ODDS INTO THE OUTPUT BUFFER (ONLY ROWS THAT HAVE CHANGED)
CV22C ALSO STUFF ODDS INTO CHECKSUM TABLE (ALL ROWS!!!)
CV22C
CV22	DO 13300 I = 0,(MAXCPLRW/2*MAXCPLRW/2) - 1
CV22	   CALL REVBYT(CPPOOL(I+1,CPLPODDS,CPLPSTAT,GINDX),
CV22     *		       3,CHKTAB,CHKIND,3)
CV22	   CHKIND = CHKIND + 3
CV22C
CV22C IF ODDS ARE REQUESTED DO NOT SEND ODDS THAT ARE ZERO (NOT ACTIVE)
CV22C
CV22	   IF(REQFLG.AND.CPPOOL(I+1,CPLPODDS,CPLPSTAT,GINDX).EQ.0) 
CV22     *        CALL CLRBIT_BSTRNG(BITMAP,I)
CV22C
CV22	   IF(.NOT.TSTBIT_BSTRNG(BITMAP,I)) GOTO 13300
CV22	   CALL REVBYT(CPPOOL(I+1,CPLPODDS,CPLPSTAT,GINDX),
CV22     *		       3,MESTAB,IND,3)
CV22	   IND = IND + 3
CV2213300	CONTINUE
CV22	MESLEN = IND - 1
CV22	CHKIND = CHKIND - 1
CV22C
CV22C PUT BITMAP INTO MESSGAE (AT PREVIOUSLY SAVED POSSITION)
CV22C
CV22	CALL MOVBYT(BITMAP,1,MESTAB,BITMAP_IND,6) !6 BYTE BITMAP
CV22C
CV22C CALCULATE CHECKSUM ON ALL ODDS (CHECKSUM TABLE).
CV22C THEN STICK IT INTO THE MESSAGE.
CV22C
CV22	CHKLEN = CHKIND 
CV22	CALL GETCCITT(CHKTAB,0,CHKLEN,MYCHKSUM)
CV22	I4CCITT = MYCHKSUM
CV22	MESTAB(5) = I1CCITT(2)
CV22	MESTAB(6) = I1CCITT(1)
CV22C
CV22C CALCULATE CHECKSUM ON OUTPUT BUFFER
CV22C
CV22	CHKLEN = MESLEN - 1
CV22	I4CCITT = 0
CV22	MESTAB(3) = I1CCITT(2)
CV22	MESTAB(4) = I1CCITT(1)
CV22	CALL GETCCITT(MESTAB,1,CHKLEN,MYCHKSUM)
CV22	I4CCITT = MYCHKSUM
CV22	MESTAB(3) = I1CCITT(2)
CV22	MESTAB(4) = I1CCITT(1)
CV22C
CV22	RETURN
C
C GAMES TYPES NOT SUPPORTED
C
9000	RETURN
	END
