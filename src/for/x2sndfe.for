C
C SUBROUTINE X2SNDFE
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]X2SNDFE.FOV                                  $
C  $Date::   17 Apr 1996 16:34:40                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C
C ** Source - x2sndbuf.for **
C
C V05 08-SEP-95 DAS Use variable x2x_comtsk in call to x2msgedt
C V04 12-DEC-94 DAS Integrate UK changes into X2X Baseline
C V02  9-MAR-94 JWE Add broadcast server code
C
C++++++++++++++++++++++++++++++++++++++++++++++
C     X2SNDFE.FTN             ;PROCESS TRANSPORT DATA MESSAGE
C
C     X2SNDFE(BUFFER,MESSAGE,MESSAGE_LEN,STATION_NO,TERMINAL_NO,
C  CURRENT_POINTER,MES_NUM,DEST_LAYER,CONNCTL_OVR,DELIVER_OVR,STATUS)
C     IN:
C        CURRENT_POINTER - CURRENT POINTER IN BUFFER
C        MESSAGE- TERMINAL MESSAGE (I*2)
C        MESSAGE_LEN - MESSAGE LENGTH IN BYTES
C        TERMINAL_NO - TERMINAL NUMBER
C        DEST_LAYER  -   FINAL DESTINATION LAYER
C        MES_NUM     - MESSAGE NUMBER FROM MESSAGE COMMON
C        CONNCTL_OVR - CONNECTION CONTROL
C        DELIVER_OVR - DELIVERY CONTROL
C     OUT:
C        BUFFER - BUFFER WITH XPORT LAYER + DATA
C        STATUS  - STATUS
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE X2SNDFE(BUFFER,MESSAGE,MESSAGE_LEN,STATION_NO,
     *	    TERMINAL_NO,CURRENT_POINTER,HOST_ID,MES_NUM,DEST_LAYER,
     *	    CONNCTL_OVR,DELIVER_OVR,STATUS)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:PROCOM.DEF'
	INCLUDE 'INCLIB:X2FEMES.DEF'
	INCLUDE 'INCLIB:X2STMES.DEF'
C
CCC	INTEGER*2 BUFFER(*)
	BYTE      BUFFER(0:*)     !ELIMINATE ILBYTE AND ISBYTE
	INTEGER*2 MESSAGE(*)
	INTEGER*4 MESSAGE_LEN,TERMINAL_NO,CURRENT_POINTER
	INTEGER*4 STATUS,DEST_LAYER, HOST_ID, STATION_NO
	INTEGER*4 UNIT_LENGTH, TO_ADD, DATA_LEN, START_OFFSET
	INTEGER*4 ADD_LEN, HEADER, ADRESS_LEN, CONN_ID, DISCONNECT
	INTEGER*4 FLAGS, STATION_FLAG, DELIVERY_ACK, ERROR_REPORT
	INTEGER*4 NO_DATA, LENGTH, DELIVER_OVR, CONNCTL_OVR, MES_NUM
        INTEGER*4 CONN_TYPE, VSLEN, DEL_MASK
        INTEGER*4 STATION_ADR(2)
	INTEGER*4 CLASS
C
	IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	    TYPE *,'X2SNDFE ',MESSAGE_LEN,STATION_NO,TERMINAL_NO,
     *	     CURRENT_POINTER,HOST_ID,MES_NUM,DEST_LAYER,CONNCTL_OVR,
     *	     DELIVER_OVR
	IF (IAND(DEST_LAYER,X2DEST_FE).EQ.0) THEN
	   STATUS=X2ERR_INV+X2ERR_FATAL
	IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	    TYPE *,'RET X2SNDFE ',CURRENT_POINTER,STATUS,MESSAGE_LEN
	   RETURN
	ENDIF
C
	IF (IAND(DEST_LAYER,X2DEST_STATION).EQ.0)  THEN !NO MESSAGE
C                                                     TO STATION
	   LENGTH=((MESSAGE_LEN+1)/2)*2
	   CURRENT_POINTER=CURRENT_POINTER+LENGTH
	   CALL MOVTAB2(MESSAGE,BUFFER,LENGTH/2)
	   STATUS=0
	   IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	    TYPE *,'RET X2SNDFE ',CURRENT_POINTER,STATUS,MESSAGE_LEN
	   RETURN
	ENDIF
C
	CLASS=X2XS_STNCLS(STATION_NO)

	BUFFER(X2FEMES_PROTID-1) = X2FEMES_PROTID_X2X
	BUFFER(X2FEMES_HOST_ID-1) = HOST_ID
	BUFFER(X2FEMES_MESTYP-1) = X2FEMES_MESTYP_DOWN
C
C     SET DELIVERY FLAGS
C
	NO_DATA=0
	IF (MESSAGE_LEN.EQ.0.AND.MES_NUM.EQ.0) NO_DATA=X2FEMES_FLAGS_ND
	ERROR_REPORT=0
	IF (X2X_DELIVERY_ERR.EQ.0) ERROR_REPORT=X2FEMES_FLAGS_ER
	DELIVERY_ACK=0
	IF (X2X_DELIVERY_ACK.EQ.0) DELIVERY_ACK=X2FEMES_FLAGS_DA
	IF (CLASS.NE.0) THEN
	    IF (X2XC_ERRREP(CLASS).EQ.0) ERROR_REPORT=X2FEMES_FLAGS_ER
	    IF (X2XC_DELACK(CLASS).EQ.0) DELIVERY_ACK=X2FEMES_FLAGS_DA
	ENDIF
	STATION_FLAG=0
	IF(TSBIT(IX2XS_DOWNFLAG,(STATION_NO-1)*8+2))
     *    STATION_FLAG=X2FEMES_FLAGS_DA
	FLAGS=
     *	  IOR(IOR(NO_DATA,ERROR_REPORT),IOR(DELIVERY_ACK,STATION_FLAG))
        IF (X2XS_VSP(STATION_NO).NE.0.OR.X2XS_EVSN(1,STATION_NO).NE.0
     *      .OR.X2XS_EVSN(2,STATION_NO).NE.0)
     *        FLAGS = IOR(FLAGS,X2FEMES_FLAGS_DVS)
C
	IF (DELIVER_OVR.NE.0) THEN
 	    DEL_MASK = IAND(DELIVER_OVR,255)
            FLAGS = IOR(FLAGS,DEL_MASK)
        ENDIF
C
        CALL ILBYTE(CONN_TYPE,IX2XS_CONN_TYPE,STATION_NO-1)
        IF(CONN_TYPE.GE.0.AND.CONN_TYPE.LE.X2FEMES_MAX_CONNTYPE)
     *     FLAGS = FLAGS + X2FEMES_NET_TYPE_XREF(CONN_TYPE)
	BUFFER(X2FEMES_FLAGS-1) = FLAGS
C
C     DISCONNECTION IS DETERMINED BY (IN PRIORITY)
C     OVERRIDE FLAG CONNCTL_OVR,GLOBAL FLAG, LOCAL FLAG FOR TERMINAL
C
	DISCONNECT=IAND(CONNCTL_OVR,'0000FF00'X)/256
	IF (DISCONNECT.EQ.0) DISCONNECT=X2X_GLOBAL_FE_DISCONNECT
	IF (DISCONNECT.EQ.0)
     *	    DISCONNECT=ZEXT (BX2XS_FE_DISCONNECT(STATION_NO))
	IF (DISCONNECT.EQ.0 .AND. CLASS.GT.0)
     *	    DISCONNECT=X2XC_FEDIS(CLASS)
C***
C BCST CHANGES                                                        V02
C FOR BCST STATION MAKE SURE YOU DO NOT OPEN NEW CONNECTION IN
C CONNECTION CONTROL FIELD, IN DISCONNECTION CONTROL FIELD SET
C SET TO NO ACTION UNLESS IT WAS IMMEDIATE DISCONNECT MESSAGE.
C
	CONN_ID=X2XS_CONN_ID(STATION_NO)
	IF (STATION_NO.GT.0) THEN
	     IF (X2XS_TYPE(STATION_NO).EQ.X2XST_BCST) THEN
		IF (IAND(DISCONNECT,'0F'X).NE.0)
     *		  DISCONNECT=IAND(DISCONNECT,'FFFFFFF0'X) !CLEAR DISC. CONTROL
		IF (IAND(DISCONNECT,'F0'X).NE.0)
     *		  DISCONNECT=IAND(DISCONNECT,'FFFFFF0F'X) !CLEAR CONN. CONTROL
C****		CONN_ID=0
	     ENDIF
	ENDIF
C END BCST CHANGES
C**
	BUFFER(X2FEMES_CONNCTL-1) = DISCONNECT
C
C IF CONNECTED VIA ASYNC PVC THEN CONNECT ID IS EXPLICITLY STATION CONNECT ID.
C
	IF(IAND(DEST_LAYER,X2DEST_APP).NE.0.AND.TERMINAL_NO.GT.0    .AND.
     *     BX2XS_CONN_TYPE(STATION_NO).NE.X2XSCT_ASYPVC		    .AND.
     *     BX2XS_CONN_TYPE(STATION_NO).NE.X2XSCT_USAT_PVC	    .AND.
     *	   X2XS_TYPE(STATION_NO).NE.X2XST_BCST) 
     *        CONN_ID=X2XT_CONN_ID(TERMINAL_NO)
	CALL I4TOBUF4(CONN_ID,BUFFER,X2FEMES_CONN_ID-1)
C
C     WE ASSUME THAT FRONT END ID COULD BE REUSED. THAT IMPLIES
C     THAT WE NEED EXPLICIT ADRESSING
C
C     IF CONNECTED VIA X.32 DO NOT USE STATION ADDRESS, BUT NETWORK
C     ADDRESS (NOT IMPLEMENTED YET) !!!
C
C
	ADRESS_LEN=X2XS_ADRESS_LEN(STATION_NO)
        STATION_ADR(1) = X2XS_ADRESS(1,STATION_NO)
        STATION_ADR(2) = X2XS_ADRESS(2,STATION_NO)
C
        CALL X2QSHFT(STATION_ADR,64-ADRESS_LEN*4)
C
	CALL I4TOBUF4(STATION_ADR(1),BUFFER,X2FEMES_ADR-1)
	IF (ADRESS_LEN.GT.0)
     *	 CALL I4TOBUF4(STATION_ADR(2),BUFFER,X2FEMES_ADR+3)
	BUFFER(X2FEMES_ADRLEN-1) = ADRESS_LEN
	HEADER=X2FEMES_ADRLEN
	IF (ADRESS_LEN.NE.0) HEADER=HEADER+(ADRESS_LEN+1)/2
        VSLEN = 0
        IF(X2XS_VSP(STATION_NO).NE.0) VSLEN = X2FEMES_VER_LEN
        IF(X2XS_EVSN_LEN(STATION_NO).GT.0)VSLEN =
     *     (X2XS_EVSN_LEN(STATION_NO)+1)/2
        IF(VSLEN.GT.0) THEN
           HEADER = HEADER + 1
           CALL ISBYTE(VSLEN,BUFFER,HEADER-1)
           IF(X2XS_VSP(STATION_NO).NE.0) THEN
              CALL I4TOBUF2(X2XS_VSP(STATION_NO),BUFFER,HEADER)
           ENDIF
           IF(X2XS_EVSN_LEN(STATION_NO).GT.0) THEN
             STATION_ADR(1) =X2XS_EVSN(1,STATION_NO)
             STATION_ADR(2) =X2XS_EVSN(2,STATION_NO)
C
             CALL X2QSHFT(STATION_ADR,64-X2XS_EVSN_LEN(STATION_NO)*4)
C
             IF(X2XS_EVSN_LEN(STATION_NO).GT.0) 
     *         CALL I4TOBUF4(STATION_ADR(1),BUFFER,HEADER)
             IF(X2XS_EVSN_LEN(STATION_NO).GT.8)
     *         CALL I4TOBUF4(STATION_ADR(2),BUFFER,HEADER+4)
           ENDIF
           HEADER=HEADER+VSLEN
        ENDIF
C
	HEADER=(HEADER+1)/2*2                 !MAKE IT EVEN
	BUFFER(X2FEMES_HEADLEN-1) = HEADER
C
	IF (IAND(DEST_LAYER,X2DEST_APP).EQ.0) THEN  !TO STATION ONLY
	   IF (MES_NUM.EQ.0) THEN
	      ADD_LEN=(MESSAGE_LEN+1)/2*2
	      CALL MOVTAB2(MESSAGE,BUFFER(((HEADER/2+1)*2)-2),
     *           ADD_LEN/2)
	   ELSE
	      CALL X2MSGEDT(MESSAGE,BUFFER(((HEADER/2+1)*2)-2),MES_NUM,
     *	                        MESSAGE_LEN,ADD_LEN,X2X_COMTSK)
	      CALL ILBYTE(START_OFFSET,BUFFER(((HEADER/2+1)*2)-2),
     *	                  X2STMES_RELAY_MSG_OFF-1)
	      DATA_LEN=ADD_LEN-START_OFFSET
	      CALL I4TOBUF2(DATA_LEN,BUFFER(((HEADER/2+1)*2)-2),
     *	                       X2STMES_RELAY_MSG_LEN-1)
	   ENDIF
	   ADD_LEN=((ADD_LEN+1)/2)*2
	   TO_ADD=HEADER+ADD_LEN
	   STATUS=0
	   CURRENT_POINTER=CURRENT_POINTER+TO_ADD
	   UNIT_LENGTH=HEADER+ADD_LEN
	   CALL I4TOBUF2(UNIT_LENGTH,BUFFER,X2FEMES_MESLEN-1)
	   IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	    TYPE *,'RET X2SNDFE ',CURRENT_POINTER,STATUS,ADD_LEN
	   RETURN
	ENDIF
C
	CALL X2SNDSTN(BUFFER(((HEADER/2+1)*2)-2),MESSAGE,TERMINAL_NO,
     *        STATION_NO,MESSAGE_LEN,DEST_LAYER,TO_ADD,MES_NUM,
     *        CONNCTL_OVR,STATUS)
	IF (STATUS.EQ.0) THEN
	   CURRENT_POINTER=CURRENT_POINTER+HEADER+((TO_ADD+1)/2)*2
	   UNIT_LENGTH=HEADER+TO_ADD
	   CALL I4TOBUF2(UNIT_LENGTH,BUFFER,X2FEMES_MESLEN-1)
CCC	   IF (X2X_TRACE_STATION.EQ.STATION_NO.AND.STATION_NO.GT.0.OR.
CCC     *	       X2X_TRACE_STATION.EQ.-1.AND.STATION_NO.GT.0)
CCC     *	      CALL X2TRCSTN(BUFFER(HEADER/2+1))
	   IF (X2X_TRACE_STATION.EQ.STATION_NO.AND.STATION_NO.GT.0.OR.
     *	       X2X_TRACE_STATION.EQ.-1.AND.STATION_NO.GT.0)
     *	      CALL X2TRCSTN(BUFFER(((HEADER/2+1)*2)-2))
	ENDIF
	IF (IAND(X2X_DEBUG,X2X_DEBUG_SUBS).NE.0)
     *	   TYPE *,'RET X2SNDFE ',CURRENT_POINTER,STATUS,MESSAGE_LEN
	RETURN
	END
