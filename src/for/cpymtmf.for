C
C     FILE   : CPYMTMF.FOR
C     AUTHOR : J.H.R
C     VERSION: 01            DATE: 20 / 12 / 2001
C
C
C V01 JHR INITIAL RELEASE FOR PORTUGAL PROJECT
C
C COPY PARTIAL MTMF01.FIL FILE TO ANOTHER FILE ( IN ORDER TO REPROCESS PARTIAL
C MTMF01.FIL FILE ). FOR EXAMPLE DO NOT REPROCESS "DAY END" COMMAND BUT
C REPROCESS ALL OTHER INFORMATION
C
C     **************************************************************************
C
C        THIS ITEM IS THE PROPERTY OF GTECH CORPORATION, POVIDENCE, RHODE
C     ISLAND, AND CONTAINS CONFIDENTIAL AND TRADE SECRET INFORMATION. IT MAY
C     NOT BE TRANSFERRED FROM THE CUSTODY OR CONTROL OF GTECH EXCEPT AS AUTO -
C     RIZED IN WRITING BY AN OFFICER OF GTECH. NEITHER THIS ITEM NOR THE
C     INFORMATION IT CONTAINS MAY BE USED, TRANSFERRED, REPRODUCED, PUBLISHED
C     OR DISCLOSED, IN WHOLE OR IN PART, AND DIRECTLY OR INDIRECTLY, EXCEPT AS
C     EXPRESSLY AUTHORIZED BY AN OFFICER OR GTECH, PURSUANT TO WRITTEN AGREEMENT
C
C     Copyright 2000 GTECH Corporation. All Rigth Reserved
C
C     **************************************************************************
C
C THIS PROGRAM COPY MASTER TRANSACTIONS FILE TO ANOTHER FILE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      PROGRAM CPYMTMF
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO COPY MASTER TRANSACTIONS FILE TO ANOTHER FILE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C VARIABLES DEFINITION TO COPY MASTER TRANSACTIONS FILE TO ANOTHER FILE
C
      INTEGER * 4 LST_MTM_SER         ! LAST SERIAL NUMBER TO COPY MTMF FILE
C
C DISPLAY TASK PRESENTATION TO USER ( WE ARE GOING TO COPY FILE )
C
      CALL DSP_TASK_PRESENTATION
C
C ASK TO USER PASSWORD AND LAST SERIAL NUMBER TO COPY
C
      CALL GET_PASSWORD_SERIAL(LST_MTM_SER)
C
C PROCEDURE TO COPY TRANSACTION MASTER FILE
C
      CALL COPY_MTMF_FILE(LST_MTM_SER)
C
C PROCEDURE TO COPY TRANSACTION MASTER FILE ENDS OK
C
      CALL GSTOP(GEXIT_SUCCESS)
C
C THIS IS THE END TO COPY MASTER TRANSACTIONS FILE TO ANOTHER FILE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: DSP_TASK_PRESENTATION
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 20 / 12 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO DISPLAY USER PRESENTATION TASK
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE DSP_TASK_PRESENTATION
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO DISPLAY USER PRESENTATION TASK
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C CLEAR WINDOW AND DISPLAY COPYRITE
C
      CALL CLRSCR(6)
      CALL COPYRITE
C
C IF IT'S SUBRUN MODE SHOW ERROR TO USER AND END PROGRAM
C
      IF(ISSUBPROC() .EQ. .TRUE.) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'It Is Not Allowed Run This Program In Subrun Mode'
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C DISPLAY USER PRESENTATION ( MANUAL RUN PROGRAM )
C
      TYPE *, IAM()
      TYPE *, IAM(), '* * * * * * * * * * * * * * * * * * * * * * * * * *'
      TYPE *, IAM(), '*     COPY TRANSACTION MASTER FILE PROCEDURES     *'
      TYPE *, IAM(), '* * * * * * * * * * * * * * * * * * * * * * * * * *'
      TYPE *, IAM()
C
C THIS IS THE END TO DISPLAY USER PRESENTATION TASK
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_PASSWORD_SERIAL
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 20 / 12 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO ASK PASSWORD TO USER AND GET LAST SERIAL TO COPY
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GET_PASSWORD_SERIAL(LST_MTM_SER)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO ASK PASSWORD TO USER AND GET LAST SERIAL TO COPY
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO ASK PASSWORD TO USER AND GET LAST SERIAL TO COPY
C
      INTEGER * 4 LST_MTM_SER         ! LAST SERIAL NUMBER TO COPY MTMF FILE
C
C VARIABLES DEFINITION TO ASK PASSWORD TO USER AND GET LAST SERIAL TO COPY
C
      INTEGER * 4 FSTS                ! FUNCTION STATUS
C
      CHARACTER * 20 USERPASWRD       ! PASSWORD THAT USER HAS ENTER
      CHARACTER * 09 ANSPSWD          ! PASSWORD THAT USER NEEDS ENTER
      CHARACTER * 38 USRMSG           ! USER MESSAGE ( TO DISPLAY )
C
C WITE PASSWORD THAT USER NEEDS ENTER
C
      ANSPSWD = 'BARCELONA'
C
C ASK PASSWORD TO THE USER ( PASSWORD IS: BARCELONA )
C
      CALL PASSWORD(20, USERPASWRD)
C
C IF USER DOES NOT KNOW THE PASSWORD EXIT, NOT ALLOWED COPY FILE
C
      IF(USERPASWRD(1:9) .NE. ANSPSWD(1:9)) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Invalid Password Entered ...'
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C ASK TO USER LAST SERIAL OF MTMF FILE TO COPY IN THE NEW FILE
C
      USRMSG = 'Enter Last Serial To Copy [A For All]:'
      TYPE *, IAM()
      CALL INPNUM(USRMSG, LST_MTM_SER, 1, 999999999, FSTS)
C
C CHECK USER SELECTION ( OPERATOR ABORT, OR ENTER A NUMBER )
C
      IF(FSTS .NE. 0 .AND. FSTS .NE. -4) THEN
        TYPE *, IAM()
        CALL GSTOP(GEXIT_OPABORT)
      ENDIF
C
C IF USER ANSWER COPY ALL FILE, SET VARIABLE
C
      IF(FSTS .EQ. -4) LST_MTM_SER = 0
C
C THIS IS THE END TO ASK PASSWORD TO USER AND GET LAST SERIAL TO COPY
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_FREE_IDFIL
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 09 / 02 / 2001
C
C ******************************************************************************
C
C FUNCTION TO GET FREE IDENTIFICATION FILE NUMBER
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      INTEGER * 4 FUNCTION GET_FREE_IDFIL(CHECKIDFIL)
      IMPLICIT NONE
C
C INCLUDE DEFINITIONS TO GET FREE IDENTIFICATION FILE NUMBER
C
      INCLUDE '(LIB$ROUTINES)'
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
C PARAMETERS DEFINITION TO GET FREE IDENTIFICATION FILE NUMBER
C
      INTEGER * 4 CHECKIDFIL          ! CHECK IDFIL (0: NO, 1: YES )
C
C VARIABLES DEFINITION TO GET FREE IDENTIFICATION FILE NUMBER
C
      INTEGER * 4 FSTS                ! FUNCTION STATUS
      INTEGER * 4 IDFIL               ! IDENTIFICATION FILE
C
C GET FREE IDENTIFICATION FILE NUMBER
C
      FSTS = LIB$GET_LUN(IDFIL)
      IF(FSTS .EQ. 0 .OR. IDFIL .LE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Getting Identifiation File'
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C CHECK IDENTIFICATION FILE
C
      IF(CHECKIDFIL .NE. 0 .AND. IDFIL .GT. 100) IDFIL = MOD(IDFIL, 100)
C
C WRITE FREE IDENTIFICATION FILE TO RETURN FUNCTION
C
       GET_FREE_IDFIL = IDFIL
C
C THIS IS THE END TO GET FREE IDENTIFICATION FILE NUMBER
C
      END


C ******************************************************************************
C
C     SUBROUTINE: COPY_MTMF_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 20 / 12 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO COPY TRANSACTION MASTER FILE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE COPY_MTMF_FILE(LST_MTM_SER)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO COPY TRANSACTION MASTER FILE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:DESTRA.DEF'
      INCLUDE 'INCLIB:PRMLOG.DEF'
C
C PARAMETERS DEFINITION TO COPY TRANSACTION MASTER FILE
C
      INTEGER * 4 LST_MTM_SER         ! LAST SERIAL NUMBER TO COPY MTMF FILE
C
C VARIABLES DEFINITION TO COPY TRANSACTION MASTER FILE
C
      INTEGER * 4 MTMSERNUM           ! MTMF TRANSACTION SERIAL NUMBER
      INTEGER * 4 LOGREC(LREC * 3)    ! LOGGER REGISTER
      INTEGER * 4 NEW_TMF_FILENAM(5)  ! NEW TMF FILE NAME
      INTEGER * 4 ORG_TMF_FILENAM(5)  ! ORIGIGAL TMF FILE NAME
      INTEGER * 4 CPYTMFFDB(7)        ! TMF FILE DESCRIPTOR BLOCK FOR COPY FILE
      INTEGER * 4 ORGTMFFDB(7)        ! TMF FILE DESCRIPTOR BLOCK FOR ORIGINAL
      INTEGER * 4 PRV_MTMSERNUM       ! PRVIOUS MTMF TRANSACTION SERIAL NUMBER
C
      LOGICAL EOF                     ! END OF FILE
C
C INITIATE VARIABLES TO COPY TRANSACTION MASTER FILE
C
      MTMSERNUM = 1
C
C ASK TO USER NEW TRANSACTION MASTER FILE NAME
C
      CALL GET_TMF_NAME_TO_COPY(NEW_TMF_FILENAM, ORG_TMF_FILENAM)
C
C OPEN TWO MTMF FILES ( MTMF FILE AND COPY MTMF FILE )
C
      CALL OPEN_MTMF_FILE(CPYTMFFDB, NEW_TMF_FILENAM)
      CALL OPEN_MTMF_FILE(ORGTMFFDB, ORG_TMF_FILENAM)
C
C DISPLAY TASK PRESENTATION TO USER ( WE ARE GOING TO COPY FILE )
C
      TYPE *, IAM()
      TYPE *, IAM(), 'Copy Transaction Master File ...'
      TYPE *, IAM()
C
C READ TRANSACTION FROM MASTER FILE
C
2000  CONTINUE
      EOF = .FALSE.
      PRV_MTMSERNUM = MTMSERNUM
      CALL READTMF(LOGREC, MTMSERNUM, EOF)
      IF(EOF) GOTO 1000
C
C CHECK IF TRANSACTION SHOULD BE COPY IN THE NEW FILE  
C
      IF(LST_MTM_SER .LE. 0) GOTO 3000              ! COPY ALL TRANSACTIONS
      CALL LOGTRA(TRABUF, LOGREC)
      IF(TRABUF(TSER) .LT. 1) GOTO 2000             ! TRANSACTION ERROR
      IF(TRABUF(TSER) .GT. LST_MTM_SER) GOTO 1000   ! NO COPY NEXT TRANSACTIONS
C
C COPY TRANSACTION TO THE NEW FILE
C
3000  CONTINUE
      CALL WRITETMF(CPYTMFFDB, PRV_MTMSERNUM, LOGREC)
C
C GO TO READ NEXT TRANSACTION TO MTMF01.FIL FILE
C
      GOTO 2000
C
C END FOR READ TRANSACTION MASTER FILE ( MTMF01.FIL )
C
1000  CONTINUE
C
C CLOSE NEW TRANSACTION MASTER FILE ( THE COPY ) AND ORIGIAN MTMF FILE 
C
      CALL CLOSEFIL(CPYTMFFDB)
      CALL CLOSEFIL(ORGTMFFDB)
C
C CHECK IF ORIGINAL AND COPY FILE ARE EQUALS ( DO NOT CHECK IN FINAL VERSION )
C
C     CALL TEST_COPY_FILE(NEW_TMF_FILENAM, ORG_TMF_FILENAM)
      RETURN
C
C THIS IS THE END TO COPY TRANSACTION MASTER FILE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: WRITETMF
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 20 / 12 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO WRITE TRANSACTION IN THE NEW MTMF FILE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE WRITETMF(FDB, SERIAL, LBUF)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO WRITE TRANSACTION IN THE NEW MTMF FILE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:PRMLOG.DEF'
      INCLUDE 'INCLIB:DESLOG.DEF'
C
C PARAMETERS DEFINITION TO WRITE TRANSACTION IN THE NEW MTMF FILE
C
      INTEGER * 4 FDB(*)              ! FILE DESCRIPTOR BLOCK
      INTEGER * 4 SERIAL              ! SERIAL NUMBER TO WRITE
      INTEGER * 4 LBUF(*)             ! BUFFER TO WRITE
C
C VARIABALES DEFINITION TO WRITE TRANSACTION IN THE NEW MTMF FILE
C
      INTEGER * 4 BLOCK               ! BLOCK NUMBER
      INTEGER * 4 INDEX               ! INDEX
      INTEGER * 4 OFFSET              ! OFFSET
      INTEGER * 4 IOBUF(DBLOCK)       ! INPUT / OUTPUT BUFFER
      INTEGER * 4 FSTS                ! FUNCTION STATUS
      INTEGER * 4 NUMREC              ! NUMBER OF RECORDS
      INTEGER * 4 RECLENGTH           ! RECORD KEBGTH
      INTEGER * 4 LSTBLK   / 0 /      ! LAST BLOCK
      INTEGER * 4 RTYPE               ! REGISTER TYPE
C
C GET BLOCK, INDEX AND OFFSET INTO LOG BUFFER GIVEN RECORD SIZE
C
      CALL GETBI(SERIAL, BLOCK, INDEX, OFFSET)
C
C IF BLOCK IT IS LAST BLOCK GO TO GET RECORD LENGTH
C
      IF(LSTBLK .EQ. BLOCK) GOTO 1000
C
C READ REGISTER IN NEW FILE
C
      CALL READW(FDB, BLOCK, IOBUF, FSTS)
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Reading New Transaction Master File'
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C UPDATE LAST BLOCK READED ( FOR NEXT WRITE TRANSACTION )
C
      LSTBLK = BLOCK
C
C GET RECORD LENGTH ( WE HAVE TO CHECK REGISTER TYPE )
C
1000  CONTINUE
      NUMREC = 1
      CALL ILBYTE(RTYPE, LBUF, LREC1 - 1)
      IF(RTYPE .EQ. LONE) THEN
        CALL ILBYTE(RTYPE, LBUF, LREC2 - 1)
        IF(RTYPE .EQ. LTWO) NUMREC = 3
        IF(RTYPE .EQ. LEND) NUMREC = 2
      ENDIF
      RECLENGTH = NUMREC * LREC
C
C WRITE INFORMATION IN NEW FILE ( FIRST MOVE IT TO WRITE BUFFER )
C
      CALL FASTMOV(LBUF, IOBUF(OFFSET), RECLENGTH)
      CALL WRITEW(FDB, BLOCK, IOBUF, FSTS)
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Writting New Transaction Master File'
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C THIS IS THE END TO WRITE TRANSACTION IN THE NEW MTMF FILE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: GET_TMF_NAME_TO_COPY
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 20 / 12 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO GET NEW TRANSACTION FILE NAME
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE GET_TMF_NAME_TO_COPY(CPY_FILENAM, ORG_FILENAM)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO GET NEW TRANSACTION FILE NAME
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:RECSCF.DEF'
      INCLUDE '(LIB$ROUTINES)'
C
C PARAMETERS DEFINITION TO GET NEW TRANSACTION FILE NAME
C
      INTEGER * 4 CPY_FILENAM(5)         ! COPY FILE NAME
      INTEGER * 4 ORG_FILENAM(5)         ! ORIGINAL FILE NAME
C
C VARIABLES DEFINITION TO GET NEW TRANSACTION FILE NAME
C
      INTEGER * 4 FSTS                   ! FUNCTION STATUS
      INTEGER * 4 LENGHT                 ! IMPUT LENGHT FROM USER
      INTEGER * 4 INT_FILENAM(5)         ! FILE NAME INTEGER FORAMT
      INTEGER * 4 DELFILE                ! DELETE FILE
C
      CHARACTER * 20 CHAR_FILENAM        ! FILE NAME CHAR FORMAT
C
      LOGICAL EXIST_FILE                 ! EXIST FILE ( YES / NO )
C
C EQUIVALENCES DEFINITION TO GET NEW TRANSACTION FILE NAME
C
      EQUIVALENCE(INT_FILENAM, CHAR_FILENAM)
C
C READ SYSTEN COMFIGURATION FILE TO GET TMF FILE SIZE
C
      CALL GETSCONF(SCFREC, FSTS)
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error System Configuration File'
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C COPY ORIGINAL FILE NAME TO OUTPUT VARIABLE
C
      CALL FASTMOV(SCFSFN(1, PTMF), ORG_FILENAM, 5)       
C
C DISPLAY TASK PRESENTATION TO USER ( WE ARE GOING TO ASK FOR FILE NAME )
C
2000  CONTINUE
      CALL DSP_TASK_PRESENTATION
C
C ASK TO USER NEW FILE NAME ( WHEN WE HAVE TO COPY MTMF01 FILE )
C
4000  CONTINUE
      CALL INPTEXT('Enter File Name When Copy Tmf File:', CHAR_FILENAM, LENGHT)
C
C CHECK IF COPY FILE IS ALLOWED ( NOT ENTER MTMF01.FIL )
C
      FSTS = INDEX(CHAR_FILENAM, '.FIL')
      IF(FSTS .EQ. 0) GOTO 3000
C
C DISPLAY ERROR TO USER ( NOT ALLOWED .FIL EXTENSION IN COPY FILE )
C
      TYPE *, IAM()
      TYPE *, IAM(), 'Not Allowed *.Fil Extension In Copy File, Enter Another'
      TYPE *, IAM()
      GOTO 4000 
C
C COPY FILE NAME TO OUTPUT VARIABLE
C
3000  CONTINUE
      CALL FASTMOV(INT_FILENAM, CPY_FILENAM, 5)
C
C IF FILE NAME EXIST, SHOW WARNING TO USER
C
      INQUIRE(FILE = CHAR_FILENAM, EXIST = EXIST_FILE)
      IF(EXIST_FILE .EQ. .FALSE.) GOTO 1000
C
C FILE EXIST, ASK TO USER IF HE/SHE WANTS TO DELETE
C
      TYPE *, IAM()
      TYPE *, IAM(), 'The File That You Entered Alrready Exist: ', CHAR_FILENAM
      TYPE *, IAM()
      CALL PRMYESNO('Do Yo Want To Delete It [Y/N]?', DELFILE)
C
C CHECK IF USER WANT ABORT OPERATION
C
      IF(DELFILE .EQ. 3) THEN
        TYPE *, IAM()
        CALL GSTOP(GEXIT_OPABORT)      
      ENDIF
C
C IF USER DO NOT WANT DELETE THE FILE, GO TO ENTER AHOTHER NAME
C
      IF(DELFILE .EQ. 2) GOTO 2000
      TYPE *, IAM()
C
C DELETE FILENAME ( ALLWAYS WE HAVE TO DELETE FILE WHEN WE ARE GOING TO COPY )
C
1000  CONTINUE
      FSTS = LIB$DELETE_FILE(CHAR_FILENAM, ';*' ,,,,,,,)
       IF(FSTS .NE. 1 .AND. EXIST_FILE .EQ. .TRUE.) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Deleting File Name: ', CHAR_FILENAM
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C CREATE NEW COPY FILE
C
      CALL CRTFIL(INT_FILENAM, SCFFSZ(PTMF), FSTS)
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE *, IAM(), 'Error Creating File Name: ', CHAR_FILENAM
        TYPE *, IAM()
        CALL GSTOP(GEXIT_FATAL)
      ENDIF
C
C DISPLAY ONE FREE LINE IN CONSOLE
C
      TYPE *, IAM()
C
C INCLUDES GET NEW TRANSACTION FILE NAME
C
      END


C ******************************************************************************
C
C     SUBROUTINE: OPEN_MTMF_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 20 / 12 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO OPEN TRANSACTION MASTER FILE 
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE OPEN_MTMF_FILE(FDB, FILE_NAME)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO OPEN TRANSACTION MASTER FILE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:DESTRA.DEF'
      INCLUDE 'INCLIB:PRMLOG.DEF'
C
C PARAMETERS DEFINITION TO OPEN TRANSACTION MASTER FILE
C
      INTEGER * 4 FDB(*)              ! FILE DESCRIPTOR BLOCK
      INTEGER * 4 FILE_NAME(*)        ! FILE NAME
C
C FUNCTIONS DEFINITION TO OPEN TRANSACTION MASTER FILE
C
      INTEGER * 4 GET_FREE_IDFIL      ! FUNCTION TO GET FREE IDENTIFICAION FILE
C
C VARIABLES DEFINITION TO OPEN TRANSACTION MASTER FILE
C
      INTEGER * 4 IDFIL               ! IDENTIFICATION FILE
      INTEGER * 4 FSTS                ! FUNCTION STATUS
      INTEGER * 4 CNTA                ! COUNTER A
C
C GET FREE IDENTIFICATION FILE FOR NEW MTMF FILE
C
      IDFIL = GET_FREE_IDFIL(1)
C
C OPEN NEW TRANSACTION FILE ( WHEN WE ARE GOING TO COPY TMF FILE )
C
      CALL OPENW(IDFIL, FILE_NAME, 4, 0, 0, FSTS)
      CALL IOINIT(FDB, IDFIL, DBLOCK / 64 * 256)
      CALL TOPEN(IDFIL)
C
C CHECK IF FILE NAME OPEN ERROR
C
      IF(FSTS .NE. 0) THEN
        TYPE *, IAM()
        TYPE 100, IAM(), (FILE_NAME(CNTA), CNTA = 1, 5)
        TYPE *, IAM()
        CALL GPAUSE
      ENDIF
C
C SET TO USER MESSAGE ( OPENING FILE - AND DISPLAY FILE NAME - )
C
      TYPE 200, IAM(), (FILE_NAME(CNTA), CNTA = 1, 5)
C
C THIS IS TO DON'T HAVE COMPILER ERRORS ( WARNNINGS )
C
      TRABUF(TTER) = TRABUF(TTER)
C
C FORMATS DEFINITION TO OPEN TRANSACTION MASTER FILE
C 
100   FORMAT(X, A, 'Error Opening File: ', 5A4)
200   FORMAT(X, A, 'Opening File: ', 5A4)
C
C THIS IS THE END TO OPEN TRANSACTION MASTER FILE
C
      END


C ******************************************************************************
C
C     SUBROUTINE: TEST_COPY_FILE
C     AUTHOR    : J.H.R
C     VERSION   : 01            DATE: 20 / 12 / 2001
C
C ******************************************************************************
C
C PROCEDURE TO TEST COPY TRANSACTION MASTER FILE
C
C=======OPTIONS /CHECK = NOOVERFLOW /EXT
      SUBROUTINE TEST_COPY_FILE(CPY_FILENAM, ORG_FILENAM)
      IMPLICIT NONE
C
C INCLUDES DEFINITION TO TEST COPY TRANSACTION MASTER FILE
C
      INCLUDE 'INCLIB:SYSPARAM.DEF'
      INCLUDE 'INCLIB:SYSEXTRN.DEF'
      INCLUDE 'INCLIB:GLOBAL.DEF'
      INCLUDE 'INCLIB:DESTRA.DEF'
      INCLUDE 'INCLIB:PRMLOG.DEF'
C
C PARAMETERS DEFINITION TO TEST COPY TRANSACTION MASTER FILE
C
      INTEGER * 4 CPY_FILENAM(5)         ! COPY FILE NAME
      INTEGER * 4 ORG_FILENAM(5)         ! ORIGINAL FILE NAME
C
C VARIABLES DEFINITION TO TEST COPY TRANSACTION MASTER FILE
C
      INTEGER * 4 POS                 ! POSITION IN TRABUF BUFFER
      INTEGER * 4 ORG_MTMSERNUM       ! MTMF TRANSACTION SERIAL NUMBER
      INTEGER * 4 CPY_MTMSERNUM       ! COPY MTMF TRANSACTION SERIAL NUMBER
      INTEGER * 4 ORG_LOGREC(LREC * 3)! LOGGER REGISTER ( ORIGINAL )
      INTEGER * 4 CPY_LOGREC(LREC * 3)! LOGGER REGISTER ( COPY )
      INTEGER * 4 CPYTMFFDB(7)        ! TMF FILE DESCRIPTOR BLOCK FOR COPY FILE
      INTEGER * 4 ORGTMFFDB(7)        ! TMF FILE DESCRIPTOR BLOCK FOR ORIGINAL
      INTEGER * 4 ORG_TRABUF(TRALEN)  ! TRANSACTION BUFFER ( ORIGINAL )
      INTEGER * 4 CPY_TRABUF(TRALEN)  ! TRANSACTION BUFFER ( COPY )
C
      LOGICAL EOF                     ! END OF FILE
C
C DISPLAY TASK PRESENTATION TO USER ( WE ARE GOING TO COPY FILE )
C
      TYPE *, IAM()
      TYPE *, IAM(), 'Testing Transaction Master File ...'
      TYPE *, IAM()
C
C OPEN TWO MTMF FILES ( MTMF FILE AND COPY MTMF FILE )
C
      CALL OPEN_MTMF_FILE(CPYTMFFDB, CPY_FILENAM)
      CALL OPEN_MTMF_FILE(ORGTMFFDB, ORG_FILENAM)
C
C INITIATE SERIAL NUMBER TO READ ( TRANSACTION SERIAL NUMBER )
C
      ORG_MTMSERNUM = 1
      CPY_MTMSERNUM = 1
C
C READ TRANSACTION FROM MASTER FILE
C
2000  CONTINUE
      EOF = .FALSE.
      CALL READTMF(ORG_LOGREC, ORG_MTMSERNUM, EOF)
      IF(EOF) GOTO 1000
C
C READ TRABSACTUIB FROM COPY FILE
C
      EOF = .FALSE.
      CALL READTMF(CPY_LOGREC, CPY_MTMSERNUM, EOF)
      IF(EOF) GOTO 1000
C
C SET LOGER TO TRANSACTION
C
      CALL LOGTRA(ORG_TRABUF, ORG_LOGREC)
      CALL LOGTRA(CPY_TRABUF, CPY_LOGREC)
C
C CHECK IF TRANSACTION SERIAL NUMBER IS EQUAL
C
      IF(ORG_MTMSERNUM .NE. CPY_MTMSERNUM) THEN
        TYPE *, IAM()
        TYPE 200, IAM(), ORG_MTMSERNUM, CPY_MTMSERNUM
        RETURN
      ENDIF 
C
C CHECK IF TRANSACTION BUFFERS ARE EQUAL
C
      DO POS = 1, TRALEN
        IF(ORG_TRABUF(POS) .NE. CPY_TRABUF(POS)) THEN
          TYPE *, IAM()
          TYPE *, IAM(), ORG_TRABUF(POS), CPY_TRABUF(POS), ORG_MTMSERNUM, POS
          RETURN
        ENDIF
      ENDDO
C
C GO TO READ NEXT TRANSACTION
C
      GOTO 2000
C
C CLOSE NEW TRANSACTION MASTER FILE ( THE COPY ) AND ORIGIAN MTMF FILE 
C
1000  CONTINUE
      CALL CLOSEFIL(CPYTMFFDB)
      CALL CLOSEFIL(ORGTMFFDB)
C
C THIS IS TO DON'T HAVE COMPILER ERRORS ( WARNNINGS )
C
      TRABUF(TTER) = TRABUF(TTER)
C
C FORMATS DEFINITION TO TEST COPY TRANSACTION MASTER FILE
C
100   FORMAT(X, A, 'Error, Org: ', I, ' Cpy: ', I, ' Serial: ', I, ' Pos: ', I)
200   FORMAT(X, A, 'Error Serial Number Are Not Equal: ' I, ' / ', I)
C
C THIS IS THE END TO TEST COPY TRANSACTION MASTER FILE
C
      END






