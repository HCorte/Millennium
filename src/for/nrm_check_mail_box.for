C
C SUBROUTINE CHECK_MAIL_BOX
C $Log:   GXAFXT:[GOLS]CHECK_MAIL_BOX.FOV  $
C  
C  V03 04-MAY-2011 RXK Waiting time shortened
C     Rev 1.0   17 Apr 1996 12:31:12   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 15:48:10   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - nrm_runtsk.for **
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C CHECK_MAIL_BOX(MBXCHAN,PRCNAME,PRCNAMEXP,PRCID,RETSTAT)
C
C  OBTAINS AN EVENT FLAG, POSTS QIO REQUEST ON THE MAILBOX.
C  IN A LOOP CHECKS THE MAIL BOX AND IF MESSAGE ARRIVED, COMPARES
C  PRCID WITH THE VALUE IN THE ACCOUNTING BLOCK. IF THE VALUE IS
C  DIFFERENT CONTINUES TO CHECK THE MAILBOX SINCE SOME OTHER MESSAGES
C  COULD BE IN THE MAILBOX.
C  IF THERE ARE NO MESSAGES IN THE MAILBOX, CHECK IF THE PROCESS
C  WITH THE SPECIFIED NAME EXISTS. IF YES RETURNS WITH GOOD STATUS.
C  IF THERE ARE NO MESSAGES IN THE MAILBOX AND NO SUBPROCESS WITH 'PRCNAME'
C  IS FOUND - RETURN WITH BAD STATUS.
C
C  INPUT: MBXCHAN - MAILBOX CHANNEL WHERE TERMINTAION MESSAGE MAY COME
C	  PRCNAME - PROCESS NAME (WITHOUT PREFIX)
C	  PRCNAMEXP - PROCESS NAME WITH PREFIX (FOR REPORTING)
C	  PRCID   - PROCESS ID
C  OUTPUT: RETSTAT - CONTAINS THE TERMINATION CODE OF THE PROCESS
C		    (IF ONE TERMINATED)
C
C--------------------------------------------------------------------
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE CHECK_MAIL_BOX(MBXCHAN,PRCNAME,PRCNAMEXP,PRCID,RETSTAT)
        IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
        INCLUDE '($SSDEF)'
        INCLUDE '($SYSSRVNAM)'
        INCLUDE '($ACCDEF)'
        INCLUDE '($IODEF)'
C
C
        INTEGER*2   MBXCHAN
	BYTE        PRCNAME(8)
	CHARACTER   PRCNAMEXP*(*)
        INTEGER*4   PRCID
        INTEGER*4   RETSTAT
	INTEGER*4   FLAG
	INTEGER*4   STATUS
	INTEGER*4   LOCAL_IOSB(2), EF_STATE
	INTEGER*2   LOCAL_IOSB_2(4)
	EQUIVALENCE (LOCAL_IOSB, LOCAL_IOSB_2)
        RECORD	  /ACCDEF/ BUF
C V03
	CHARACTER*80   IMAGE_NAME	    ! V03
	INTEGER*4   NAME_LENGTH
C
C V04	HOW MANY .5 SECONDS TO WAIT FOR THE TERMINATION MESSAGE
C
	INTEGER*4    WAIT_MAX		    ! V04
	PARAMETER   (WAIT_MAX=10)	    ! V04
	INTEGER*4   WAIT_COUNT		    ! V04
C
C V03	SINCE SUCCESSFULL CREATION OF THE PPROCESS DOES NOT GUARANTEE
C V03	A MESSAGE ABOUT NOT BEING ABLE TO LOAD THE PROCESS IMAGE, WE
C V03	NEED TO DO IT OUSELVES BY OBTAINING THE PROCESS STATUS.
C V03	THERE ARE THREE POSSIBILITY:
C V03	1. PROCESS DOES NOT EXIST - CHECK A MESSAGE IN THE MAILBOX. PRINT
C V03	   A MESSAGE ABOUT UNSUCCESSFULL START OF THE PROCESS.
C V03	2. PROCESS EXISTS AND THE IMAGE NAME IS NOT A NULL STRING - PROCESS
C V03	   STARTED AND A MESSAGE WILL BE PRINTED BY IMAGE RUNDOWN IF PROCESS
C V03	   TERMINATES. RETURN SUCCESSFULLY.
C V03	3. PROCESS EXISTS AND THE IMAGE NAME IS A NULL STRING - WAIT UNTILL
C V03	   THE PROCESS STATUS INDICATES 'DOES NOT EXIST' (CASE 1 ABOVE) 
C V03	   OR THE IMAGE IS LOADED (CASE 2 ABOVE).
C
10	CONTINUE				! V03
C
	CALL IMGNAME(PRCID, IMAGE_NAME,NAME_LENGTH,STATUS,PRCNAMEXP)
	IF (STATUS.EQ.4) THEN			! 4 AS USED IN STTTSK
C	    PROCESS TERMINATED - THERE ARE SHOULD BE A MESSAGE IN THE MAILBOX
	    GOTO 50
	ELSE
D	    TYPE *,'IMAGE NAME IS ',IMAGE_NAME
C
C	    PROCESS IS THERE - CHECK THE IMAGE NAME LENGTH
	    IF(NAME_LENGTH.LE.0) THEN
C		WAIT FOR IMAGE TO ACTIVATE
C		'WAIT' IS HELPFULL - OTHERWISE IF PRIORITY OF THE SUBMITTED
C		PROCESS IS LOWER THAN CURRENT PROCESS PRIORITY,
C		WE MAY WAIT FOREVER...
		CALL XWAIT(100, 1, STATUS)
		GOTO 10
	    ELSE
C		IMAGE ACTIVATED - CAN RETURN
		RETSTAT = 0
		GOTO 10000
	    ENDIF
	ENDIF
C
50	CONTINUE				    ! V03
C
        CALL LIB$GET_EF(FLAG)                       !GET AN EVENT FLAG TO USE
        IF(FLAG.EQ.-1)THEN
          TYPE *,IAM(),'FAILED TO GET EVENT FLAG'
          RETSTAT = 1
          GOTO 10000
        ENDIF
C
D        TYPE *,IAM(),'CHANNEL NR ', MBXCHAN
C
C	RETURN HERE IF MORE MESSAGES HAVE TO BE READ
C
100	CONTINUE
        STATUS=SYS$QIO(%VAL(FLAG),%VAL(MBXCHAN),
     *                  %VAL(IO$_READLBLK),
     *                  LOCAL_IOSB,,,BUF,
     *                  %VAL(84),,,,)
        IF(.NOT.STATUS) THEN
          CALL LIB$SIGNAL(%VAL(STATUS))
          RETSTAT = 1
          GOTO 8000
        ENDIF
C V04
	WAIT_COUNT = 0			    ! V04
C V04
1000	CONTINUE			    ! 
C
C	WAIT FOR QIO TO HAVE EFFECT...
C
	CALL XWAIT (10,1,STATUS)            !V03
C
        STATUS = SYS$READEF (%VAL(FLAG), EF_STATE)
        IF (STATUS .EQ. SS$_WASSET) THEN
            STATUS = SYS$WAITFR(%VAL(FLAG))          !WAIT FOR EVENT FLAG
	    IF (.NOT.STATUS .OR. .NOT. LOCAL_IOSB_2(1)) THEN
D		TYPE *,IAM(),'WAITFR STATUS BAD ', STATUS, LOCAL_IOSB_2(1)
	        CALL LIB$SIGNAL(%VAL(STATUS))
		RETSTAT = 1
		GOTO 8000
	    ENDIF
C
C	    GET TERMINATION STATUS FROM ACC DATA
C
	    IF (LOCAL_IOSB(2) .EQ. PRCID) THEN
	        STATUS = BUF.ACC$L_FINALSTS
		IF(.NOT.STATUS) THEN
		    TYPE *,IAM(),'TERMINATION STATUS FOR ',PRCNAMEXP,
     1		      ' IS ',STATUS
C		    TASK TERMINATED, LET CALLING ROUTINE KNOW THAT.
		    RETSTAT = 1
		    GOTO 8000
		ELSE
		    RETSTAT = 0
		    GOTO 8000
		ENDIF
	    ELSE
C
C		MESSAGE ARRIVED BUT PROCESS ID DOES NOT MATCH -
C		READ AND CHECK THE MAILBOX AGAIN
C
		GOTO 100
	    ENDIF
C
	ELSE
C
C	THERE ARE NO MESSAGES IN THE MAILBOX - SYSTEM ERROR... OR
C V04	POSSIBLY PROCESS TERMINATED, BUT IT TAKES LONG TIME FOR VMS
C V04	TO DELIVER A TERMINATION MESSAGE...
C V04 	GO TO CHECK EVENT FLAG AGAIN
C
	    WAIT_COUNT = WAIT_COUNT + 1
	    IF (WAIT_COUNT .LT. WAIT_MAX) THEN
		TYPE *,IAM(),
     *		  'WAITING FOR THE TERMINATION STATUS FROM ',PRCNAMEXP
		GOTO 1000
	    ELSE
		TYPE *,IAM(),
     *		  'FAILED TO GET THE TERMINATION STATUS FOR ',PRCNAMEXP
		RETSTAT = 1
		GOTO 8000
	    ENDIF
        ENDIF
C
8000	CONTINUE
        CALL LIB$FREE_EF(FLAG)
C
10000    CONTINUE
C
	STATUS = SYS$DASSGN (%VAL(MBXCHAN))
	IF (.NOT.STATUS) THEN
	    TYPE *,IAM(), 'ERROR DEASSIGNING MAILBOX: ',
     *		  ' STATUS= ', STATUS
	ENDIF
C
        RETURN
C
        END
