C
C PROGRAM MAILTAPE
C $Log:   GXAFXT:[GOLS]MAILTAPE.FOV  $
C  
C     Rev 1.0   17 Apr 1996 14:00:08   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 16:58:10   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - mailtape.for **
C
C MAILTAPE.FOR
C
C V01 04-APR-90 JPJ INITIAL RELEASE FOR MARYLAND
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM MAILTAPE
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:PRMLOG.DEF'
	INCLUDE 'INCLIB:DESTRA.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:RECSCF.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
C
	INTEGER*4 BOARDS(2,12)
	INTEGER*4    FDB(7), BLKLEN/160/, ST, BLKNUM/0/, LAST
	INTEGER*4    CNT, NUM(6,10), IND, I, K, TMPMAP(2,10)
	INTEGER*4    TEMP, LOGREC(LMUREC), TAPFDB(7), SCFFDB(7)
	INTEGER*4    MXLOG, IOBUF(8192), FLAG, DRWPACK(2), DRWNAM(5)
	INTEGER*4    FILEXT(2), GMSIZE, BLOCK/0/, LENGTH, OFF/1/
	INTEGER*4    MAILNAM/'MAIL'/,J,TAPE,INPLEN
	CHARACTER*20 TMP
	LOGICAL	     SORT
	CHARACTER*20 DEVICE/'MAGX:'/
	CHARACTER*4  CXDRWPCK
	BYTE         BYTBUF(160), TMPINT(96)
	EQUIVALENCE(CXDRWPCK, DRWPACK)
	DATA DRWPACK/'XXXX',':YYY'/
	DATA FILEXT/'.FIL','    '/
C
	MXLOG=(8192-LMUREC)+1
	CALL FASTSET(0,IOBUF,8192)
C
C READ SYSTEM CONTROL FILE
C
	CALL OPENX(1,'SCF.FIL',4,0,0,ST)
	CALL IOINIT(SCFFDB,1,SCFSEC*256)
	IF(ST.NE.0) THEN
	   TYPE*,'SCF.FIL open error > ',ST
	   CALL GPAUSE
	ENDIF
	CALL READW(SCFFDB,1,SCFREC,ST)
	IF(ST.NE.0) THEN
	   TYPE*,'SCF.FIL read error > ',ST
	   CALL GPAUSE
	ENDIF
	CALL CLOSEFIL(SCFFDB)
C
C CHECK THAT DRAWING PACK IS MOUNTED
C
	CALL PRMYESNO('Is the drawing pack mounted? ',FLAG)
	IF(FLAG.NE.1) THEN
	  TYPE*,'Mount drawing pack and continue'
	  CALL GPAUSE
	ENDIF
C
C GET DRAWING PACK VOLUME NAME
C
5	CONTINUE
	CALL PRMTEXT('Enter drawing pack volume name: ',CXDRWPCK,INPLEN)
	IF(DRWPACK(1).EQ.'    ') GOTO 5
C
C CREATE DRAW FILE , COMPUTE SIZE , CREATE FILE AND OPEN
C
	CALL MOVBYT(DRWPACK,1,DRWNAM(1),1,5)
	CALL MOVBYT(MAILNAM,1,DRWNAM(1),6,4)
	CALL BINASC(DRWNAM(1),10,4,DAYCDC)
	CALL MOVBYT(FILEXT(1),1,DRWNAM(1),14,7)
C
C
	GMSIZE=200*128
	CALL CRTFIL(DRWNAM(1),GMSIZE,ST)
	IF(ST.NE.0) THEN
	   WRITE(5,900) (DRWNAM(K),K=1,5),ST
	   CALL GPAUSE
	ENDIF
C
C
C
	CALL OPENW(1,DRWNAM(1),4,0,0,ST)
	CALL IOINIT(FDB,1,128*256)
	IF(ST.NE.0) THEN
	   WRITE(5,902) (DRWNAM(K),K=1,5),ST
	   CALL GPAUSE
	ENDIF
C
C
C
100	CONTINUE
C
        CALL PRMNUM('Enter tape drive number ',TAPE,1,2,ST)
        IF(ST.LT.0) THEN
C
C WRITE LAST BLOCKS AND CALL GSTOP(GEXIT_SUCCESS)
C
	  BLOCK=BLOCK+1
	  CALL WRITEW(FDB,BLOCK,IOBUF,ST)
	  IF(ST.NE.0) THEN
	     WRITE(5,904) (DRWNAM(K),K=1,5),ST,BLOCK
	     CALL GPAUSE
	  ENDIF
	  CALL CLOSEFIL(FDB)
	  CALL GSTOP(GEXIT_SUCCESS)
	ENDIF
C
        DEVICE(4:4) = CHAR(TAPE+48)
	CALL USRCLOS1(     2)
	CALL TAPOPEN(TAPFDB,DEVICE,ST)
	IF(ST.NE.0)THEN
	  TYPE *,'CANNOT OPEN THAT DEVICE'
	  GO TO 100
	ENDIF
	CALL TAPINT(TAPFDB,1,BLKLEN)
	CALL XREWIND(TAPFDB,ST)
C***	CALL FEOT(TAPFDB,ST)
C
C READ TAPE
C
1000	CONTINUE
	CALL RTAPEW(TAPFDB,BYTBUF,ST)
	BLKNUM=BLKNUM+1
	IF(ST.EQ.'88'X)THEN
	  WRITE(5,9011) 1,BLKNUM
9011	  FORMAT(/,' FILE:BLK',I3,':',I5,' *** T A P E M A R K ***'///)
	  CALL PRMTEXT('ENTER GO TO CONTINUE ',TMP,INPLEN)
	  CALL XREWIND(TAPFDB,ST)
	  GOTO 100
	ENDIF
	IF(ST.LT.0) THEN
          TYPE *,'ERROR ON READ=',ST
	  CALL GPAUSE
	ENDIF
C
C GET NUMBERS BET
C
	IND=38
	CNT=0
	DO 1100 I=1,10
	   DO 1200 K=1,6
	      NUM(K,I)=0
	      CALL ASCBIN(BYTBUF,IND,2,NUM(K,I),ST)
	      IF(K.EQ.1.AND.NUM(K,I).GE.1) CNT=CNT+1
	      IND=IND+2
1200	   CONTINUE
1100	CONTINUE
C
C SORT NUMBERS
C
	DO 1130 J=1,CNT
1110       CONTINUE
           SORT=.FALSE.
           DO 1120 I=1,5
           IF(NUM(I,J).GT.NUM(I+1,J)) THEN
             TEMP=NUM(I,J)
             NUM(I,J)=NUM(I+1,J)
             NUM(I+1,J)=TEMP
             SORT=.TRUE.
           ENDIF
1120       CONTINUE
           IF(SORT) GOTO 1110
1130	CONTINUE
 
C
C FILL IN TRABUF
C
	IF(CNT.EQ.0) GOTO 1000
	TRABUF(TSER)=1
	TRABUF(TSTAT)=GOOD
	TRABUF(TCDC)=DAYCDC
	TRABUF(TTYP)=TWAG
	TRABUF(TGAM)=TLTO
	TRABUF(TGAMTYP)=1
	TRABUF(TGAMIND)=1
	TRABUF(TWBEG)=DAYDRW(1)
	TRABUF(TWEND)=DAYDRW(1)
	TRABUF(TWDUR)=1
	TRABUF(TWNBET)=CNT
	TRABUF(TWNMRK)=6
C
C CONVERT NUMBERS TO INTERVAL CODE
C
	CALL FASTSET(0,TMPINT,24)
	IND=0
	DO 1300 I=1,CNT
	   LAST=0
	   DO 1400 K=1,6
	      IF(NUM(K,I).LT.1.OR.NUM(K,I).GT.49) THEN
		TYPE *,'Board data out of range '
		CALL GPAUSE
	      ENDIF
	      TEMP=NUM(K,I)-LAST
	      IND= IND + (TEMP-1)/15 + 1
	      TEMP = TEMP - ((TEMP-1)/15*15)
	      IF(MOD(IND,2).NE.0) THEN
	        TMPINT((IND-1)/2+1)=TMPINT((IND-1)/2+1)+TEMP*16
	      ELSE
		TMPINT((IND-1)/2+1)=TMPINT((IND-1)/2+1)+TEMP
	      ENDIF
	      LAST=NUM(K,I)
1400	   CONTINUE
1300	CONTINUE
 
C
C MOVE INTERVAL CODE INTO TRABUF
C
	CALL MOVBYT(TMPINT,1,TRABUF(TWBORD),1,96)
	CALL INTMAP(TRABUF(TWBORD),1,TRABUF(TWNBET),TRABUF(TWNMRK),
     *              49,BOARDS,ST)
	IF(ST.NE.0) THEN
	  TYPE *,'Bad board data on tape '
	  WRITE(5,999) (TRABUF(TWBORD+K),K=1,24)
   	  WRITE(5,998) (BYTBUF(K),K=1,160)
	  TYPE *,CNT
	  CALL GPAUSE
	ENDIF
999	FORMAT(4(/,1X,6(Z8,1X)))
998	FORMAT(4(/,1X,40(Z2,1X)))
	TRABUF(TSIZE)=1
	IF(IND.GT.16) TRABUF(TSIZE)=2
	IF(IND.GT.76) TRABUF(TSIZE)=3
C
C MOVE INFO INTO BUFFER
C
	LENGTH=LREC*TRABUF(TSIZE)
	CALL TRALOG(TRABUF,LOGREC)
	CALL FASTMOV(LOGREC,IOBUF(OFF),LENGTH)
	OFF=OFF+LENGTH
C
C IF BLOCK IS FULL THEN WRITE IT TO THE RESPECTIVE DRAW FILE
C
	IF(OFF.GT.MXLOG) THEN
	  BLOCK=BLOCK+1
C***********
D	  TYPE *,'WRITING BLOCK',BLOCK,' TO DISK FILE'
C***********
	  CALL WRITEW(FDB,BLOCK,IOBUF,ST)
	  IF(ST.NE.0) THEN
	    WRITE(5,904) (DRWNAM(K),K=1,5),ST,BLOCK
	    CALL GPAUSE
	  ENDIF
	  OFF=1
	  DO 35 I=1,8192
	  IOBUF(I)=0
35	  CONTINUE
	ENDIF
	GOTO 1000
C
C FORMAT SECTION
C
900	FORMAT(1X,5A4,'   Allocation error ',Z8,' on the draw pack')
902	FORMAT(1X,5A4,'   open error > ',Z8,' hex ')
904	FORMAT(1X,5A4,'   write error > ',Z8,' record > ',I4)
906	FORMAT(A4)
	END
