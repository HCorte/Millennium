C
C SUBROUTINE XRUNTSK
C 
C V07 25-JUL-2000 UXN ISDETACHED() AND XRUNTSK_DET ADDED
C V06 17-JUN-2000 UXN CDEC$ OPTIONS /WARNING=NOALIGNMENT added for QUOTA_DEF
C V05 10-FEB-2000 UXN GET_WSDEFAULT and GET_WSQUOTA added.
C V04 15-OCT-1999 UXN WS_DEFAULT set to WSEXTENT to eliminate "FAILED TO
C                     INCREASE WORKNING SET" messages.  
C V03 25-FEB-1998 UXN Call GET_WSEXTENT added.
C V02 20-JUL-1993 JWE Do not increase the priority of tasks if memory 
C                     is not being locked.
C V01 21-JAN-1993 DAB Initial Release
C                     Based on Netherlands Bible, 12/92, and Comm 1/93 update
C                     DEC Baseline
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1999 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C XRUNTSK -
C	DO THE WORK FOR MENTIONED ABOVE ROUITNES
C--------------------------------------------------------------------
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE XRUNTSK(PRGNAME,PRCNAME,WFLG)
	IMPLICIT NONE
C
	BYTE	PRGNAME(8),PRCNAME(8)
	LOGICAL WFLG
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE '($SYSSRVNAM)'
	INCLUDE '($PRVDEF)'
	INCLUDE '($PQLDEF)'
	INCLUDE '($ACLDEF)'
	INCLUDE '($PRCDEF)'
C
	BYTE	    NAMB
	CHARACTER*1 NAMC
	INTEGER*4   STATUS/1/
	INTEGER*4   I,IND, PREFIX_LEN, PROGNAM_LEN
	LOGICAL	    FIRST_TIME/.TRUE./
	CHARACTER*4 EXT/'.EXE'/
	CHARACTER*7 TASKLIB/'TSKLIB:'/
	INTEGER*4   TASKLIB_SZ/7/
	INTEGER*4   TSKSTS(2)
	INTEGER*4   YESNO_FLAG
C
C	FOLLOWING ARE DATA SPACE ALLOCATION FOR
C	PARAMETERS THAT SERVICE SYS$CREPRC REQUIRES
C
	INTEGER*4	PIDADR		! ADDRESS OF CREATED PROCESS ID
	CHARACTER*63	IMAGE		! PROGRAM NAME TO LOAD
	CHARACTER*63	INPUT		! SYS$INPUT  DEFINITION
	CHARACTER*63	OUTPUT		! SYS$OUTPUT DEFINITION
	CHARACTER*63	ERROR		! SYS$ERROR  DEFINITION
	INTEGER*4	PRVADR(2)	! PRIVILEGES
	CHARACTER*8	TERMNAME
C
	EQUIVALENCE	(IMAGE, TASKLIB)
C
	DATA	INPUT /'SYS$INPUT'/
	DATA	OUTPUT/'SYS$OUTPUT'/
	DATA	ERROR /'SYS$ERROR'/
C
CDEC$ OPTIONS /WARNING=NOALIGNMENT
	STRUCTURE	/QUOTA_DEF/
	    BYTE	QUOTA_TYPE	! QUOTA TYPE
	    INTEGER*4	QUOTA_AMOUNT	! QUOTA AMOUNT
	END STRUCTURE
CDEC$ END OPTIONS 
	RECORD /QUOTA_DEF/ QUOTA(PQL$_LENGTH+1)
C
	CHARACTER*15	PRCNAMEXP	! PROCESS NAME EXPANDED
	INTEGER*4	I4PRCNAM
	EQUIVALENCE	(I4PRCNAM, PRCNAMEXP)
	INTEGER*4	BASPRI		! BASE PRIORITY
	INTEGER*4	UIC		! UIC OF CREATED PROCESS
	INTEGER*2	I2UIC(2)
	EQUIVALENCE	(I2UIC,UIC)
C
	INTEGER*2	MBXCHAN, MBXUNT
        INTEGER*4       UNIT
 	INTEGER*4	STSFLG
C
	LOGICAL		PRGPRCDIF
C
	INTEGER*4	WSEXTENT,WSQUOTA,WSDEFAULT
	INTEGER*4	PRCNAMEXP_LEN
C
C CHECK IF CALLING PROCESS IS DETACHED, THEN CREATE ALSO
C DETACHED PROCESS.
C
	IF(ISDETACHED()) THEN
            CALL XRUNTSK_DET(PRGNAME,PRCNAME,WFLG)
	    RETURN
	ENDIF

C
	PRGPRCDIF = .FALSE.
C
C	FOR MULTIPLE GAMING SYSTEMS ON ONE COMPUTER EACH PROCESS SHOULD
C	HAVE A PREFIX IDENTIFYING WICH GAMING ENVIRONMENT THE PROCESS
C	BELONGS
C
	IF (FIRST_TIME) THEN
	    FIRST_TIME = .FALSE.
	    CALL GETPRFX(I4PRCNAM, PREFIX_LEN)
	    CALL GET_WSDEFAULT(WSDEFAULT)
	    CALL GET_WSQUOTA(WSQUOTA)
	    CALL GET_WSEXTENT(WSEXTENT)
	ENDIF
C
C
C BUILD PROGRAM FILE NAME TO BE LOADED
C
C
C LENGTH OF IMAGE IS CHANGED LATER, SO INITIALIZE IT
C
	DO 6, I=TASKLIB_SZ+1,63
	    IMAGE(I:I) = ' '
6	CONTINUE
C
	DO 10 I=1,8
	   NAMB = PRGNAME(I)
	   NAMC = CHAR(NAMB)
	   IF (NAMB .EQ. 0 .OR. NAMC.EQ.' ') THEN
	      GOTO 20
	   ENDIF
	   IMAGE((TASKLIB_SZ+I):(TASKLIB_SZ+I))=NAMC
10	CONTINUE
C
20	CONTINUE
	I = I - 1
	PROGNAM_LEN = I
C
	DO 25 IND=1,4
	   IMAGE(I+IND+TASKLIB_SZ:I+IND+TASKLIB_SZ)=EXT(IND:IND)
25	CONTINUE
C
C	CHECK IF FILE EXISTS
C V02	EVEN WITH RECIEVING TERMINATION MESSAGE IT IS MORE MEANINGFULL
C V02	TO CHECK THE EXISTANCE OF THE FILE
C
	INQUIRE(FILE=IMAGE, EXIST=STATUS)
	IF (.NOT.STATUS) THEN
	    TYPE *,IAM(), 'FILE DOES NOT EXIST: ', 
     *                   IMAGE(1:PROGNAM_LEN+TASKLIB_SZ+4)
	    RETURN
	ENDIF
C
C	LENGTH OF PRCNAMEXP IS CHANGED LATER, SO INITIALIZE IT
C
	DO 30 I=1,8
	   NAMB = PRCNAME(I)
	   IF (NAMB .NE. PRGNAME(I)) THEN
	     PRGPRCDIF = .TRUE.
	   ENDIF
	   NAMC = CHAR(NAMB)
	   IF (NAMB .EQ. 0 .OR. NAMC.EQ.' ') THEN
	      GOTO 40
	   ENDIF
	   PRCNAMEXP((PREFIX_LEN+I):(PREFIX_LEN+I))=NAMC
30	CONTINUE
C
40	CONTINUE
	I = I - 1
C
C	SET PROCESS NAME LENGTH PROPERLY FOR SYSTEM SERVICE CALL
C
C***************
	PRCNAMEXP_LEN = PREFIX_LEN+I
C
C	IF PROCESS NAME IS DIFFERENT FROM PROGRAM NAME, PRINT A MESSAGE
C
	IF (PREFIX_LEN .GT. 0 .OR. PRGPRCDIF) THEN
D	    TYPE *,IAM(),'ACTIVATING ',IMAGE,' AS ', PRCNAMEXP
	ENDIF
C
C	WE WILL GIVE ALL PRIVILEGES THAT THE FATHER HAS
C
	PRVADR(1) = 'FFFFFFFF'X
	PRVADR(2) = 'FFFFFFFF'X
C
C	SET QUOTAS
C
	QUOTA(1).QUOTA_TYPE = PQL$_WSDEFAULT
	QUOTA(1).QUOTA_AMOUNT = WSQUOTA
	QUOTA(2).QUOTA_TYPE = PQL$_WSQUOTA
	QUOTA(2).QUOTA_AMOUNT = WSQUOTA
	QUOTA(3).QUOTA_TYPE = PQL$_WSEXTENT
	QUOTA(3).QUOTA_AMOUNT = WSEXTENT
	QUOTA(4).QUOTA_TYPE = PQL$_LISTEND
C
C	SET STATUS FLAG
C
	STSFLG = PRC$M_DISAWS		! DISABLE WORKING SET ADJUSTMENT
     1  .OR.     PRC$M_PSWAPM	        ! INHIBIT PROCESS SWAPPING
C     *  .OR.     PRC$M_DETACH	        ! MAKE A DETCHED PROCESS
C
C	USE UIC OF THE CREATING PROCESS
C
	I2UIC(1) = 0
	I2UIC(2) = 0
C
C	GET NAME OF THE TERMINAL DEVICE
C
	CALL GETTERM(TERMNAME, STATUS)
	IF (STATUS .EQ. 0) THEN
D	    TYPE *,IAM(),'RUNTSK: OUTPUT DEVICE NAME IS - ',TERMNAME
	    INPUT = TERMNAME
	    OUTPUT = INPUT
	    ERROR  = INPUT
	ELSE
	    TYPE *,IAM(),'RUNTSK: FAILED TO OBTAIN TERMNAME '
	ENDIF
C
C       GET MAILBOX UNIT
C
        CALL GET_MAIL_UNIT(UNIT, MBXCHAN)
        MBXUNT = UNIT
D        TYPE *,IAM(),'MBXUNT, MBXCHAN ', MBXUNT, MBXCHAN
C
C	ISSUE THE CALL
C
	IF (P(LOCK_PAGES_MEM) .NE. NOLOCK_PAGES_MEM_VALUE) THEN
		BASPRI = 6
	ELSE
		BASPRI = 4
	ENDIF
C
	STATUS = SYS$CREPRC (PIDADR, IMAGE, INPUT,
     *			     OUTPUT, ERROR,
     *			     PRVADR, QUOTA,
     *			     %DESCR(PRCNAMEXP(1:PRCNAMEXP_LEN)),
     *			     %VAL(BASPRI),
     *			     %VAL(UIC), %VAL(MBXUNT), %VAL(STSFLG))
C
C	CHECK THE STATUS
C
	IF (.NOT.STATUS) THEN
	    TYPE *,IAM(), 'ERROR ACTIVATING TASK: ', IMAGE,
     *		  ' STATUS= ', STATUS
	    GOTO 70
	ENDIF
C
C       WAIT UNTIL THE MAIL BOX HAS ANY MESSAGES OR TASK STATUS
C       INDICATES THAT THE PROCESS STARTED
C
D       TYPE *,IAM(),'PROCESS ID ', PIDADR
C
50      CONTINUE
C
        CALL CHECK_MAIL_BOX(MBXCHAN,PRCNAME,PRCNAMEXP(1:PRCNAMEXP_LEN),
     *                      PIDADR,STATUS)
	IF(STATUS .NE. 0) THEN
	    TYPE *,IAM(), 'ERROR ACTIVATING TASK: ', PRCNAMEXP
	    GOTO 70
	ENDIF
CC
	IF (.NOT.WFLG) THEN
	   GOTO 10000
	ENDIF
60	CONTINUE
	CALL XWAIT(2,2,STATUS)
	CALL STTSK(PRCNAME,TSKSTS,STATUS)
	IF (STATUS.NE.4) THEN
	   GOTO 60
	ENDIF
C
C COMMON RETURN
C
10000	CONTINUE
	RETURN
C
C PROGRAM RUN ERROR
C
70	CONTINUE
	CALL INPYESNO('Do you want to continue [Y/N]',YESNO_FLAG)
	IF (YESNO_FLAG.EQ.1) GOTO 10000
	WRITE(6,904) PRCNAME
	CALL GSTOP(GEXIT_SUCCESS)
C
C FORMAT AREA
C
904	FORMAT(1X,'***  RUNTSK PROCEDURE ABORTED FOR ',8A, ' ***')
	END
