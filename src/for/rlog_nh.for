C RLOG_NH.FOR - Read LOG with No Hold.
C
C V01 21-Feb-96 MP  Released for Finland telephone betting.
C		    Produced from RLOG by replacing HOLD with XWAIT and
C		    not using TSKMAP.
C
C LOGGER READ SUBROUTINE to be used by tasks that do not have task queue
C and do not care to do XWAIT instead of HOLD. 
C
C If DAYSTS is not equal to DSOPEN, read TM file using off-line RLOG.
C since LOGGER is not doing it's work in such cases.
C
C If DAYSTS is equal to DSOPEN, 
C READ TRANSACTION FROM APPROPIATE LOGGER MEMORY BUFFER.
C IF BUFFER NOT CURRENTLY IN MEMORY REQUEST BUFFER
C TO BE READ AND WAIT FOR COMPLETION.
C
C IF RECORD TYPE IS NOT SET TO ONE OR TWO (ONE RECORD TRANSACTION,
C OR FIRST RECORD OF A MULTI-RECORD TRANSACTION) THEN RETURN WITH
C A LOGGER READ ERROR. IF RECORD IS A FIRST RECORD OF A MULTI-
C RECORD TRANSACTION THEN RETURN ALL THREE TRANSACTION RECORDS.
C
C CALLING SEQUENCE:
C     CALL RLOG_NH(SERIAL,RECORD, DUMMY,STATUS)
C INPUT
C     SERIAL   -  TRANSACTION SERIAL NUMBER
C     RECORD   -  TRANSACTION LOG RECORD
C     DUMMY    -  used just for compatibility of calling sequence with RLOG.
C OUTPUT
C     STATUS   - (0-OK,-1 - LOGGER READ ERROR)
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1991 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE RLOG_NH(SERIAL,RECORD,TASK,STATUS)
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:LOGCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:DESLOG.DEF'
C
	INTEGER*4 RECORD(LREC*3), K, LENGTH, TYPE, BL, ST, OFFSET
	INTEGER*4 INDEX, BLOCK, STATUS, TASK, SERIAL, DUMMY
	LOGICAL   FIRST /.TRUE./
C
C If day is closed, use off-line RLOG.
C
	IF(DAYSTS .NE. DSOPEN) THEN
	  IF(FIRST) THEN
	    CALL TOPEN(PTMF)
	    FIRST = .FALSE.
	  ENDIF
	  CALL RLOG(SERIAL,RECORD,DUMMY,STATUS)
	  RETURN
	ENDIF
C
C CHECK IF TRANSACTION HAS BEEN LOGGGED
C YET, IF NOT RETURN STATUS OF -1.
C
5	CONTINUE
	STATUS=0
	IF(MOD(SERIAL,SYSOFF).GT.MOD(HRSER,SYSOFF).OR.SERIAL.LE.0)THEN
	    STATUS=-1
	    RETURN
	ENDIF
C
C GET TRANSACTION BLOCK AND INDEX
C
	CALL GETBI(SERIAL,BLOCK,INDEX,OFFSET)
	OFFSET=OFFSET+LOGHDR-1
C
C SCAN MEMORY RESIDENT FILE BLOCKS FOR
C THIS BLOCK.
C
10	CONTINUE
	IF(LOKON(P(LOGFLG))) THEN
15	  CONTINUE
	  IF(P(LOGFLG).NE.0) THEN
	    CALL XWAIT(5,1,ST)
	    GOTO 15
	  ENDIF
	  GOTO 10
	ENDIF
C
C
	  DO 1000 BL=1,NUMLOG
	  IF(LOGBUF(BLONUM,BL).NE.BLOCK) GOTO 1000
C
C IF STATUS EQUALS READY FOR I/O THEN
C READ TRANSACTION FROM BUFFER.
C
	    IF(LOGBUF(BSTATE,BL).EQ.LGRDY.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGUSD.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGRRW.OR.
     *	    LOGBUF(BSTATE,BL).EQ.LGROU) THEN
C
C EXTRACT RECORD TYPE FROM LOG BUFFER
C IF RECORD TYPE IS INVALID RETURN WITH ERROR
C IF FIRST RECORD OF A MULTI-RECORD TRANSACTION
C THEN DETERMINE HOW MANY RECORDS ARE USED.
C
C***	      TYPE=LOGBUF(OFFSET+LREC-1,BL)
	      CALL ILBYTE(TYPE, LOGBUF(OFFSET,BL), LREC1-1)
	      TYPE=IAND(TYPE,7)
	      IF(TYPE.NE.LREG.AND.TYPE.NE.LONE) THEN
	        IF(LOGBUF(BSTATE,BL).EQ.LGRRW) LOGBUF(BSTATE,BL)=LGUSD
	        CALL LOKOFF(P(LOGFLG))
	        STATUS=-1
	        RETURN
	      ENDIF
	      LENGTH=LREC
	      IF(TYPE.EQ.LONE) THEN
C***	        TYPE=LOGBUF(OFFSET+LREC*2-1,BL)
		CALL ILBYTE(TYPE, LOGBUF(OFFSET,BL), LREC2-1)
	        TYPE=IAND(TYPE,7)
	        IF(TYPE.EQ.LEND) LENGTH=LREC*2
	        IF(TYPE.EQ.LTWO) LENGTH=LREC*3
	      ENDIF
C
	        CALL FASTMOV(LOGBUF(OFFSET,BL),RECORD(1),LENGTH)
	        OFFSET=OFFSET+LENGTH
	        IF(LENGTH.LT.LREC*3) THEN
	          CALL FASTSET(0,RECORD(LENGTH+1),LREC*3-LENGTH)
	        ENDIF
C
C IF BUFFER STATUS IS READY FOR RE-WRITE, RELEASE BUFFER FOR USE
C
	      IF(LOGBUF(BSTATE,BL).EQ.LGRRW) LOGBUF(BSTATE,BL)=LGUSD
C
C ALWAYS EXIT CRITICAL REGION
C
	      CALL LOKOFF(P(LOGFLG))
C
	      RETURN
	    ELSE
C
C IF ANY OTHER BLOCK STATUS -
C EXIT CRITICAL REGION,
C KICK LOGGER AND,
C WAIT FOR COMPLETION.
C
	      CALL LOKOFF(P(LOGFLG))
C
	      CALL RELSE(TSKNAM(LOG),ST)
	      CALL XWAIT(50,1,ST)
	      GOTO 10
	    ENDIF
1000	  CONTINUE
C
C BLOCK NOT FOUND ALLOCATE A USED BLOCK
C AND REQUEST BLOCK TO BE READ.
C ROUND ROBIN SEARCH TO GIVE EVERYONE A CHANCE.
C
	  DO 2000 K=1,NUMLOG
	  BL=SBLOCK
	  BL=MOD(BL,NUMLOG)+1
	  SBLOCK=BL
	  IF(LOGBUF(BSTATE,BL).NE.LGUSD) GOTO 2000
	  LOGBUF(BLONUM,BL)=BLOCK
	  LOGBUF(LOGCNT,BL)=0
	  LOGBUF(BLTAPE,BL)=0
	  LOGBUF(BSTATE,BL)=LGRIN
C
C ALWAYS EXIT CRITICAL REGION
C
	  CALL LOKOFF(P(LOGFLG))
C
	  CALL RELSE(TSKNAM(LOG),ST)
	  CALL XWAIT(50,1,ST)
	  GOTO 10
2000	  CONTINUE
C
C NO BUFFERS AVAILABLE -
C EXIT CRITICAL REGION,
C release LOGGER,
C wait
C
	CALL LOKOFF(P(LOGFLG))
C
	CALL RELSE(TSKNAM(LOG),ST)
	CALL XWAIT(50,1,ST)
	GOTO 10
	END
