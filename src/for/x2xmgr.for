C
C PROGRAM X2XMGR
C
C*************************** START X2X PVCS HEADER ****************************
C
C  $Logfile::   GXAFXT:[GOLS]X2XMGR.FOV                                   $
C  $Date::   17 Apr 1996 16:43:20                                         $
C  $Revision::   1.0                                                      $
C  $Author::   HXK                                                        $
C
C**************************** END X2X PVCS HEADER *****************************
C
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - x2xmgr.for;1 **
C
C X2XMGR.FOR
C
C V04 12-DEC-94 DAS Integrate UK changes into X2X Baseline
C V01 28-NOV-90 XXX RELEASED FOR VAX
C
C     THE FUNCTION OF THIS PROGRAM IS TO FULLFILL TRANSPORT
C     LAYER PROTOCOL REQUIREMNTS TO CONNECT GAME WITH THE OUTSIDE
C     WORLD.
C
C     ENTRY POINTS:
C     X2CLOSE(SAP,QUE)         CLOSE SAP
C     X2OPEN(SAP,QUE,MODE)     OPEN SAP
C     X2SNDCMD(SAP,COMMAND)    SEND TRANSPORT LAYER COMMAND
C
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C This item is the property of GTECH Corporation, Providence, Rhode
C Island, and contains confidential and trade secret information. It
C may not be transferred from the custody or control of GTECH except
C as authorized in writing by an officer of GTECH. Neither this item
C nor the information it contains may be used, transferred,
C reproduced, published, or disclosed, in whole or in part, and
C directly or indirectly, except as expressly authorized by an
C officer of GTECH, pursuant to written agreement.
C
C Copyright 1994 GTECH Corporation. All rights reserved.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C=======OPTIONS /CHECK=NOOVERFLOW
	PROGRAM X2XMGR
	IMPLICIT NONE
C
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
C
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:LANCOM.DEF'
	INCLUDE 'INCLIB:X2TDBH.DEF'
	INCLUDE 'INCLIB:TASKID.DEF'
	INCLUDE 'INCLIB:LANEVN.DEF'
	INCLUDE '($IODEF)'
        INCLUDE '($SSDEF)'
        INCLUDE '($SYSSRVNAM)'
C
        CHARACTER     GXEVNNAM*4        !Event name function        
C
	INTEGER*4 RESEND_BEGIN(X2X_SAP)    !SEND BEGIN COUNT
	INTEGER*4 STATUS, REDO_LOOP, BUF
	INTEGER*4 LOOP_SAP, LOOP_MAINTENANCE, SAP, QUE, ST
	INTEGER*4 NEXT_SHUTDOWN_LOOP, LOCAL_TIME, GAME_IS_UP
	INTEGER*4 NEXT_FLUSH_TIME
	INTEGER*4 SECONDS_INDEX, SUBNETWORK_INDEX, CURRENT_VOLUME
	INTEGER*4 LAST_TIME, EXTRA_TRANSACTIONS
	INTEGER*4 CLEAR_MAINT_OPTIONS_STATS
C
	CALL COPYRITE
C V03
	CALL SNIF_AND_WRKSET
C
C CREATE THE COMMON EVENT FLAG CLUSTER.
C
        STATUS=SYS$ASCEFC(%VAL(LN_EVNTIMER),GXEVNNAM()//LN_EVNNAME,0,0)
        IF(.NOT.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
C
	CALL FASTSET(0,X2XT_PRO,X2X_TERMS/2)
	CALL FASTSET(0,RESEND_BEGIN,X2X_SAP)
	NEXT_FLUSH_TIME=0
        X2XS_STATS_PNT = 1       !INIT STATISTICS POINTER
C
	IF (X2X_GAME_SAP.LE.0 .OR. X2X_LOOP_DELAY.LE.0) THEN
	   TYPE *,IAM(),'Invalid game sap ',X2X_GAME_SAP
	   CALL GSTOP(GEXIT_SUCCESS)
	ENDIF
C
C     OPEN GAME SAP, CLOSE IT FIRST JUST IN CASE IT WAS PREVIOUSLY
C     OPENED
C
	X2X_GAME_STATE=X2X_GAMES_IDLE
	GAME_IS_UP=0
	LOCAL_TIME=0
C
10	CONTINUE
	NEXT_SHUTDOWN_LOOP=0
C
20	CONTINUE
C
	IF(X2X_GAME_CHECK.EQ.X2X_GAMEC_REQ) X2X_GAME_CHECK=X2X_GAMEC_UP
C
	IF (X2X_GAME_STATE.EQ.X2X_GAMES_IDLE) THEN
	   CALL XWAIT(500,1,ST)     !WAIT SOME
	   LOCAL_TIME=LOCAL_TIME+500
C
C     TELL X2XPRO TO FLUSH DATA TO DISK
C
	   IF (LOCAL_TIME.GT.NEXT_FLUSH_TIME) THEN
	     X2XPRO_FLUSH=-1
	     NEXT_FLUSH_TIME=LOCAL_TIME+X2XPRO_FLUSH_INT
	     IF(X2XPRO_FLUSH_INT.EQ.0)NEXT_FLUSH_TIME=LOCAL_TIME+10000
	     CALL RELSE(TSKNAM(X2P),ST)
	   ENDIF
	   GOTO 10
	ELSEIF (X2X_GAME_STATE.EQ.X2X_GAMES_SHUTDOWN) THEN
	   NEXT_SHUTDOWN_LOOP=NEXT_SHUTDOWN_LOOP+1
	   IF (NEXT_SHUTDOWN_LOOP.GE.30) THEN
	      QUE=X2X_GAME_QUE
	      IF (GAME_IS_UP.EQ.0) THEN
	         CALL X2CLOSE(X2X_GAME_SAP,QUE)
	      ENDIF
	      CALL X2KILL
	      CALL GSTOP(GEXIT_SUCCESS)
	   ENDIF
	   GOTO 20
	ELSEIF (X2X_GAME_STATE.EQ.X2X_GAMES_REQUP) THEN
	   QUE=X2X_GAME_QUE
	   IF (GAME_IS_UP.EQ.0)
     *	   CALL X2CLOSE(X2X_GAME_SAP,QUE)!CLOSE IT FIRST,WAIT RESPONCE
	   CALL X2OPEN(X2X_GAME_SAP,QUE,LANMPRI) !OPEN SAP
	   X2X_GAME_STATE=X2X_GAMES_UP
	   GAME_IS_UP=0
	   GOTO 30
	ELSE
	   TYPE *,IAM(),'Invalid game status ',X2X_GAME_STATE
	   CALL GSTOP(GEXIT_SUCCESS)
	ENDIF
C
30	CONTINUE
C
C     WAIT SOME TIME IF NOTHING TO DO
C
C
	IF(X2X_GAME_CHECK.EQ.X2X_GAMEC_REQ) X2X_GAME_CHECK=X2X_GAMEC_UP
	IF (X2X_GAME_STATE.NE.X2X_GAMES_UP) THEN
	   IF (GAME_IS_UP.EQ.0) THEN
	      QUE=X2X_GAME_QUE
	      CALL X2CLOSE1(X2X_GAME_SAP,QUE)!CLOSE IT FIRST
	      GAME_IS_UP=-1
	   ELSE
C
C        CHECK IF ALL SAPS ARE CLOSED, IF SO, GOTO IDLE STATE
C
	      DO 40, SAP=1,X2X_SAP
	        IF (X2XE_DEF_STATUS(SAP).NE.X2XES_NOTUP) GOTO 60
40	      CONTINUE
	      GOTO 10
	   ENDIF
	ELSE
	   IF (GAME_IS_UP.NE.0) THEN !IF GAME WAS CLOSED, WAIT TILL
C                                   EVERYTHING CLOSED AND REOPEN
	      DO 50, SAP=1,X2X_SAP
	        IF (X2XE_DEF_STATUS(SAP).NE.X2XES_NOTUP) GOTO 60
50	      CONTINUE
	      GOTO 10
	   ENDIF
	ENDIF
C
60	CONTINUE
C
	CALL XWAIT(X2X_LOOP_DELAY,1,ST)         !MAIN WAIT LOOP
	X2XA_LASTDELAY_TIME=X2XA_LASTDELAY_TIME+X2X_LOOP_DELAY
C
C       P(ACTTIM) IS NORMALLY SET IN DISPATCH HOWEVER DISPATCH IS
C       NOT ACTIVE DURING NIGHTGAME SO IT MUST BE SET HERE
C
        IF(X2X_GAME_MODE.EQ.X2X_GAMEM_NIGHT) THEN
          CALL GETTIM(P(ACTTIM))
        ENDIF
	X2X_SYSTIM=P(ACTTIM)
	X2X_LOOP_TIME=X2X_LOOP_TIME+X2X_LOOP_DELAY
C
C     CHECK IF IT HAS TO SEND MEANTANANCE BLOCKS
C
	LOOP_MAINTENANCE=0
	LOOP_SAP=0
	IF (X2X_LOOP_MAINTENANCE.LT.X2X_LOOP_TIME) THEN
	   LOOP_MAINTENANCE=-1
	   LOOP_SAP=-1
           X2X_LOOP_MAINTENANCE=X2X_LOOP_TIME+
     *       X2X_LOOP_MAINTENANCE_DELAY
	   X2X_LOOP_SAP=X2X_LOOP_TIME+X2X_LOOP_SAP_DELAY
C
C
	ELSEIF (X2X_LOOP_SAP.LT.X2X_LOOP_TIME) THEN
	      X2X_LOOP_SAP=X2X_LOOP_TIME+X2X_LOOP_SAP_DELAY
	      LOOP_SAP=-1
	ENDIF
C
C     TRY TO PROCESS STATS
C
        IF (X2X_STATS_LOOP.LT.X2X_LOOP_TIME) THEN
              CALL X2STATS       !UPDATE STATISTICS
              IF (X2XS_STATS_TIME.EQ.0) X2XS_STATS_TIME=60000
              X2X_STATS_LOOP=X2X_LOOP_TIME+X2XS_STATS_TIME
        ENDIF
	IF (X2XA_LASTDELAY_TIME.GT.X2XA_LASTDELAY_INTERVAL) THEN
	   X2XA_LASTDELAY_INDEX=X2XA_LASTDELAY_INDEX+1
	   IF (X2XA_LASTDELAY_INDEX.GT.2) X2XA_LASTDELAY_INDEX=1
	   CALL FASTSET(0,X2XA_LASTDELAY(0,0,X2XA_LASTDELAY_INDEX),
     *	              (X2X_MAXDELAY+1)*X2X_MAX_DELAY_SUBNET)
           X2XA_LASTDELAY_TIME=0
	ELSE
	   IF (X2XA_LASTDELAY_INDEX.EQ.0) X2XA_LASTDELAY_INDEX=1
	ENDIF
C
C     TELL X2XPRO TO FLUSH DATA TO DISK
C
	IF (X2X_LOOP_TIME.GT.NEXT_FLUSH_TIME) THEN
	   X2XPRO_FLUSH=-1
	   NEXT_FLUSH_TIME=X2X_LOOP_TIME+X2XPRO_FLUSH_INT
	   IF(X2XPRO_FLUSH_INT.EQ.0)NEXT_FLUSH_TIME=X2X_LOOP_TIME+10000
	   CALL RELSE(TSKNAM(X2P),ST)
	ENDIF
C
C
C     PROCESS INCOMING AND OUTCOMMING BUFFERS LOOP
C
100	CONTINUE
C
C	UPDATE VOLUME STATISTICS FOR DROPPING/FLUSHING MESSAGES
C
	IF (P(ACTTIM).NE.LAST_TIME) THEN
	    LAST_TIME=P(ACTTIM)
	    X2XSN_CURRENT_UPDATE_POINTER= MOD(
     *	    X2XSN_CURRENT_UPDATE_POINTER+1,X2X_SECS_VOLUME_MEASUREMENT+1)
C
C	RECEIVE FLUSH LOGIC
	    DO 130, SUBNETWORK_INDEX=0,X2X_MAX_SUBNETWORK
	      IF (X2XSN_MAX_THRUPUT(SUBNETWORK_INDEX).LE.0) GOTO 130
	      CURRENT_VOLUME=0
	      DO 110, SECONDS_INDEX=0,X2X_SECS_VOLUME_MEASUREMENT
		    CURRENT_VOLUME=X2XSN_CURRENT_VOLUME(SECONDS_INDEX,
     *				  SUBNETWORK_INDEX)+CURRENT_VOLUME
110	      CONTINUE
	      X2XSN_CURRENT_VOLUME(X2XSN_CURRENT_UPDATE_POINTER,
     *			      SUBNETWORK_INDEX)=0
	      IF (CURRENT_VOLUME.LE.(X2X_SECS_VOLUME_MEASUREMENT+1)*
     *		  X2XSN_MAX_THRUPUT(SUBNETWORK_INDEX)) THEN
		  X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX)=0
	      ELSE

C	      EXTRA TRANSACTIONS/SEC
	
		  EXTRA_TRANSACTIONS = (CURRENT_VOLUME- 
     *		    (X2X_SECS_VOLUME_MEASUREMENT+1)*
     *			  X2XSN_MAX_THRUPUT(SUBNETWORK_INDEX))/
     *		    (X2X_SECS_VOLUME_MEASUREMENT+1)

		  IF (EXTRA_TRANSACTIONS.GT.0) THEN
		    X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX)=
     *		      X2XSN_MAX_THRUPUT(SUBNETWORK_INDEX)/EXTRA_TRANSACTIONS
		    IF (X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX).EQ.0)
     *		      X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX)=1
		    IF (X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX).LE.20) 
     *		      CALL OPS('Flush more than 5 % [ratio/subnetwork] ',
     *		        X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX),
     *		        SUBNETWORK_INDEX)
		  ELSE
		    X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX)=0
		  ENDIF

		  X2XSN_CURRENT_FLUSH(SUBNETWORK_INDEX)=
     *		    X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX)
	      ENDIF
130	   CONTINUE
C
C	SEND FLUSH LOGIC

	    DO 140, SUBNETWORK_INDEX=0,X2X_MAX_SUBNETWORK
	      IF (X2XSN_MAX_THRUPUT_SEND(SUBNETWORK_INDEX).LE.0) GOTO 140
	      CURRENT_VOLUME=0
	      DO 135, SECONDS_INDEX=0,X2X_SECS_VOLUME_MEASUREMENT
		    CURRENT_VOLUME=
     *		      X2XSN_CURRENT_VOLUME_SEND(SECONDS_INDEX,
     *				  SUBNETWORK_INDEX)+CURRENT_VOLUME
135	      CONTINUE
	      X2XSN_CURRENT_VOLUME_SEND(X2XSN_CURRENT_UPDATE_POINTER,
     *			      SUBNETWORK_INDEX)=0
	      IF (CURRENT_VOLUME.LE.(X2X_SECS_VOLUME_MEASUREMENT+1)*
     *		  X2XSN_MAX_THRUPUT_SEND(SUBNETWORK_INDEX)) THEN
	  X2XSN_FLUSH_RATIO_SEND(SUBNETWORK_INDEX)=0
	      ELSE

C	      EXTRA TRANSACTIONS/SEC
	
		  EXTRA_TRANSACTIONS = (CURRENT_VOLUME- 
     *		    (X2X_SECS_VOLUME_MEASUREMENT+1)*
     *			  X2XSN_MAX_THRUPUT_SEND(SUBNETWORK_INDEX))/
     *		    (X2X_SECS_VOLUME_MEASUREMENT+1)

		  IF (EXTRA_TRANSACTIONS.GT.0) THEN
		    X2XSN_FLUSH_RATIO_SEND(SUBNETWORK_INDEX)=
     *		      X2XSN_MAX_THRUPUT_SEND(SUBNETWORK_INDEX)/
     *			    EXTRA_TRANSACTIONS
		    IF (X2XSN_FLUSH_RATIO_SEND(SUBNETWORK_INDEX).EQ.0)
     *		      X2XSN_FLUSH_RATIO_SEND(SUBNETWORK_INDEX)=1
		    IF (X2XSN_FLUSH_RATIO(SUBNETWORK_INDEX).LE.20) 
     *		      CALL OPS('Flush send over 5 % [ratio/subnet] ',
     *		        X2XSN_FLUSH_RATIO_SEND(SUBNETWORK_INDEX),
     *		        SUBNETWORK_INDEX)
		  ELSE
		    X2XSN_FLUSH_RATIO_SEND(SUBNETWORK_INDEX)=0
		  ENDIF

		  X2XSN_CURRENT_FLUSH_SEND(SUBNETWORK_INDEX)=
     *		    X2XSN_FLUSH_RATIO_SEND(SUBNETWORK_INDEX)
	      ENDIF
140	   CONTINUE
	ENDIF

	QUE=X2X_GAME_QUE
	CALL X2GETAPP(BUF,QUE,ST)
	IF (ST.NE.2) THEN         !IF ANY TO DO
	   CALL X2RCVBUF(BUF)
	   CALL LANRELB(BUF)
	   REDO_LOOP=-1
	ELSE
	   CALL X2SNDBUF(STATUS)
	   REDO_LOOP=0
	ENDIF
C
C     FOR ALL SAP CHECKS IF SHOULD CHECK BEGIN/RESET
C     OR TO SEND MAINTENANCE PACKAGE (LOOPBACK PACKAGE)
C     OR TO SEND OUTSTANDING BUFFER
C

	CLEAR_MAINT_OPTIONS_STATS=
     *	      IAND(X2XEM_OPTIONS_STATS_MASK,X2XE_MAINT_OPTIONS)
	IF (LOOP_SAP.NE.0) THEN
C
	DO 150, SAP=1,X2X_SAP
	   IF (X2XE_DEF_STATUS(SAP).EQ.X2XES_NOTUP) GOTO 150 ! NO SAP
C
	   IF (X2XE_FORMAT_TIME(SAP).LT.X2X_LOOP_TIME.AND.
     *	       X2XE_BUF(SAP).GT.0) THEN       !TIME TO SEND DATA
	      CALL X2SNDLAN(X2X_GAME_SAP,SAP,X2XE_BUF(SAP),
     *	                    X2XE_INDEX(SAP))
	      X2XE_BUF(SAP)=-1
	   ENDIF
C
	   IF (LOOP_MAINTENANCE.NE.0) THEN
	      RESEND_BEGIN(SAP)=RESEND_BEGIN(SAP)+1
	      IF (RESEND_BEGIN(SAP).GE.X2XE_RESEND_BEGIN)
     *	               RESEND_BEGIN(SAP)=1
	      IF (X2XE_ACT_STATUS(SAP).EQ.X2XE_DEF_STATUS(SAP).AND.
     *	          RESEND_BEGIN(SAP).NE.X2XE_RESEND_BEGIN) THEN
	         CALL X2SNDCMD(SAP,X2TDBHT_MAINTENANCE_REQ)
	         X2XE_MAINTENANCE_START(SAP)=X2X_LOOP_TIME
	      ELSE
	         CALL X2SNDCMD(SAP,X2TDBHT_BEGIN)
	      ENDIF
	   ENDIF
150	CONTINUE
C
	IF (LOOP_MAINTENANCE.NE.0 .AND. CLEAR_MAINT_OPTIONS_STATS.NE.0)
     *	   X2XE_MAINT_OPTIONS=
     *      IEOR(CLEAR_MAINT_OPTIONS_STATS,X2XE_MAINT_OPTIONS)
	LOOP_MAINTENANCE=0
	LOOP_SAP=0
	ENDIF
C
	IF (REDO_LOOP.NE.0) GOTO 100
	GOTO 30
	END
