C
C SUBROUTINE BLDGRP
C $Log:   GXAFXT:[GOLS]BLDGRP.FOV  $
C  
C     Rev 1.0   17 Apr 1996 12:18:30   HXK
C  Release of Finland for X.25, Telephone Betting, Instant Pass Thru Phase 1
C  
C     Rev 1.0   21 Jan 1993 15:43:28   DAB
C  Initial Release
C  Based on Netherlands Bible, 12/92, and Comm 1/93 update
C  DEC Baseline
C
C ** Source - gngroup.for **
C
*
* ========================================================
* SUBROUTINE BLDGRP
*
* This subroutine will build the group message and
* will send it to TCP/IP.
*
* Input parameters:
*
*     OUTGRP      Int*4       Group number
*     MESTYP      Int*4       Message type
*     SUBTYP      Int*4       Message subtype
*     MSGID       Int*4       PC message identifier
*     MSGSEQ      Int*4       Message sequence number
*
* Ouput paramters:
*
*     MESLEN      Int*4       Message length
*
C=======OPTIONS /CHECK=NOOVERFLOW
	SUBROUTINE BLDGRP(OUTGRP,MESTYP,SUBTYP,MSGID,MSGSEQ,MESLEN)
	IMPLICIT NONE
*
	INCLUDE 'INCLIB:SYSPARAM.DEF'
	INCLUDE 'INCLIB:SYSEXTRN.DEF'
*
	INCLUDE 'INCLIB:GLOBAL.DEF'
	INCLUDE 'INCLIB:X2XCOM.DEF'
	INCLUDE 'INCLIB:CONCOM.DEF'
	INCLUDE 'INCLIB:GNSMES.DEF'
	INCLUDE 'INCLIB:X2XGRP.DEF'
*
	INTEGER*4   OUTGRP              !Group number
	INTEGER*4   MESTYP              !Message type
	INTEGER*4   SUBTYP              !Message subtype
	INTEGER*4   MSGID               !PC message identifier
	INTEGER*4   MSGSEQ              !Message sequence number
	INTEGER*4   MESLEN              !Message length
	INTEGER*4   MESS(400)           !Output buffer
	INTEGER*4   OFF                 !Data message offset
	INTEGER*4   CURTIM              !Current system time
	INTEGER*4   I
	INTEGER*4   ST
*
* CHECK FOR A VALID GROUP NUMBER.
*
	IF(OUTGRP.LT.1 .OR. OUTGRP.GT.X2X_NUM_GROUPS) THEN
	  MESLEN=-1
	  GOTO 8000
	ENDIF
*
* CHECK FOR A USED GROUP NUMBER.
*
	IF(X2XG_CNT(OUTGRP).EQ.0) THEN
	  MESLEN=-1
	  GOTO 8000
	ENDIF
*
* READ THE GROUP FROM THE GROUP FILE.
*
	CALL READW(X2XGRP_FDB,OUTGRP,X2XGRP_REC,ST)
	IF(ST.NE.0) THEN
	  CALL OS32ER(5,X2XGRP_NAME,'READW',ST,OUTGRP)
	  PAUSE
	ENDIF
*
* BUILD THE DOWNLINE HEADER PORTION.
*
	CALL ISBYTE(GNHDRMES_PROTID_VAL,MESS,GNDWNMES_PROTID-1)
	CALL I4TOBUF2(MESTYP,MESS,GNDWNMES_MESTYP-1)
	CALL ISBYTE(SUBTYP,MESS,GNDWNMES_SUBTYP-1)
	CALL I4TOBUF2(MSGID,MESS,GNDWNMES_MSGID-1)
	CALL I4TOBUF2(MSGSEQ,MESS,GNDWNMES_SEQNUM-1)
	CALL I4TOBUF2(GNDWNMES_CMDDTA,MESS,GNDWNMES_DATOFF-1)
	CURTIM=P(ACTTIM)
	CALL I4TOBUF4(CURTIM,MESS,GNDWNMES_TIME-1)
	CALL ISBYTE(GNDWNMES_FLAGS_DATA,MESS,GNDWNMES_FLAGS-1)
	CALL ISBYTE(0,MESS,GNDWNMES_CMDSTS-1)
	CALL ISBYTE(0,MESS,GNDWNMES_CMDDTA-1)
	OFF=GNDWNMES_CMDDTA
*
* BUILD OUTPUT DATA MESSAGE PORTION.
*
	CALL I4TOBUF2(OUTGRP,MESS,OFF+GNGRPMES_NUMBER-1)
	CALL I4TOBUF4(X2XGRP_IDESC(1),MESS,OFF+GNGRPMES_DESC-1)
	CALL I4TOBUF4(X2XGRP_IDESC(2),MESS,OFF+GNGRPMES_DESC-1+4)
	CALL I4TOBUF4(X2XGRP_IDESC(3),MESS,OFF+GNGRPMES_DESC-1+8)
*
* STORE MESSAGE LENGTH INTO MESSAGE HEADER.
*
	MESLEN=OFF+GNGRPMES_DESC+11
	CALL I4TOBUF2(MESLEN,MESS,GNDWNMES_MESLEN-1)
*
* SEND MESSAGE TO TCP/IP.
*
	CALL TCP_SNDBUF(MESS,MESLEN)
*
* PROGRAM EXIT.
*
8000	CONTINUE
	RETURN
	END
